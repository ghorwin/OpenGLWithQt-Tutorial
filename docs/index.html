<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Andreas Nicolai">
<title>OpenGL + Qt Tutorial</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(https://fonts.googleapis.com/css?family=Roboto+Condensed);
@import url(https://asciidoctor.org/stylesheets/asciidoctor.css); /* Default asciidoc style framework - important */

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#a90e22;
--secondarycolor:#333333;
--tertiarycolor: #772953;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
body{font-family: "Roboto Condensed",sans-serif;}

h1,h2{color:var(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;}
h3,h4,h5,h6{color:var(--secondarycolor);font-family: "Roboto Condensed",sans-serif;}
.title{color:(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Roboto Condensed",sans-serif ! important}
#toc.toc2 a{font-family:"Roboto Condensed",sans-serif;}
/*#toc.toc2 a:link{color:(--linkcolor) !important}
a:visited {color: #ffdbad;}
a.bare:visited {color: #204f83;}
a:hover {color: #317ed4;}
#toc.toc2 a:hover {color: #f1b464;}*/
/* code{background-color: var(--secondarycolor) !important;color:var(--white)} */
code,kbd,pre,samp{font-family:monospace;font-size:0.8em}

/* Table styles */
th{background-color: var(--tertiarycolor);color:var(--white) !important;}

#toctitle{color:var(--primarycolor);font-family: "Roboto Condensed",sans-serif;font-size: 1.6875em;}
#toc.toc2{background-color:#f4f8fd;}
/*#toc.toc2{background-color:#2C001E;color:white;}
#toc.toc2.a{color:white;}
*/

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>OpenGL + Qt Tutorial</h1>
<div class="details">
<span id="author" class="author">Andreas Nicolai</span><br>
<span id="email" class="email"><a href="mailto:andreas.nicolai@tu-dresden.de">andreas.nicolai@tu-dresden.de</a></span><br>
<span id="revnumber">version 0.7.0,</span>
<span id="revdate">April 2020</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Inhaltsverzeichnis</div>
<ul class="sectlevel1">
<li><a href="#_einführung">Einführung</a>
<ul class="sectlevel2">
<li><a href="#_kernthemen">Kernthemen</a></li>
<li><a href="#_plattformunterstützung_und_opengl_version">Plattformunterstützung und OpenGL-Version</a></li>
<li><a href="#_grundlagen">Grundlagen</a></li>
</ul>
</li>
<li><a href="#_tutorial_01_opengl_innerhalb_eines_qwindow">1. Tutorial 01: OpenGL innerhalb eines QWindow</a>
<ul class="sectlevel2">
<li><a href="#_qwidget_näher_betrachtet">1.1. QWidget näher betrachtet</a></li>
<li><a href="#_allgemeingültige_basisklasse_für_opengl_render_fenster">1.2. Allgemeingültige Basisklasse für OpenGL-Render-Fenster</a>
<ul class="sectlevel3">
<li><a href="#_initialisierung_des_opengl_fensters">1.2.1. Initialisierung des OpenGL-Fensters</a></li>
</ul>
</li>
<li><a href="#_implementierung_eines_konkreten_renderfensters">1.3. Implementierung eines konkreten Renderfensters</a>
<ul class="sectlevel3">
<li><a href="#_shaderprogramme">1.3.1. Shaderprogramme</a></li>
<li><a href="#_vertex_buffer_objekte_vbo_und_vertex_array_objekte_vba">1.3.2. Vertex-Buffer-Objekte (VBO) und Vertex-Array-Objekte (VBA)</a></li>
<li><a href="#_rendern">1.3.3. Rendern</a></li>
<li><a href="#_resourcenfreigabe">1.3.4. Resourcenfreigabe</a></li>
</ul>
</li>
<li><a href="#_das_hauptprogramm">1.4. Das Hauptprogramm</a></li>
</ul>
</li>
<li><a href="#_tutorial_02_alternative_die_klasse_qopenglwindow">2. Tutorial 02: Alternative: die Klasse QOpenGLWindow</a>
<ul class="sectlevel2">
<li><a href="#_verwendung_der_klasse">2.1. Verwendung der Klasse</a></li>
<li><a href="#_die_implementierung_der_klasse_qopenglwindow">2.2. Die Implementierung der Klasse QOpenGLWindow</a>
<ul class="sectlevel3">
<li><a href="#_constructor">2.2.1. Constructor</a></li>
<li><a href="#_ereignisbehandlungsroutinen">2.2.2. Ereignisbehandlungsroutinen</a></li>
<li><a href="#_initialisierung">2.2.3. Initialisierung</a></li>
</ul>
</li>
<li><a href="#_zeichnen_mit_index_elementpuffern">2.3. Zeichnen mit Index-/Elementpuffern</a>
<ul class="sectlevel3">
<li><a href="#_shaderprogramm">2.3.1. Shaderprogramm</a></li>
<li><a href="#_initialisierung_von_gemischten_vertex_puffern">2.3.2. Initialisierung von gemischten Vertex-Puffern</a></li>
<li><a href="#_element_indexpuffer">2.3.3. Element-/Indexpuffer</a></li>
<li><a href="#_attribute_im_gemischten_vertexarray">2.3.4. Attribute im gemischten Vertexarray</a></li>
<li><a href="#_freigabe_der_puffer">2.3.5. Freigabe der Puffer</a></li>
<li><a href="#_rendern_2">2.3.6. Rendern</a></li>
</ul>
</li>
<li><a href="#_zusammenfassung">2.4. Zusammenfassung</a></li>
</ul>
</li>
<li><a href="#_tutorial_03_renderfenster_in_einem_qdialog_eingebettet">3. Tutorial 03: Renderfenster in einem QDialog eingebettet</a>
<ul class="sectlevel2">
<li><a href="#_window_container_widgets">3.1. Window Container Widgets</a></li>
<li><a href="#_interaktion_und_synchronisation_mit_dem_zeichnen">3.2. Interaktion und Synchronisation mit dem Zeichnen</a>
<ul class="sectlevel3">
<li><a href="#_einmalige_änderungen_farbwechsel_auf_knopfdruck">3.2.1. Einmalige Änderungen: Farbwechsel auf Knopfdruck</a></li>
<li><a href="#_animierte_farbänderung">3.2.2. Animierte Farbänderung</a></li>
<li><a href="#_zusammenfassung_2">3.2.3. Zusammenfassung</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tutorial_04_verwendung_des_qopenglwidget">4. Tutorial 04: Verwendung des QOpenGLWidget</a>
<ul class="sectlevel2">
<li><a href="#_was_bietet_das_qopenglwidget">4.1. Was bietet das QOpenGLWidget</a>
<ul class="sectlevel3">
<li><a href="#_anpassung_der_vererbungshierarchie">4.1.1. Anpassung der Vererbungshierarchie</a></li>
<li><a href="#_initialisierung_2">4.1.2. Initialisierung</a></li>
<li><a href="#_einbettung_in_ein_anderes_qwidget">4.1.3. Einbettung in ein anderes QWidget</a></li>
</ul>
</li>
<li><a href="#_performance_vergleich">4.2. Performance-Vergleich</a></li>
<li><a href="#_transparenz">4.3. Transparenz</a>
<ul class="sectlevel3">
<li><a href="#_mit_qopenglwidget">4.3.1. Mit QOpenGLWidget</a></li>
<li><a href="#_mit_qwindow_basierten_opengl_renderfenstern">4.3.2. Mit QWindow-basierten OpenGL Renderfenstern</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tutorial_05_maus_und_tastatureingaben">5. Tutorial 05: Maus- und Tastatureingaben</a>
<ul class="sectlevel2">
<li><a href="#_überblick">5.1. Überblick</a></li>
<li><a href="#_fenster_basisklasse_openglwindow">5.2. Fenster-Basisklasse OpenGLWindow</a></li>
<li><a href="#_klasse_sceneview_die_konkrete_implementierung">5.3. Klasse SceneView - die konkrete Implementierung</a>
<ul class="sectlevel3">
<li><a href="#_klassendeklaration">5.3.1. Klassendeklaration</a></li>
<li><a href="#_das_aktualisierungskonzept">5.3.2. Das Aktualisierungskonzept</a></li>
<li><a href="#_verwendung_der_klasse_sceneview">5.3.3. Verwendung der Klasse <em>SceneView</em></a></li>
<li><a href="#_implementierung_der_klasse_sceneview">5.3.4. Implementierung der Klasse <em>SceneView</em></a></li>
<li><a href="#_opengl_initialisierung">5.3.5. OpenGL-Initialisierung</a></li>
</ul>
</li>
<li><a href="#_tastatur_und_mauseingabe">5.4. Tastatur- und Mauseingabe</a>
<ul class="sectlevel3">
<li><a href="#_der_tastatur_und_maus_zustandsmanager">5.4.1. Der Tastatur- und Maus-Zustandsmanager</a></li>
<li><a href="#_die_ereignisschleife_und_tastatur_mausevents">5.4.2. Die Ereignisschleife und Tastatur-/Mausevents</a></li>
<li><a href="#_auswertung_der_eingabe_und_anpassung_der_kameraposition_und_ausrichtung">5.4.3. Auswertung der Eingabe und Anpassung der Kameraposition- und Ausrichtung</a></li>
<li><a href="#_auf_gedrückte_tasten_reagieren">5.4.4. Auf gedrückte Tasten reagieren</a></li>
</ul>
</li>
<li><a href="#_shaderprogramme_2">5.5. Shaderprogramme</a></li>
<li><a href="#_transformationsmatrizen_und_kamera">5.6. Transformationsmatrizen und Kamera</a>
<ul class="sectlevel3">
<li><a href="#_transformationen">5.6.1. Transformationen</a></li>
<li><a href="#_aktualisierung_der_world2view_matrix">5.6.2. Aktualisierung der World2View Matrix</a></li>
</ul>
</li>
<li><a href="#_zeichenobjekte">5.7. Zeichenobjekte</a>
<ul class="sectlevel3">
<li><a href="#_effizientes_zeichnen_großer_geometrien">5.7.1. Effizientes Zeichnen großer Geometrien</a></li>
<li><a href="#_verwaltung_von_zeichenobjekten">5.7.2. Verwaltung von Zeichenobjekten</a></li>
<li><a href="#_zeichenobjekt_1_gitterraster_in_x_z_ebene">5.7.3. Zeichenobjekt #1: Gitterraster in X-Z Ebene</a></li>
<li><a href="#_zeichenobjekt_2_viele_viele_boxen">5.7.4. Zeichenobjekt #2: Viele viele Boxen</a></li>
</ul>
</li>
<li><a href="#_antialiasing">5.8. Antialiasing</a></li>
</ul>
</li>
<li><a href="#_tutorial_06_fehlerbehandlung_und_und_profiling_mit_qopengldebuglogger_und_qopengltimemonitor">6. Tutorial 06: Fehlerbehandlung und und Profiling mit QOpenGLDebugLogger und QOpenGLTimeMonitor</a>
<ul class="sectlevel2">
<li><a href="#_fehlerbehandlung">6.1. Fehlerbehandlung</a>
<ul class="sectlevel3">
<li><a href="#_exceptions_und_qt">6.1.1. Exceptions und Qt</a></li>
<li><a href="#_qt_messagehandler">6.1.2. Qt-MessageHandler</a></li>
<li><a href="#_qopengldebuglogger">6.1.3. QOpenGLDebugLogger</a></li>
</ul>
</li>
<li><a href="#_profiling_und_performance_tuning">6.2. Profiling und Performance-Tuning</a>
<ul class="sectlevel3">
<li><a href="#_gpu_und_cpu_profiling">6.2.1. GPU und CPU Profiling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tutorial_07_markierenauswählen_von_flächen">7. Tutorial 07: Markieren/Auswählen von Flächen</a>
<ul class="sectlevel2">
<li><a href="#_option_1_strahlenverfolgung">7.1. Option 1: Strahlenverfolgung</a>
<ul class="sectlevel3">
<li><a href="#_erkennung_von_mausklick_ereignissen">7.1.1. Erkennung von Mausklick-Ereignissen</a></li>
<li><a href="#_finden_von_angeklickten_objekten">7.1.2. Finden von angeklickten Objekten</a></li>
<li><a href="#_die_pick_implementierung">7.1.3. Die pick-Implementierung</a></li>
<li><a href="#_picking_performance">7.1.4. Picking Performance</a></li>
<li><a href="#_einfärben_ausgewählter_objekte">7.1.5. Einfärben ausgewählter Objekte</a></li>
</ul>
</li>
<li><a href="#_option_2_falschfarbenrendering">7.2. Option 2: Falschfarbenrendering</a>
<ul class="sectlevel3">
<li><a href="#_optimierungsidee_für_quasi_statische_szenen">7.2.1. Optimierungsidee für quasi-statische Szenen</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tutorial_08_texturen_mit_qopengltexture">8. Tutorial 08: Texturen mit QOpenGLTexture</a>
<ul class="sectlevel2">
<li><a href="#_initialisierung_von_texturen">8.1. Initialisierung von Texturen</a>
<ul class="sectlevel3">
<li><a href="#_shader_texture_verknüpfung">8.1.1. Shader-Texture-Verknüpfung</a></li>
</ul>
</li>
<li><a href="#_verwendung_der_texture">8.2. Verwendung der Texture</a>
<ul class="sectlevel3">
<li><a href="#_shader">8.2.1. Shader</a></li>
<li><a href="#_einbinden_der_texturen">8.2.2. Einbinden der Texturen</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tutorial_09_render_in_eine_framebuffer_und_verwendung_von_kernel_effekten">9. Tutorial 09: Render in eine Framebuffer und Verwendung von Kernel Effekten</a>
<ul class="sectlevel2">
<li><a href="#_initialisierung_des_framebuffers">9.1. Initialisierung des Framebuffers</a></li>
<li><a href="#_größenanpassung">9.2. Größenanpassung</a></li>
<li><a href="#_rendern_in_den_framebuffer">9.3. Rendern in den Framebuffer</a></li>
</ul>
</li>
<li><a href="#_tutorial_10_shadowmapsmehrfach_render_passes_und_qopenglframebufferobject">10. Tutorial 10: Shadowmaps/Mehrfach-Render-Passes und QOpenGLFramebufferObject</a></li>
<li><a href="#_tutorial_xx_cmake_als_buildsystem_für_qt_und_opengl_und_deployment_von_qtopengl_anwendungen">11. Tutorial xx: CMake als BuildSystem für Qt und OpenGL, und Deployment von Qt+OpenGL Anwendungen</a>
<ul class="sectlevel2">
<li><a href="#_cmakelists_txt_für_opengl_anwendungen">11.1. CMakeLists.txt für OpenGL-Anwendungen</a>
<ul class="sectlevel3">
<li><a href="#_erstellung">11.1.1. Erstellung</a></li>
<li><a href="#_deployment">11.1.2. Deployment</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_einführung">Einführung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dieses Tutorial ist <strong><em>kein</em></strong> OpenGL Tutorial. Man sollte also OpenGL selbst schon ganz gut kennen. Natürlich kann man die hier vorgestellten Beispiele als Vorlage nehmen, aber es geht hier wirklich darum, die Qt-Klassen und vorbereitete Funktionalität zu verstehen und sinnvoll zu nutzen.</p>
</div>
<div class="paragraph">
<p>Diese Anleitung soll auch <strong><em>nicht</em></strong> zeigen, wie man mit Qt ein Spiel- oder eine Spieleengine schreibt. Es geht eher um technische Anwendungen, in denen <em>Animationen keine Rolle spielen</em>. Fokus liegt eher darauf, effizient und resourcenschonend (und damit Laptop-Akku-schonend) 3D Grafik zu verwenden.</p>
</div>
<div class="paragraph">
<p>Es gibt eine PDF-Version des Tutorials:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/raw/master/docs/OpenGLQtTutorial.pdf" class="bare">https://github.com/ghorwin/OpenGLWithQt-Tutorial/raw/master/docs/OpenGLQtTutorial.pdf</a></p>
</div>
<div class="paragraph">
<p>Die Quelltexte (und Inhalte dieses Tutorials) liegen auf github:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial" class="bare">https://github.com/ghorwin/OpenGLWithQt-Tutorial</a></p>
</div>
<div class="paragraph">
<p>Fragen und Anregungen kann man in der Issues-Seite auf Githab eintragen, die kann man ja wie ein Diskussionsforum verwenden, nur dass die nie geschlossen werden :-)</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/issues" class="bare">https://github.com/ghorwin/OpenGLWithQt-Tutorial/issues</a></p>
</div>
<div class="sect2">
<h3 id="_kernthemen">Kernthemen</h3>
<div class="paragraph">
<p>In diesem Tutorial geht es primär um folgende Themen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Integration von OpenGL in eine Qt Widget Anwendung (es werden verschiedene Ansätze diskutiert), einschließlich Fehlerbehandlung</p>
</li>
<li>
<p>Verwendung der Qt-Wrapper-Klassen als Ersatz für native OpenGL Aufrufe (die Dokumentation vieler OpenGL-Qt-Klassen ist bisweilen etwas dürftig)</p>
</li>
<li>
<p>Implementierung von Keyboard- und Maussteuerung</p>
</li>
<li>
<p>Rendering-on-Demand mit Fokus auf CAD/Virtual Design Anwendungen, d.h. batterieschonendes Rendern nur, wenn sich Camera oder Scene ändern</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Letzteres wird auch dadurch erreicht, dass wirklich nur die 3D Scene gerendert wird, aber alle sonstigen Eingaben separat in klassischen Widgets erfolgen. Bei klassischen Ansätzen (z.B. unter Verwendung von 3D Engines) werden Dialoge, Eingabefelder, Datenelemente alle als Teil der 3D Szene umgesetzt, sodass bereits beim Tippen einer Zahl in ein Eingabefeld ständig neu gerendert werden muss. In Summe ergibt das eine sinnlose Energieverschwendung und Akkulaufzeitreduktion (nicht zu vergessen das nervige fönen des Laptop-Akkus).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es wird eine hinreichend aktuelle Qt-Version vorausgesetzt, mindestens <strong>Qt 5.4</strong>. Bei meinem Ubuntu 18.04 System ist Qt 5.9 dabei, das dürfte also eine gute Basisversion für dieses Tutorial sein. Funktionen neuerer Qt Versionen betrachte ich nicht.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Qt enthält aus Kompatibilitätsgründen noch eine Reihe von OpenGL-Implementierungsklassen (im OpenGL Modul), welche alle mit <code>QGL...</code> beginnen. Diese sind veraltet und sollten in neuen Programmen nicht mehr verwendet werden. In aktuellen Qt Programmen sind die Hilfsklassen für OpenGL-Fenster im GUI-Modul enthalten.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_plattformunterstützung_und_opengl_version">Plattformunterstützung und OpenGL-Version</h3>
<div class="paragraph">
<p>Das Tutorial addressiert Desktopanwendungen, d.h. <em>Linux</em>, <em>Windows</em> und <em>MacOS</em> Widgets-Anwendungen. Daher ist OpenGL ES (ES für Embedded Systems) kein Thema für dieses Tutorial. Das Wesentliche sollte aber übertragbar sein.</p>
</div>
<div class="paragraph">
<p>Hinsichtlich der OpenGL-Version wird Mac-bedingt Version 3.3 angepeilt. Hinsichtlich der Einbettung von OpenGL in Qt Widgets-Anwendungen spielt die OpenGL-Version eigentlich keine Rolle.</p>
</div>
<div class="paragraph">
<p>Im Rahmen dieses Tutorials wird für die Beispiele das Qt bzw. qmake Buildsystem verwendet. Das Thema <em>Compilieren mit CMake</em> und <em>Deployment von OpenGL-basierten Anwendungen</em> wird in einem speziellen Tutorial erklärt.</p>
</div>
</div>
<div class="sect2">
<h3 id="_grundlagen">Grundlagen</h3>
<div class="paragraph">
<p>Als Einstieg in OpenGL empfehle ich folgende (englischsprachige) Webseiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://learnopengl.com" class="bare">https://learnopengl.com</a> : ein gutes und aktuelles Tutorial mit guten Abbildungen und guter Mischung aus C++ und C, eine Lektüre der ersten paar Kapitel dieses Tutorials sollte eigentlich ausreichen, um alle in meinem Tutorial verwendeten OpenGL-Befehle und Techniken zu verstehen.</p>
</li>
<li>
<p><a href="http://antongerdelan.net/opengl" class="bare">http://antongerdelan.net/opengl</a> : englisch, gute Illustrationen und Erklärungen zu einzelnen Themen</p>
</li>
<li>
<p><a href="http://www.opengl-tutorial.org" class="bare">http://www.opengl-tutorial.org</a> : eher grundlegendes Tutorialset, C und GLUT werden verwendet</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mein Tutorial selbst basiert zum Teil auf folgenden Webtutorials:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.trentreed.net/blog/qt5-opengl-part-0-creating-a-window" class="bare">https://www.trentreed.net/blog/qt5-opengl-part-0-creating-a-window</a> : in diesem Tutorial und den Forumkommentaren gibt es einige Anregungen, allerdings ist dies eher eine Dokumentation eigener Versuche grafisch optimale Effekte zu erziehlen. Es gibt durchaus interessante Anregungen. Manche Quelltextumsetzung sind nicht ganz optimal, daher mit Vorsicht als Vorlage für eigene Programme verwenden (Diese Kleinigkeiten, über die ich selber auch gestolpert bin, sind u.A. der Grund für dieses Tutorial).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_01_opengl_innerhalb_eines_qwindow">1. Tutorial 01: OpenGL innerhalb eines QWindow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Das Ziel ist erstmal einfach: ein einfarbiges Dreieck mit OpenGL in einem <code>QWindow</code> zu zeichnen.</p>
</div>
<div class="paragraph">
<p>Das sieht dann so (noch ziemlich langweilig) aus, reicht aber aus, um mehrere Seiten Tutorialtext zu füllen :-)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_01_mac.png" alt="Tutorial_01">
</div>
<div class="title">Figure 1. Ausgabe: Tutorial_01 (Mac OS Screenshot)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_01">Tutorial_01</a></p>
</div>
<div class="paragraph">
<p><code>.pro</code>-Datei in Qt Creator öffnen und compilieren.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das Tutorial selbst basiert zum einen auf dem Qt Beispiel "OpenGLWindow" und auf dem Tutorial <a href="https://learnopengl.com/Getting-started/Hello-Triangle" class="bare">https://learnopengl.com/Getting-started/Hello-Triangle</a>.</p>
</div>
<div class="paragraph">
<p>Beim Rendern von OpenGL Inhalten mit Qt gibt es verschiedene Möglichkeiten. Hier soll zunächst ein <code>QWindow</code> verwendet werden, welches ein natives Fenster des jeweiligen Betriebssystems kapselt. Damit kann man also ziemlich direkt und plattformnah zeichnen.</p>
</div>
<div class="sect2">
<h3 id="_qwidget_näher_betrachtet">1.1. QWidget näher betrachtet</h3>
<div class="paragraph">
<p>Um ein QWidget zu verwenden, muss man die Klasse ableiten und sollte dann einige Funktionen implementieren. Eine minimalistische Klassendeklaration sähe z.B. so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">OpenGLWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWindow</span> <span class="p">{</span>
	<span class="n">Q_OBJECT</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// ... other public members ...</span>

<span class="nl">protected:</span>
	<span class="kt">bool</span> <span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="c1">// ... private members ...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das Makro <code>Q_DECL_OVERRIDE</code> wird zum Schlüsselwort <code>override</code>, wenn der Compiler dies unterstützt (C++11 erlaubt). Da das eigentlich bei Qt 5 vorausgesetzt werden kann, könnte man eigentlich immer gleich <code>override</code> schreiben.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Man kann entweder mit einem rasterbasierten QPainter zeichnen, oder eben mit OpenGL. Dies legt man am besten im Constructor der Klasse fest, wie beispielsweise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">QWindow</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setSurfaceType</span><span class="p">(</span><span class="n">QWindow</span><span class="o">::</span><span class="n">OpenGLSurface</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Durch Aufruf der Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#setSurfaceType">setSurfaceType(QWindow::OpenGLSurface)</a> legt man fest, dass man ein natives OpenGL-Window erstellen möchte.</p>
</div>
<div class="paragraph">
<p>Das Qt Framework sendet nun zwei für uns interessante Events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QEvent::UpdateRequest</code> - wir sollten das Widget neu zeichnen</p>
</li>
<li>
<p><code>QEvent::Expose</code> - das Fenster (oder ein Teil davon) ist nun sichtbar und sollte aktualisiert werden</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Für letzteres Event existiert eine überladene Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#exposeEvent">void exposeEvent(QExposeEvent *event)</a>, welche wir implementieren:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span> <span class="cm">/*event*/</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">renderNow</span><span class="p">();</span> <span class="c1">// simply redirect call to renderNow()</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wir leiten einfach die Anfrage an das Zeichnen des Bildes an eine Funktion weiter, die das macht (dazu kommen wir gleich).</p>
</div>
<div class="paragraph">
<p>In der Implementierung der generischen Ereignisbehandlungsfunktion <code>event()</code> picken wir uns nur das <code>UpdateRequest</code>-Ereignis heraus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>
    	<span class="k">case</span> <span class="n">QEvent</span><span class="p">:</span><span class="o">:</span><span class="n">UpdateRequest</span><span class="o">:</span>
    		<span class="n">renderNow</span><span class="p">();</span> <span class="c1">// now render the image</span>
		    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	    <span class="nl">default:</span>
		    <span class="k">return</span> <span class="n">QWindow</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Damit wäre dann unsere Aufgabe klar - eine Funktion <code>renderNow()</code> zu implementieren, die mit OpenGL zeichnet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_allgemeingültige_basisklasse_für_opengl_render_fenster">1.2. Allgemeingültige Basisklasse für OpenGL-Render-Fenster</h3>
<div class="paragraph">
<p>Die nachfolgend beschriebene Funktionalität kann man für beliebige OpenGL-Anwendungen nachnutzen, daher wird das ganze in Form einer abstrakten Basisklasse <code>OpenGLWindow</code> implementiert.</p>
</div>
<div class="paragraph">
<p>Wir erweitern die Klassendeklaration geringfügig:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">OpenGLWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWindow</span><span class="p">,</span> <span class="k">protected</span> <span class="n">QOpenGLFunctions</span> <span class="p">{</span>
	<span class="n">Q_OBJECT</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">initialize</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">renderLater</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">renderNow</span><span class="p">();</span>

<span class="nl">protected:</span>
	<span class="kt">bool</span> <span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

	<span class="n">QOpenGLContext</span> <span class="o">*</span><span class="n">m_context</span><span class="p">;</span> <span class="c1">// wraps the OpenGL context</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Zugriff auf die nativen OpenGL Funktionen ist in Qt in der Klasse <code>QOpenGLFunctions</code> gekapselt. Diese kann entweder als Datenmember gehalten werden, oder eben wie oben gezeigt als Implementierung vererbt werden. Da es sich ja um ein <code>OpenGLWindow</code> handelt, fühlt sich das mit der Vererbung schon richtig an.</p>
</div>
<div class="paragraph">
<p>Es gibt zwei pur virtuelle Funktionen, <code>initialize()</code> und <code>render()</code>, ohne die kein OpenGL-Programm auskommt. Daher verlangen wir von Nutzern dieser Basisklasse, dass sie diese Funktionen bereitstellen (Inhalt wird später erläutert).</p>
</div>
<div class="paragraph">
<p>Neben der Funktion <code>renderNow()</code>, welche ja oben bereits aufgerufen wurde, und deren Aufgabe das <em>sofortige</em> OpenGL-Zeichnen ist, gibt es noch eine weitere Funktion <code>renderLater()</code>. Deren Aufgabe ist es letztlich, einen Neu-Zeichen-Aufruf passend zum Vertical-Sync anzufordern, was letztlich dem Absenden eines <code>UpdateRequest</code>-Ereignisses in die Anwendungs-Ereignis-Schleife entspricht. Das macht die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#requestUpdate">requestUpdate()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">renderLater</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Schedule an UpdateRequest event in the event loop</span>
	<span class="c1">// that will be send with the next VSync.</span>
	<span class="n">requestUpdate</span><span class="p">();</span> <span class="c1">// call public slot requestUpdate()</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Man kann sich strenggenommen die Funktion auch sparen, und direkt den Slot <code>requestUpdate()</code> aufrufen, aber die Benennung zeigt letztlich an, dass erst beim nächsten VSync gezeichnet wird.</p>
</div>
<div class="paragraph">
<p>Zur Synchronisation mit Bildwiederholraten kann man an dieser Stelle schon einmal zwei Dinge vorwegnehmen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>es wird doppelgepuffert gezeichnet</p>
</li>
<li>
<p>Qt ist standardmäßig zu konfiguriert, dass das <code>QEvent::UpdateRequest</code> immer zu einem VSync gesendet wird. Es wird natürlich bei einer Bildwiederholfrequenz von 60Hz vorausgesetzt, dass die Zeit bis zum Umschalten des Zeichenpuffers nicht mehr als ~16 ms ist.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Variante mit dem Absenden des <code>UpdateRequest</code> in die Ereignisschleife hat den Vorteil, dass mehrere Aufrufe dieser Funktion (z.B. via Signal-Slot-Verbindung) innerhalb eines Sync-Zyklus (d.h. innerhalb von 16ms) letztlich zu einem Ereignis zusammengefasst werden, und so nur <em>einmal</em> je VSync gezeichnet wird. Wäre sonst ja auch eine Verschwendung von Rechenzeit.</p>
</div>
<div class="paragraph">
<p>Zuletzt sei noch auf die neuen private Membervariable <code>m_context</code> hingewiesen. Dieser Kontext kapselt letztlich den nativen OpenGL Kontext, d.h. den Zustandsautomaten, der bei OpenGL verwendet wird. Obwohl dieser dynamisch erzeugt wird, brauchen wir keinen  Destruktor, da wir über die QObject-Eltern-Beziehung auch automatisch <code>m_context</code> mit aufräumen.</p>
</div>
<div class="paragraph">
<p>Im Konstruktor initialisieren wir die Zeigervariable mit einem nullptr.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">QWindow</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
	<span class="n">m_context</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setSurfaceType</span><span class="p">(</span><span class="n">QWindow</span><span class="o">::</span><span class="n">OpenGLSurface</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung_des_opengl_fensters">1.2.1. Initialisierung des OpenGL-Fensters</h4>
<div class="paragraph">
<p>Es gibt nun verschiedenen Möglichkeiten, das OpenGL-Zeichenfenster zu initialisieren. Man könnte das gleich im Konstruktor tun, wobei dann allerdings alle dafür benötigten Resourcen (auch eventuell Meshes/Texturen, &#8230;&#8203;) bereits initialisiert sein sollten. Für ein schnellen Anwendungsstart wäre das hinderlich. Besser ist es, dies später zu machen.</p>
</div>
<div class="paragraph">
<p>Man könnten nun eine eigene Initialisierungsfunktion implementieren, die der Nutzer der Klasse anfänglich aufruft. Oder man regelt dies beim allerersten Anzeigen des Fensters. Hier gibt es einiges an Spielraum und je nach Komplexität und Fehleranfälligkeit der Initialisierung ist die Variante mit einer expliziten Initialisierungsfunktion sicher gut.</p>
</div>
<div class="paragraph">
<p>Hier wird die Variante der Initialisierung-bei-erster-Verwendung genutzt (was nebenbei ja ein übliches Pattern bei Verwendung von Dialogen in Qt ist). Damit ist die Funktion <code>renderNow()</code> gefordert, die Initialisierung anzustoßen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">renderNow</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// only render if exposed</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isExposed</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="kt">bool</span> <span class="n">needsInitialize</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="c1">// initialize on first call</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_context</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLContext</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
		<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">requestedFormat</span><span class="p">());</span>
		<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">();</span>

		<span class="n">needsInitialize</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needsInitialize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">initializeOpenGLFunctions</span><span class="p">();</span>
		<span class="n">initialize</span><span class="p">();</span> <span class="c1">// call user code</span>
	<span class="p">}</span>

	<span class="n">render</span><span class="p">();</span> <span class="c1">// call user code</span>

	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">swapBuffers</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion wird einmal von <code>exposeEvent()</code> und von <code>event()</code> aufgerufen. In beiden Fällen sollte nur gezeichnet werden, wenn das Fenster tatsächlich sichtbar ist. Daher wird über die Funtion <code>isExposed()</code> zunächst geprüft, ob es überhaupt zu sehen ist. Wenn nicht, dann raus.</p>
</div>
<div class="paragraph">
<p>Jetzt kommt die oben angesprochene Initialisierung-bei-erster-Benutzung. Zuerst wird das <code>QOpenGLContext</code> Objekt erstellt. Als nächstes werden verschiedene OpenGL-spezifische Anforderungen gesetzt, wobei die im QWindow-gesetzten Formate an den QOpenGLContext übergeben werden.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#requestedFormat">requestedFormat()</a> liefert das für das <code>QWindow</code> eingestellte Format der Oberfläche (<code>QSurfaceFormat</code> zurück. Dieses enthält Einstellungen zu den Farb- und Tiefenpuffern, und auch zum Antialiasing des OpenGL-Renderes.</p>
</div>
<div class="paragraph">
<p>Zum Zeitpunkt der Initialisierung des OpenGL-Context muss also dieses Format bereits für das QWindow festgelegt worden sein, d.h. <em>bevor</em> das erste Mal <code>show()</code> für das OpenGLWindow aufgerufen wird.</p>
</div>
<div class="paragraph">
<p>Wenn man diese Fehlerquelle vermeiden will, muss man die Initialisierung unter Anforderung des gewünschten <code>QSurfaceFormat</code> tatsächlich in eine spezielle Funktion verschieben.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mit dem Aufruf von <code>m_context-&gt;create()</code> wird der OpenGL Kontext (also Zustand) erstellt, wobei die vorab gesetzten Formatparameter verwendet werden.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Falls man später die Formatparameter ändern möchte (z.B. Antialiasing), so muss zunächst wieder das Format im Kontextobjekt neu gesetzt werden und danach <code>create()</code> neu aufgerufen werden. Dies löscht und ersetzt dann den vorherigen Kontext.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nachdem der Kontext erzeugt wurde, stehen die wohl wichtigsten Funktionen <code>makeCurrent()</code> und <code>swapBuffers()</code> zur Verfügung.</p>
</div>
<div class="paragraph">
<p>Der Aufruf <code>m_context-&gt;makeCurrent(this)</code> überträgt den Inhalt des Kontext-Objekts in den OpenGL-Zustand.</p>
</div>
<div class="paragraph">
<p>Der zweite Schritt der Initialisierung besteht im Aufruf der Funktion
<a href="https://doc.qt.io/qt-5/qopenglfunctions.html#initializeOpenGLFunctions">QOpenGLFunctions::initializeOpenGLFunctions()</a>. Hierbei werden letztlich die plattformspezifischen OpenGL-Bibliotheken dynamisch eingebunden und die Funktionszeiger auf die nativen OpenGL-Funktionen (<code>glXXX...</code>) geholt.</p>
</div>
<div class="paragraph">
<p>Zuletzt wird noch die Funktion <code>initialize()</code> mit nutzerspezifischen Initialisierungen aufgerufen.</p>
</div>
<div class="paragraph">
<p>Das eigentliche Rendern der 3D Szene muss der Anwender dann in der Funktion <code>render()</code> erledigen (dazu kommen wir gleich).</p>
</div>
<div class="paragraph">
<p>Am Ende tauschen wir noch mittels <code>m_context-&gt;swapBuffers(this)</code> den Fensterpuffer mit dem Renderpuffer aus.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Nachdem der Fensterpuffer aktualisiert wurde, kann das Fenster beliebig auf dem Bildschirm verschoben oder sogar minimiert werden, <em>ohne</em> dass wir neu rendern müssen. Dies gilt zumindest solange, bis wir anfangen, in der Szene mit Animationen zu arbeiten. Bei Anwendungen ohne Animationen ist es deshalb sinnvoll, nicht automaisch jeden Frame neu zu rendern, wie das bei Spieleengines wie Unity/Unreal/Irrlicht etc. gemacht wird.</p>
</div>
<div class="paragraph">
<p>Falls wir dennoch animieren wollen (und wenn es nur eine weiche Kamerafahrt wird), dann sollten wir am Ende der Funktion <code>renderNow()</code> die Funktion <code>renderLater()</code> aufrufen, und so beim nächsten VSync einen neuen Aufruf erhalten. Ach ja: wenn das Fenster versteckt ist (nicht <em>exposed</em>), dann würde natürlich die Funktion schnell verlassen werden, und die Funktion <code>renderLater()</code> wird nicht aufgerufen. Damit wäre dann die Animation gestoppt. Damit sie wieder losläuft, gibt es die implementierte Ereignisfunktion <code>exposeEvent()</code>, die das Rendering wieder anstößt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Damit wäre die zentrale Basisklasse für OpenGL-Renderfenster fertig. Wir testen das jetzt mit dem ganz am Anfang erwähnten primitiven Dreiecksbeispiel.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementierung_eines_konkreten_renderfensters">1.3. Implementierung eines konkreten Renderfensters</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Vor der Lektüre diese Abschnitts sollte man den Tutorialteil <a href="https://learnopengl.com/Getting-started/Hello-Triangle" class="bare">https://learnopengl.com/Getting-started/Hello-Triangle</a> überflogen haben (oder sich zumindest soweit mit OpenGL auskennen).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das konkrete Renderfenster heißt in diesem Beispiel <code>TriangleWindow</code> mit der Headerdatei <code>TriangleWindow.h</code>. Die Klassendeklaration ist recht kurz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cm">/*	This is the window that shows the triangle.
	We derive from our OpenGLWindow base class and implement the
	virtual initialize() and render() functions.
*/</span>
<span class="k">class</span> <span class="nc">TriangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">TriangleWindow</span><span class="p">();</span>
	<span class="o">~</span><span class="n">TriangleWindow</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">initialize</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

<span class="nl">private:</span>
	<span class="c1">// Wraps an OpenGL VertexArrayObject (VAO)</span>
	<span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="c1">// Vertex buffer (only positions now).</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vertexBufferObject</span><span class="p">;</span>

	<span class="c1">// Holds the compiled shader programs.</span>
	<span class="n">QOpenGLShaderProgram</span>		<span class="o">*</span><span class="n">m_program</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Interessant sind die privaten Membervariablen, die nachfolgend in der Implementierung der Klasse näher erläutert werden.</p>
</div>
<div class="sect3">
<h4 id="_shaderprogramme">1.3.1. Shaderprogramme</h4>
<div class="paragraph">
<p>Die Klasse <code>QOpenGLShaderProgram</code> kapselt ein Shaderprogramm und bietet verschiedene Bequemlichkeitsfunktionen, die in nativen OpenGL-Aufrufe umgesetzt werden.</p>
</div>
<div class="paragraph">
<p>Zuerst wird das Objekt erstellt:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">TriangleWindow</span><span class="o">::</span><span class="n">initialize</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// this function is called once, when the window is first shown, i.e. when</span>
	<span class="c1">// the the window content is first rendereds</span>

	<span class="c1">// build and compile our shader program</span>
	<span class="c1">// ------------------------------------</span>

	<span class="n">m_program</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLShaderProgram</span><span class="p">();</span>

    <span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dies entspricht in etwa den folgenden OpenGL-Befehlen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shaderProgram</span><span class="p">;</span>
<span class="n">shaderProgram</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt nun eine ganze Reihe von Möglichkeiten, Shaderprogramme hinzuzufügen. Für das einfache Dreieck brauchen wir nur ein Vertex-Shader und ein Fragment-Shaderprogramme. Die Implementierungen dieser Shader sind in zwei Dateien abgelegt:</p>
</div>
<div class="listingblock">
<div class="title">Vertex-Shader: shader/pass_through.vert</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// vertex shader</span>

<span class="c1">// input:  attribute named 'position' with 3 floats per vertex</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Fragment-Shader: shaders/uniform_color.frag</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// fragment shader</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>  <span class="c1">// output: fertiger Farbwert als rgb-Wert</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Vertexshader schiebt die Vertexkoordinaten (als vec3) einfach als vec4 ohne jede Transformation raus. Und der Fragmentationshader gibt einfach nur die gleiche Farbe (dunkles Rot) aus.</p>
</div>
<div class="sect4">
<h5 id="_compilieren_und_linken_von_shaderprogrammen">Compilieren und Linken von Shaderprogrammen</h5>
<div class="paragraph">
<p>Die nächsten Zeilen in der <code>initialize()</code> Funktion übersetzen die Shaderprogramme und linken die Programme:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span>
	    <span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Vertex</span><span class="p">,</span> <span class="s">":/shaders/pass_through.vert"</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Vertex shader errors :</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span>
	    <span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Fragment</span><span class="p">,</span> <span class="s">":/shaders/uniform_color.frag"</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Fragment shader errors :</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">())</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Shader linker errors :</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt mehrere überladene Funktionen <code>addShaderFromSourceFile()</code> in der Klasse <a href="https://doc.qt.io/qt-5/qopenglshaderprogram.html">QOpenGLShaderProgram</a>, hier wird die Variante mit Übernahme eines Dateinamens verwendet. Die Dateien sind in einer <code>.qrc</code> Resourcendatei referenziert und daher über die Resourcenpfade <code>:/shaders/...</code> angeben. Wichtig ist die Angabe des Typs des Shaderprogramms, hier <code>QOpenGLShader::Vertex</code> und <code>QOpenGLShader::Fragment</code>.</p>
</div>
<div class="paragraph">
<p>Erfolg oder Fehler wird über den Rückgabecode signalisiert. Das Thema Fehlerbehandlung wird aber in einem späteren Tutorial noch einmal aufgegriffen.</p>
</div>
<div class="paragraph">
<p>Letzter Schritt ist das Linken der Shaderprogramme, d.h. das Verknüpfen selbstdefinierter Variablen (Kommunikation zwischen Shaderprogrammen).</p>
</div>
<div class="paragraph">
<p>Die Funktionen der Klasse <code>QOpenGLShaderProgram</code> kapseln letztlich OpenGL-Befehle der Art:</p>
</div>
<div class="listingblock">
<div class="title">Native OpenGL Shaderprogramm-Initialisierung</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// create the shader</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexShader</span><span class="p">;</span>
<span class="n">vertexShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>

<span class="c1">// pass shader program in C string</span>
<span class="n">glShaderSource</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vertexShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// compile the shader</span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>

<span class="c1">// check success of compilation</span>
<span class="kt">int</span>  <span class="n">success</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">infoLog</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>

<span class="c1">// print out an error if any</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vertex shader error:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">infoLog</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// ... same for fragment shader</span>

<span class="c1">// attach shaders to shader program</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>

<span class="c1">// and link</span>
<span class="n">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Verglichen damit ist die Qt Variante mit "etwas" weniger Tippaufwand verbunden.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_vertex_buffer_objekte_vbo_und_vertex_array_objekte_vba">1.3.2. Vertex-Buffer-Objekte (VBO) und Vertex-Array-Objekte (VBA)</h4>
<div class="paragraph">
<p>Nachdem das Shaderprogramm fertig ist, erstellen wir zunächst ein Vertexpufferobjekt mit den Koordinaten des Dreiecks. Danach werden dann die Zuordnungen der Vertexdaten zu Attributen festgelegt. Und damit man diese Zuordnungen nicht immer wieder neu machen muss, merkt man sich diese in einem VertexArrayObject (VBA). Auf den ersten Blick ist das alles ganz schön kompliziert, daher machen wir das am Besten am Beispiel.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Vertexpufferobjekte (engl. <em>Vertex Buffer Objects (VBO)</em>) beinhalten letztlich die Daten, die an den Vertex-Shader gesendet werden. Aus Sicht von OpenGL müssen diese Objekte erst erstellt werden, dann gebunden werden (d.h. nachfolgende OpenGL-Befehle beziehen sich auf den Puffer), und dann wieder freigegeben werden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
		 <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
		 <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>
	<span class="p">};</span>

	<span class="c1">// create a new buffer for the vertices</span>
	<span class="n">m_vertexBufferObject</span> <span class="o">=</span> <span class="n">QOpenGLBuffer</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">VertexBuffer</span><span class="p">);</span> <span class="c1">// VBO</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">create</span><span class="p">();</span> <span class="c1">// create underlying OpenGL object</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span> <span class="c1">// must be called before allocate</span>

	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span> <span class="c1">// set it active in the context, so that we can write to it</span>
	<span class="c1">// int bufSize = sizeof(vertices) = 9 * sizeof(float) = 9*4 = 36 bytes</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="p">);</span> <span class="c1">// copy data into buffer</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im obigen Quelltext wird zunächst ein statisches Array mit 9 floats (3 x 3 Vektoren) definiert. Z-Koordinate ist jeweils 0. Nun erstellen wir ein neues VertexBufferObject vom Typ <code>QOpenGLBuffer::VertexBuffer</code>. Der Aufruf von <code>create()</code> erstellt das Objekt selbst und entspricht in etwa dem OpenGL-Aufruf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dann wird dem QOpenGLBuffer-Pufferobjekt noch die geplante Zugriffsart via <code>setUsagePattern()</code> mitgeteilt. Dies führt keinen OpenGL Aufruf aus, sondern es wird sich dieses Attribute für später gemerkt.</p>
</div>
<div class="paragraph">
<p>Mit dem Aufruf von <code>bind()</code> wird dieses VBO als Aktiv im OpenGL-Kontext gesetzt, d.h. nachfolgende Funktionsaufrufe mit Bezug auf VBOs beziehen sich auf unser erstelltes VBO. Dies entspricht dem OpenGL-Aufruf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zuletzt werden die Daten im Aufruf von <code>allocate()</code> in den Puffer kopiert. Dies entspricht in etwa einem memcpy-Befehl, d.h. Quelladresse des Puffers wird übergeben und Länge in Bytes as zweites Argument. In diesem Fall sind es 9 floats, d.h. 9*4=36 Bytes. Dies entspricht dem OpenGL-Befehl:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier wird der vorab gesetzte Verwendungstyp (usagePattern) verwendet. Deshalb ist es wichtig, <code>setUsagePattern()</code> immer <em>vor</em> <code>allocate()</code> aufzurufen.</p>
</div>
<div class="paragraph">
<p>Der Puffer ist nun gebunden und man könnte nun die Vertex-Daten mit den Eingangsparametern im Shaderprogramm verknüpfen. Da wir dies nicht jedesmal vorm Zeichnen erneut machen wollen, verwenden wir ein VertexArrayObject (VBA), welches letztlich so etwas wie ein Container für derartige Verknüpfungen darstellt. Man kann sich so ein VBA wie eine Aufzeichnung der nachfolgenden Verknüpfungsbefehle vorstellen, wobei der jeweils aktive Vertexpuffer und die verknüpften Variablen kollektiv gespeichert werden. Später beim eigentlichen Zeichnen muss man nur noch das VBA einbinden, welches unter der Haube dann alle aufgezeichneten Verknüpfungen abspielt und so den OpenGL-Zustand entsprechend wiederherstellt.</p>
</div>
<div class="paragraph">
<p>Konkret sieht das so aus:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="c1">// Initialize the Vertex Array Object (VAO) to record and remember subsequent attribute assocations with</span>
	<span class="c1">// generated vertex buffer(s)</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">create</span><span class="p">();</span> <span class="c1">// create underlying OpenGL object</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span> <span class="c1">// sets the Vertex Array Object current to the OpenGL context so it monitors attribute assignments</span>

	<span class="c1">// now all following enableAttributeArray(), disableAttributeArray() and setAttributeBuffer() calls are</span>
	<span class="c1">// "recorded" in the currently bound VBA.</span>

	<span class="c1">// Enable attribute array at layout location 0</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="c1">// This maps the data we have set in the VBO to the "position" attribute.</span>
	<span class="c1">// 0 - offset - means the "position" data starts at the begin of the memory array</span>
	<span class="c1">// 3 - size of each vertex (=vec3) - means that each position-tuple has the size of 3 floats (those are the 3 coordinates,</span>
	<span class="c1">//     mind: this is the size of GL_FLOAT, not the size in bytes!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zunächst wir das Vertex-Array-Objekt erstellt und eingebunden. Danach werden alle folgenden Aufrufe von <code>enableAttributeArray()</code> und <code>setAttributeBuffer()</code> vermerkt.</p>
</div>
<div class="paragraph">
<p>Der Befehl <code>enableAttributeArray(0)</code> aktiviert ein Attribut (bzw. Variable) im Vertex-Puffer, welches im Shaderprogramm dann mit dem layout-Index 0 angesprochen werden kann. Im Vertex-Shader dieses Beispiels (siehe oben) ist das der <em>position</em> Vektor.</p>
</div>
<div class="paragraph">
<p>Mit <code>setAttributeBuffer()</code> wird nun definiert, wo im Vertex-Buffer die Daten zu finden sind, d.h. Datentyp, Anzahl (hier 3 floats entsprechend den 3 Koordinaten) und dem Startoffset (hier 0).</p>
</div>
<div class="paragraph">
<p>Diese beiden Aufrufe entsprechen den OpenGL-Aufrufen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Damit sind alle Daten initialisiert, und die Pufferobjekte können freigegeben werden:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="c1">// Release (unbind) all</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// not really necessary, but done for completeness</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dies entspricht den OpenGL-Aufrufen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Man sieht also, dass die Qt-Klassen letztlich die nativen OpenGL-Funktionsaufrufe (mitunter ziemlich direkt) kapseln.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Qt API fühlt sich hier nicht ganz glücklich gewählt an. Aufrufe wie <code>m_programm-&gt;enableAttributeArray(0)</code> sugggerieren, dass hier tatsächlich Objekteigenschaften geändert werden, dabei wird tatsächlich mit dem OpenGL-Zustandsautomaten gearbeitet. Entsprechend ist bei etlichen Befehlen die Reihenfolge der Aufrufe wichtig, obgleich es bei individuell setzbaren Attributen eines Objekts eigentlich egal sein sollte, welches Attribut man zuerst setzt. Daher habe ich oben im Tutorial auch noch einmal explizit die dahinterliegenden OpenGL-Befehle angegeben.</p>
</div>
<div class="paragraph">
<p>Es ist daher empfehlenswert, dass man die Qt API nochmal in eigene Klassen einpackt, und dann eine entsprechend schlange und fehlerunanfällige API entwirft.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_rendern">1.3.3. Rendern</h4>
<div class="paragraph">
<p>Das eigentliche Render erfolgt in der Funktion <code>render()</code>, die als rein virtuelle Funktion von der Basisklasse <code>OpenGLWindow</code> aufgerufen wird. Die Basisklasse prüft ja auch, ob Rendern überhaupt notwendig ist, und setzt den aktuellen OpenGL Context. Dadurch kann man in dieser Funktion direkt losrendern.</p>
</div>
<div class="paragraph">
<p>Die Implementierung ist (noch) recht selbsterklärend:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::render()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">TriangleWindow</span><span class="o">::</span><span class="n">render</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// this function is called for every frame to be rendered on screen</span>
	<span class="k">const</span> <span class="n">qreal</span> <span class="n">retinaScale</span> <span class="o">=</span> <span class="n">devicePixelRatio</span><span class="p">();</span> <span class="c1">// needed for Macs with retina display</span>
	<span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">()</span> <span class="o">*</span> <span class="n">retinaScale</span><span class="p">,</span> <span class="n">height</span><span class="p">()</span> <span class="o">*</span> <span class="n">retinaScale</span><span class="p">);</span>

	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

	<span class="c1">// use our shader program</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// bind the vertex array object, which in turn binds the vertex buffer object and</span>
	<span class="c1">// sets the attribute buffer in the OpenGL context</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// now draw the triangles:</span>
	<span class="c1">// - GL_TRIANGLES - draw individual triangles</span>
	<span class="c1">// - 0 index of first triangle to draw</span>
	<span class="c1">// - 3 number of vertices to process</span>
	<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="c1">// finally release VAO again (not really necessary, just for completeness)</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die ersten drei <code>glXXX</code> Befehle sind native OpenGL-Aufrufe, und sollten eigentlich in dieser Art mehr oder weniger immer auftauchen. Die Anpassung des ViewPort (<code>glViewport(...)</code>) ist für resize-Operationen notwendig, das Löschen des Color Buffers (<code>glClear(...)</code>) auch (später werden in diesem Aufruf noch andere Puffer gelöscht werden). Die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#devicePixelRatio">devicePixelRatio()</a> ist für Bildschirme mit angepasster Skalierung interessant (vornehmlich für Macs mit Retina-Display).</p>
</div>
<div class="paragraph">
<p>Solange sich die Hintergrundfarbe (clear-color) nicht ändert, könnte man diesen Aufruf auch in die Initialisierung verschieben.</p>
</div>
<div class="paragraph">
<p>Danach kommt der interessante Teil. Es wird das Shader-Programm gebunden (<code>m_programm-&gt;bind()</code>) und danach das Vertex Array Objekt (VAO) (<code>m_vao.bind()</code>). Letzteres sorgt dafür, dass im OpenGL-Kontext auch das Vertex-Buffer-Objekt und die Attributzuordnung gesetzt werden. Damit kann dann einfach gezeichnet werden, wofür mit <code>glDrawArrays(...)</code> wieder ein nativer OpenGL-Befehl zum Einsatz kommt.</p>
</div>
<div class="paragraph">
<p>Dieser Teil des Programms sähe in nativem OpenGL-Code so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ist also ziemlich ähnlich.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resourcenfreigabe">1.3.4. Resourcenfreigabe</h4>
<div class="paragraph">
<p>Bleibt noch das Aufräumen der reservierten Resourcen im Destructor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">TriangleWindow</span><span class="o">::~</span><span class="n">TriangleWindow</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// resource cleanup</span>

	<span class="c1">// since we release resources related to an OpenGL context,</span>
	<span class="c1">// we make this context current before cleaning up our resources</span>
	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

	<span class="n">m_vao</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">m_program</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Da einige Resourcen dem OpenGL-Kontext des aktuellen Fenster gehören, sollte man vorher den OpenGL-Kontext "aktuell" setzen (<code>m_context-&gt;makeCurrent(this);</code>), damit diese Resourcen sicher freigegeben werden können.</p>
</div>
<div class="paragraph">
<p>Damit wäre dann die Implementierung des <code>TriangleWindow</code> komplett.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_das_hauptprogramm">1.4. Das Hauptprogramm</h3>
<div class="paragraph">
<p>Das <code>TriangleWindow</code> kann jetzt eigentlich direkt als Top-Level-Fenster verwendet werden. Allerdings ist zu beachten, dass <em>vor</em> dem ersten Anzeigen (und damit vor der OpenGL-Initialisierung und Erstellung des OpenGL-Kontext) die Oberflächeneigenschaften (<code>QSurfaceFormat</code>) zu setzen sind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QGuiApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="c1">// Set OpenGL Version information</span>
	<span class="n">QSurfaceFormat</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setRenderableType</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">OpenGL</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setProfile</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">CoreProfile</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setVersion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

	<span class="n">TriangleWindow</span> <span class="n">window</span><span class="p">;</span>
	<span class="c1">// Note: The format must be set before show() is called.</span>
	<span class="n">window</span><span class="p">.</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das wäre dann erstmal eine Grundlage, auf der man aufbauen kann. Interessanterweise bietet Qt selbst eine Klasse an, die unserer OpenGLWindow-Klasse nicht unähnlich ist. Diese schauen wir uns in <em>Tutorial 02</em> an.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_02_alternative_die_klasse_qopenglwindow">2. Tutorial 02: Alternative: die Klasse QOpenGLWindow</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wer mit der Funktionalität des OpenGLWindows aus <em>Tutorial 01</em> zufrieden ist, kann gleich mit <em>Tutorial 03</em> weitermachen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In diesem Teil schauen wir uns die Klasse <a href="https://doc.qt.io/qt-5/qopenglwindow.html">QOpenGLWindow</a> an. Mit Hilfe dieser Klasse (die letztlich die Klasse <code>OpenGLWindow</code> aus dem <em>Tutorial 01</em> ersetzt) erstellen wir ein leicht modifiziertes Zeichenprogramm (2 Dreiecke, welche ein buntes Rechteck ergeben und via Element-Index-Puffer gezeichnet werden).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_02_linux.png" alt="Tutorial_02">
</div>
<div class="title">Figure 2. Ausgabe: Tutorial_02 (Linux/Ubuntu Screenshot)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_02">Tutorial_02</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Zuerst schauen wir an, was die Klasse <code>OpenGLWindow</code> unter der Haube macht.</p>
</div>
<div class="sect2">
<h3 id="_verwendung_der_klasse">2.1. Verwendung der Klasse</h3>
<div class="paragraph">
<p>Eine interessante Eigenschaft des <code>QOpenGLWindow</code> ist die Möglichkeit, nur einen Teil des Fensters neu zu zeichnen. Das wird über die <code>UpdateBehavior</code>-Eigenschaft gesteuert. Interessant ist das eigentlich nur, wenn man mittels rasterbasiertem QPainter Teile des Bildes aktualisieren möchte. Es gibt 3 Varianten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QOpenGLWindow::NoPartialUpdate</code> - das gesamte Bild wird jedes Mal neu gezeichnet (es wird kein zusätzlicher Framebuffer erzeugt und verwendet)</p>
</li>
<li>
<p><code>QOpenGLWindow::PartialUpdateBlit</code> - man zeichnet nur einen Teil des Bildes neu, und das in einem zusätzlichen, automatisch erstellten Framebuffer. Nach Ende des Zeichnens wird einfach der neu gezeichnete Teil in den eigentlichen Framebuffer kopiert.</p>
</li>
<li>
<p><code>QOpenGLWindow::PartialUpdateBlend</code> - im Prinzip wie die 2. Varianten, nur dass diesmal der Inhalt nicht kopiert, sondern überblendet wird.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ob man die 2. oder 3. Funktion braucht, hängt sicher von der Anwendung ab. Für viele OpenGL-Anwendungen wird das vielleicht nicht notwendig sein, daher schauen wir uns hier mal Variante mit <code>QOpenGLWindow::NoPartialUpdate</code> an.</p>
</div>
<div class="paragraph">
<p>Die Klasse <code>QOpenGLWindow</code> bietet 5 interessante virtuelle Funktionen an:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">initializeGL</span><span class="p">();</span>            <span class="c1">// initialization stuff</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">paintGL</span><span class="p">();</span>                 <span class="c1">// actual painting</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">paintOverGL</span><span class="p">();</span>             <span class="c1">// not needed for NoPartialUpdate</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">paintUnderGL</span><span class="p">();</span>            <span class="c1">// not needed for NoPartialUpdate</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">resizeGL</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">);</span>    <span class="c1">// to update anything related to view port</span>
                                        <span class="c1">// size (projection matrix etc.)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>initializeGL()</code> macht eigentlich das Gleiche, wie in Tutorial 01 die Funktion <code>initialize()</code>.</p>
</div>
<div class="paragraph">
<p>Die Funktion <code>paintGL()</code> macht das Gleiche, wie in Tutorial 01 die Funktion <code>render()</code>, d.h. hier wird das Bild mit OpenGL gezeichnet.</p>
</div>
<div class="paragraph">
<p>Die Funktionen <code>paintOverGL()</code> und <code>paintUnderGL()</code> werden im Modus <code>QOpenGLWindow::NoPartialUpdate</code> nicht benötigt.</p>
</div>
<div class="paragraph">
<p>Letztlich ist die Funktion <code>resizeGL(int w, int h)</code> nur eine Bequemlichkeitsfunktion, aufgerufen aus der <code>event()</code> Funktion für das <code>QEvent::ResizeEvent</code>. Hier kann man z.B. die Projektionsmatrix an den neuen Viewport anpassen oder sonstige Größenanpassungen vornehmen.</p>
</div>
</div>
<div class="sect2">
<h3 id="_die_implementierung_der_klasse_qopenglwindow">2.2. Die Implementierung der Klasse QOpenGLWindow</h3>
<div class="paragraph">
<p>Um die Gemeinsamkeiten und Unterschiede zur OpenGLWindow-Klasse aus Tutorial 01 zu verstehen, schauen wir uns mal die Klassenimplementierung an. Die Quelltextschnipsel stammen aus der Qt Version 5.14, sollten aber im Vergleich zu vorherigen Versionen nicht groß verändert sein.</p>
</div>
<div class="paragraph">
<p>Wichtigster Unterschied ist schon die Vererbungshierarchie. <code>QOpenGLWindow</code> leitet von <code>QOpenGLPaintDevice</code> ab, welches hardwarebeschleunigtes Zeichnen mit dem rasterbasierten <code>QPainter</code> erlaubt. Allerdings gibt es einen kleinen Haken. Zitat aus dem Handbuch:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Antialiasing in the OpenGL paint engine is done using multisampling. Most hardware require significantly more memory to do multisampling and the resulting quality is not on par with the quality of the software paint engine. The OpenGL paint engine&#8217;s strength lies in its performance, not its visual rendering quality.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Qt Documentation 5.9 zu QOpenGLPaintDevice
</div>
</div>
<div class="paragraph">
<p>Das hat insofern Auswirkung auf das Gesamterscheinungsbild der Anwendung, wenn im OpenGL Fenster verwaschene Widgets oder Kontrollen gezeichnet werden, daneben aber klassische Widgets mit scharfen Kanten.  Man kennt das Problem vielleicht von den verwaschenen Fenstern in Windows 10, wenn dort die Anwendungen letztlich in einen Pixelpuffer  zeichnen, welcher dann als Textur in einer 3D Oberfläche interpoliert gerendert wird. Sieht meiner Meinung nach doof aus :-)</p>
</div>
<div class="paragraph">
<p>Hilfreich kann das dennoch sein, wenn man existierende Zeichenfunktionalität (basierend auf QPainter) in einem OpenGL-Widget verwenden möchte. Falls man die Funktionalität nicht braucht, bringt das PaintDevice und die dafür benötigte Funktionalität <em>etwas unnützen Overhead</em> (vor allem Speicherverbrauch) mit sich.</p>
</div>
<div class="paragraph">
<p>Schauen wir uns nun die Gemeinsamkeiten an.</p>
</div>
<div class="sect3">
<h4 id="_constructor">2.2.1. Constructor</h4>
<div class="paragraph">
<p>Der Konstruktor sieht erstmal fast genauso aus, wie der unserer <code>OpenGLWindow</code>-Klasse. abgesehen davon, dass die Argumente in die private <a href="https://en.wikipedia.org/wiki/Opaque_pointer">Pimpl</a>-Klasse weitergeleitet werden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">QOpenGLWindow</span><span class="p">(</span><span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">UpdateBehavior</span> <span class="n">updateBehavior</span><span class="p">,</span> <span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">QPaintDeviceWindow</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="nf">QOpenGLWindowPrivate</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="n">updateBehavior</span><span class="p">)),</span> <span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setSurfaceType</span><span class="p">(</span><span class="n">QSurface</span><span class="o">::</span><span class="n">OpenGLSurface</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ereignisbehandlungsroutinen">2.2.2. Ereignisbehandlungsroutinen</h4>
<div class="paragraph">
<p>Interessanter sind schon die Ereignisbehandlungsroutinen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">paintEvent</span><span class="p">(</span><span class="n">QPaintEvent</span> <span class="o">*</span> <span class="cm">/*event*/</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">paintGL</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">resizeEvent</span><span class="p">(</span><span class="n">QResizeEvent</span> <span class="o">*</span> <span class="cm">/*event*/</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Q_D</span><span class="p">(</span><span class="n">QOpenGLWindow</span><span class="p">);</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">();</span>
    <span class="n">resizeGL</span><span class="p">(</span><span class="n">width</span><span class="p">(),</span> <span class="n">height</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das <code>paintEvent()</code> wird einfach an die vom Nutzer zu implementierende Funktion <code>paintGL()</code> weitergereicht. Insofern analog zu der Ereignisbehandlung im OpenGLWidget, welches auf <code>QEvent::UpdateRequest</code> wartet. Allerdings sind auf dem Weg bis zum Aufruf der <code>paintEvent()</code> Funktion etliche Zwischenschritte implementiert, bis zum Erzeugen des QPaintEvent-Objekts, welches gar nicht benötigt wird. Der Aufwand wird deutlich, wenn man sich die Aufrufkette anschaut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QPaintDeviceWindow</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>  <span class="c1">// waits for QEvent::UpdateRequest</span>
<span class="n">QPaintDeviceWindowPrivate</span><span class="o">::</span><span class="n">handleUpdateEvent</span><span class="p">()</span>
<span class="n">QPaintDeviceWindowPrivate</span><span class="o">::</span><span class="n">doFlush</span><span class="p">()</span>  <span class="c1">// calls QPaintDeviceWindowPrivate::paint()</span>

    <span class="kt">bool</span> <span class="nf">paint</span><span class="p">(</span><span class="k">const</span> <span class="n">QRegion</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Q_Q</span><span class="p">(</span><span class="n">QPaintDeviceWindow</span><span class="p">);</span>
        <span class="n">QRegion</span> <span class="n">toPaint</span> <span class="o">=</span> <span class="n">region</span> <span class="o">&amp;</span> <span class="n">dirtyRegion</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">toPaint</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// Clear the region now. The overridden functions may call update().</span>
        <span class="n">dirtyRegion</span> <span class="o">-=</span> <span class="n">toPaint</span><span class="p">;</span>

        <span class="n">beginPaint</span><span class="p">(</span><span class="n">toPaint</span><span class="p">);</span> <span class="c1">// here we call QOpenGLWindowPrivate::beginPaint()</span>

        <span class="n">QPaintEvent</span> <span class="n">paintEvent</span><span class="p">(</span><span class="n">toPaint</span><span class="p">);</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">paintEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paintEvent</span><span class="p">);</span> <span class="c1">// here we call QOpenGLWindowPrivate::paintEvent()</span>

        <span class="n">endPaint</span><span class="p">();</span> <span class="c1">// here we call QOpenGLWindowPrivate::endPaint()</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternativ wird <code>paintGL()</code> noch aus der Ereignisbehandlungsroutine <code>QPaintDeviceWindow::exposeEvent()</code> aufgerufen, wobei dort direkt <code>QPaintDeviceWindowPrivate::doFlush()</code> gerufen wird. Die Funktionen <code>beginPaint()</code> und  <code>endPaint()</code> kümmern sich um den temporären Framebuffer, in dem beim UpdateBehavior <code>QOpenGLWindow::PartialUpdateBlit</code> und <code>QOpenGLWindow::PartialUpdateBlend</code> gerendert wird. Ohne diese Modi passiert in der Funktion sehr wenig.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung">2.2.3. Initialisierung</h4>
<div class="paragraph">
<p>Interessant ist noch der Initialisierungsaufruf, der in der <code>resizeEvent()</code> Ereignisbehandlungsroutine steckt.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">QOpenGLWindowPrivate</span><span class="o">::</span><span class="n">initialize</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Q_Q</span><span class="p">(</span><span class="n">QOpenGLWindow</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">())</span>
        <span class="n">qWarning</span><span class="p">(</span><span class="s">"Attempted to initialize QOpenGLWindow without a platform window"</span><span class="p">);</span>

    <span class="n">context</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">QOpenGLContext</span><span class="p">);</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">setShareContext</span><span class="p">(</span><span class="n">shareContext</span><span class="p">);</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">requestedFormat</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">())</span>
        <span class="n">qWarning</span><span class="p">(</span><span class="s">"QOpenGLWindow::beginPaint: Failed to create context"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">qWarning</span><span class="p">(</span><span class="s">"QOpenGLWindow::beginPaint: Failed to make context current"</span><span class="p">);</span>

    <span class="n">paintDevice</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">QOpenGLWindowPaintDevice</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updateBehavior</span> <span class="o">==</span> <span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">PartialUpdateBlit</span><span class="p">)</span>
        <span class="n">hasFboBlit</span> <span class="o">=</span> <span class="n">QOpenGLFramebufferObject</span><span class="o">::</span><span class="n">hasOpenGLFramebufferBlit</span><span class="p">();</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">initializeGL</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Eigentlich sieht die Funktion fast genauso wie der Initialisierungsteil der Funktion <code>OpenGLWindow::renderNow()</code> aus <em>Tutorial 01</em> aus. Abgesehen natürlich davon, dass noch ein <code>QOpenGLWindowPaintDevice</code> erzeugt wird.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_zeichnen_mit_index_elementpuffern">2.3. Zeichnen mit Index-/Elementpuffern</h3>
<div class="paragraph">
<p>Als Erweiterung zum <em>Tutorial 01</em> soll im Anwendungsbeispiel für <code>QOpenGLWindow</code> ein Indexpuffer verwendet werden. Zwei Erweiterungen werden vorgestellt:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>interleaved Vertex-Puffer (d.h. Koordinaten und Farben zusammen in einem Puffer)</p>
</li>
<li>
<p>indexbasiertes Elementzeichnen (und den dafür benötigten Elementpuffer)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Implementierung des <code>RectangleWindow</code> ist zunächst mal fast identisch zum <code>TriangleWindow</code> aus <em>Tutorial 01</em>:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cm">/*	This is the window that shows the two triangles to form a rectangle.
	We derive from our QOpenGLWindow base class and implement the
	virtual initializeGL() and paintGL() functions.
*/</span>
<span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">RectangleWindow</span><span class="p">();</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">RectangleWindow</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

<span class="nl">private:</span>
	<span class="c1">// Wraps an OpenGL VertexArrayObject (VAO)</span>
	<span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="c1">// Vertex buffer (positions and colors, interleaved storage mode).</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vertexBufferObject</span><span class="p">;</span>
	<span class="c1">// Index buffer to draw two rectangles</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_indexBufferObject</span><span class="p">;</span>

	<span class="c1">// Holds the compiled shader programs.</span>
	<span class="n">QOpenGLShaderProgram</span>		<span class="o">*</span><span class="n">m_program</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die wesentlichsten Erweiterungen sind:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>die Klasse erbt von <code>QOpenGLWindow</code></p>
</li>
<li>
<p>die Initialisierung erfolgt in der Funktion <code>initializeGL()</code> (vormals <code>TriangleWindow::initialize()</code>)</p>
</li>
<li>
<p>das Rendern erfolgt in der Funktion <code>paintGL()</code> (vormals <code>TriangleWindow::render()</code>)</p>
</li>
<li>
<p>es gibt eine neue Variable vom Typ <code>QOpenGLBuffer</code>, welche wir für den Indexpuffer verwenden.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_shaderprogramm">2.3.1. Shaderprogramm</h4>
<div class="paragraph">
<p>Die Initialisierung beginnt wie in <em>Tutorial 01</em> unverändert mit dem Erstellen und Compilieren des Shaderprogramms. Da diesmal Farben verwendet werden, müssen beide Shaderprogramme angepasst werden:</p>
</div>
<div class="listingblock">
<div class="title">Vertexshader "shaders/pass_through.vert"</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// vertex shader</span>

<span class="c1">// input:  attribute named 'position' with 3 floats per vertex</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">color</span><span class="p">;</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt nun zwei Vertex-Attribute:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>layout location 0 = Position (als vec3 Koordinate)</p>
</li>
<li>
<p>layout location 1 = Farbe (auch als vec3, rgb Farbwerte je im Bereich 0..1)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Der Farbwert eines Vertex wird als Ausgabevariable <em>fragColor</em> einfach als vec4 weitergereicht und kommt dann, bereits fertig interpoliert, als <em>fragColor</em> im Fragmentshader an. Dort wird er unverändert ausgegeben.</p>
</div>
<div class="listingblock">
<div class="title">Fragmentshader "shaders/simple.frag"</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// fragment shader</span>

<span class="n">in</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>    <span class="c1">// input: interpolated color as rgba-value</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">finalColor</span><span class="p">;</span>  <span class="c1">// output: final color value as rgba-value</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">finalColor</span> <span class="o">=</span> <span class="n">fragColor</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Laden, Compilieren und Linken der Shader im Shaderprogramm wird genauso wie in <em>Tutorial 01</em> gemacht.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung_von_gemischten_vertex_puffern">2.3.2. Initialisierung von gemischten Vertex-Puffern</h4>
<div class="paragraph">
<p>Als nächstes der Vertex-Buffer erstellt. Diesmal werden nicht nur Koordinaten in den Buffer geschrieben, sondern auch Farben, und zwar abwechselnd (=<em>interleaved</em>) (siehe <a href="https://learnopengl.com/Getting-started/Hello-Triangle" class="bare">https://learnopengl.com/Getting-started/Hello-Triangle</a> für eine Erläuterung).</p>
</div>
<div class="paragraph">
<p>Es wird ein Rechteck gezeichnet, und zwar durch zwei Dreiecke. Dafür brauchen wir 4 Punkte. Der Vertexpuffer-Speicherblock soll am Ende so aussehen: <code>p0c0|p1c1|p2c2|p3c3</code>, wobei p für eine Position (vec3) und c für eine Farbe (vec3) steht. Die Daten werden zunächst in statischen Arrays separat definiert.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// set up vertex data (and buffer(s)) and configure vertex attributes</span>
<span class="c1">// ------------------------------------------------------------------</span>

<span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	 <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// top right</span>
	 <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom right</span>
	<span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom left</span>
	<span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>   <span class="c1">// top left</span>
<span class="p">};</span>

<span class="n">QColor</span> <span class="n">vertexColors</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#f6a509"</span><span class="p">),</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#cb2dde"</span><span class="p">),</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#0eeed1"</span><span class="p">),</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#068918"</span><span class="p">),</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die noch getrennten Daten werden jetzt in einen gemeinsamen Speicherbereich kopiert.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// create buffer for 2 interleaved attributes: position and color, 4 vertices, 3 floats each</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">vertexBufferData</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// create new data buffer - the following memory copy stuff should</span>
<span class="c1">// be placed in some convenience class in later tutorials</span>
<span class="c1">// copy data in interleaved mode with pattern p0c0|p1c1|p2c2|p3c3</span>
<span class="kt">float</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// coordinates</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
	<span class="c1">// colors</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">redF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">greenF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">blueF</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt sicher viele andere Varianten, die Daten in der gewünschten Reihenfolge in den Speicherblock zu kopieren.</p>
</div>
<div class="paragraph">
<p>Es fällt vielleicht auf, dass der gemeinsame Pufferspeicher in einem lokal erstellen <code>std::vector</code> liegt. Das wirft die Frage nach der (benötigten) Lebensdauer für diese Pufferspeicher auf.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// create a new buffer for the vertices and colors, interleaved storage</span>
<span class="n">m_vertexBufferObject</span> <span class="o">=</span> <span class="n">QOpenGLBuffer</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">VertexBuffer</span><span class="p">);</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>

<span class="c1">// now copy buffer data over: first argument pointer to data, second argument: size in bytes</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im letzten Aufruf wird der Pufferspeicher tatsächlich <em>kopiert</em>. Der Aufruf zu <code>allocate()</code> ist sowohl Speicherreservierung im OpenGL-Puffer, als auch Kopieren der Daten (wie mit <code>memcpy</code>).</p>
</div>
<div class="paragraph">
<p>Danach wird der Vector <code>vertexBufferData</code> nicht mehr benötigt, oder könnte sogar für weitere Puffer verwendet und verändert werden.</p>
</div>
</div>
<div class="sect3">
<h4 id="_element_indexpuffer">2.3.3. Element-/Indexpuffer</h4>
<div class="paragraph">
<p>In ähnlicher Weise wird nun der Elementpuffer erstellt, allerdings gibt es eine OpenGL-Besonderheit zu beachten:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das <em>Vertex Array Object</em> verwaltet nicht nur die Attribute, sondern auch gebundene Puffer. Daher muss das VAO <em>vor</em> dem Elementpuffer gebunden werden, um dann den Zustand korrekt zu speichern.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Deshalb wird nun zuerst das VAO erstellt und gebunden (kann man auch ganz am Anfang machen)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// create and bind Vertex Array Object - must be bound *before* the element buffer is bound,</span>
<span class="c1">// because the VAO remembers and manages element buffers as well</span>
<span class="n">m_vao</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>und dann erst der Elementpuffer erzeugt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// note that we start from 0!</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>   <span class="c1">// first triangle</span>
	<span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>    <span class="c1">// second triangle</span>
<span class="p">};</span>

<span class="c1">// create a new buffer for the indexes</span>
<span class="n">m_indexBufferObject</span> <span class="o">=</span> <span class="n">QOpenGLBuffer</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">IndexBuffer</span><span class="p">);</span> <span class="c1">// Mind: use 'IndexBuffer' here</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Qt (und auch OpenGL) unterscheidet nicht zwischen Pufferobjekten für verschiedene Aufgaben. Erst beim Binden des Puffers an den OpenGL Kontext (beispielsweise durch den Aufruf <code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO)</code>) wird die Verwendung des Puffers festgelegt.</p>
</div>
<div class="paragraph">
<p>In Qt muss man die Art des Puffers als Construktor-Argument übergeben, wobei <code>QOpenGLBuffer::VertexBuffer</code> der Standard ist. Für den Index-/Elementpuffer muss man <code>QOpenGLBuffer::IndexBuffer</code> übergeben. Der eigentliche Pufferinhalt wird wieder beim Aufruf von <code>allocate()</code> kopiert.</p>
</div>
</div>
<div class="sect3">
<h4 id="_attribute_im_gemischten_vertexarray">2.3.4. Attribute im gemischten Vertexarray</h4>
<div class="paragraph">
<p>Bei der Verwendung gemischter Vertexarrays (mehrer Attribute je Vertex) muss man dem Shaderprogramm die Speicherstruktur und die Abbildung der Attribute angeben (zur Erläuterung siehe wiederum <a href="https://learnopengl.com/Getting-started/Hello-Triangle">Hello-Triangle Tutorial</a>).</p>
</div>
<div class="paragraph">
<p>Die Syntax von <code>QOpenGLShaderProgram::setAttributeBuffer</code> entspricht im wesentlichen dem nativen OpenGL-Aufruf <code>glVertexAttribPointer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// stride = number of bytes for one vertex (with all its attributes) = 3+3 floats = 6*4 = 24 Bytes</span>
<span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">6</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>

<span class="c1">// layout location 0 - vec3 with coordinates</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>

<span class="c1">// layout location 1 - vec3 with colors</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">colorOffset</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">colorOffset</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wie gesagt, für die korrekte Komposition des VAO es ist lediglich die Reihenfolge des Bindens und der <code>setAttributeBuffer()</code>-Aufrufe wichtig. Man könnte also auch die Puffer erst erstellen und befüllen und zum Schluss die folgenden Aufrufe in der geforderten Reihenfolge schreiben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span> <span class="c1">// VAO binden</span>
<span class="c1">// Puffer binden und Daten kopieren</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">);</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="p">);</span>
<span class="c1">// Attribute setzen</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(...)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In ähnlicher Art und Weise werden Bufferdaten auch aktualisiert (wird noch in einem späteren Tutorial besprochen).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_freigabe_der_puffer">2.3.5. Freigabe der Puffer</h4>
<div class="paragraph">
<p>Bei der Freigabe der Puffer ist die Reihenfolge wichtig. Damit sich das VAO den Zustand des eingebundenden Elementpuffers merkt, darf man diesen <em>nicht vor</em> Freigabe des VAO freigeben. Am Besten man gibt nur Vertexbuffer und VAO frei, und auch das nur, wenn es notwendig ist. Es wird im Beispiel auch nur der Vollständigkeithalber gemacht.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Release (unbind) all</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Explizites Freigeben von VBO oder VAO ist eigentlich nur notwendig, wenn man mit verschiedenen VAOs arbeitet und/oder verschiedenen Shadern. Dann sollte man auf Zustand im aktuellen OpenGL-Kontext achten und bewusst OpenGL-Objekte einbinden und freigeben.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_rendern_2">2.3.6. Rendern</h4>
<div class="paragraph">
<p>Das eigentliche Zeichnen erfolgt in der <code>paintGL()</code> Funktion, welche fast genauso aussieht wie die <code>TriangleWindow::render()</code> Funktion aus <em>Tutorial 01</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

	<span class="c1">// use our shader program</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// bind the vertex array object, which in turn binds the vertex buffer object and</span>
	<span class="c1">// sets the attribute buffer in the OpenGL context</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// For old Intel drivers you may need to explicitely re-bind the index buffer, because</span>
	<span class="c1">// these drivers do not remember the binding-state of the index/element-buffer in the VAO</span>
	<span class="c1">//	m_indexBufferObject.bind();</span>

	<span class="c1">// now draw the two triangles via index drawing</span>
	<span class="c1">// - GL_TRIANGLES - draw individual triangles via elements</span>
	<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
	<span class="c1">// finally release VAO again (not really necessary, just for completeness)</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Anpassen des Viewports (OpenGL-Aufruf <code>glViewport()</code>) kann entfallen, da das bereits in der Basisklasse gemacht wurde.</p>
</div>
<div class="paragraph">
<p>Dann folgen eigentlich die üblichen 4 Schritte:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Shaderprogramm binden</p>
</li>
<li>
<p>Vertex Array Objekt binden (und damit Binden des Vertex- und Elementpuffers, und setzen der Attribut-Zeiger)</p>
</li>
<li>
<p>Rendern, diesmal mit <code>glDrawElements</code> statt <code>glDrawArrays</code>, und</p>
</li>
<li>
<p>freigeben des VAO (damit danach weitere Objekte gezeichnet werden können).</p>
</li>
</ol>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bei einigen älteren Intel-Treibern wurde der Zustand des eingebundenen Elementpuffers noch nicht korrekt im VAO gespeichert und wiederhergestellt. Daher musste man den Index-/Elementpuffer vor dem Zeichnen immer nochmal explizit einbinden (siehe auskommentierter Quelltext).</p>
</div>
<div class="paragraph">
<p>Bei aktuellen Treibern scheint das aber kein Problem mehr zu sein (zumindest nicht unter Ubuntu).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_zusammenfassung">2.4. Zusammenfassung</h3>
<div class="paragraph">
<p>Das <code>QOpenGLWindow</code> ist im Modus <code>QOpenGLWindow::NoPartialUpdate</code> eigentlich vergleichbar mit unserem minimalistischen <code>OpenGLWindow</code> aus <em>Tutorial 01</em>. Etwas Overhead ist vorhanden, allerdings sollte der in realen Anwendungen keine Rolle spielen. Es spricht also eigentlich nichts dagegen, direkt mit dem <code>QOpenGLWindow</code> anzufangen.</p>
</div>
<div class="paragraph">
<p>Für spätere Erweiterungen (Maus- und Tastatureingabebehandlung) ist dennoch eine von <code>QOpenGLWindow</code> abgeleitete Klasse nötig. Wenn man also die zusätzlichen Funktionen (QPainter-Zeichnen, Buffer-Blenden etc.) von <code>QOpenGLWindow</code> nicht braucht, kann man auch mit dem schlanken <code>OpenGLWindow</code> aus <em>Tutorial 01</em> weitermachen.</p>
</div>
<div class="paragraph">
<p>Wie man nun ein solches QWindow-basiertes (natives) OpenGL-Fenster in eine Widgets-Anwendung integriert bekommt, beschreibt <em>Tutorial 03</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_03_renderfenster_in_einem_qdialog_eingebettet">3. Tutorial 03: Renderfenster in einem QDialog eingebettet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In diesem Teil des Tutorials geht es darum, ein QWindow-basiertes OpenGL-Renderfenster (siehe <em>Tutorial 01</em> und <em>02</em>), in eine QWidgets-Anwendung einzubetten.</p>
</div>
<div class="paragraph">
<p>Der erste Teil des Tutorials beschäftigt sich allein mit der Einbettung (und ist recht kurz). Damit das Tutorial aber noch etwas interessanter wird, gibt es im 2. Abschnitt noch zwei Interaktionsvarianten mit und ohne Animation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man könnte auch die Bequemlichkeitsklasse <code>QOpenGLWidget</code> verwenden. In <em>Tutorial 04</em> schauen wir uns an, wie diese Klasse intern funktioniert und ob es ggfs. Performancenachteile geben könnte, wenn man diese Klasse verwendet.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_03_win10.png" alt="Tutorial_03">
</div>
<div class="title">Figure 3. Tutorial_03 (Windows 10 Screenshot)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_03">Tutorial_03</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_window_container_widgets">3.1. Window Container Widgets</h3>
<div class="paragraph">
<p>Die Funktion <code>QWidget::createWindowContainer</code> erstellt ein <code>QWidget</code>, welches das als Argument übergebene <code>QWindow</code> einbettet. So einfach kann&#8217;s sein:</p>
</div>
<div class="listingblock">
<div class="title">TestDialog.cpp:Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// *** create OpenGL window</span>

<span class="n">QSurfaceFormat</span> <span class="n">format</span><span class="p">;</span>
<span class="n">format</span><span class="p">.</span><span class="n">setRenderableType</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">OpenGL</span><span class="p">);</span>
<span class="n">format</span><span class="p">.</span><span class="n">setProfile</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">CoreProfile</span><span class="p">);</span>
<span class="n">format</span><span class="p">.</span><span class="n">setVersion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

<span class="n">m_rectangleWindow</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RectangleWindow</span><span class="p">;</span>
<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>

<span class="c1">// *** create window container widget</span>

<span class="n">QWidget</span> <span class="o">*</span><span class="n">container</span> <span class="o">=</span> <span class="n">QWidget</span><span class="o">::</span><span class="n">createWindowContainer</span><span class="p">(</span><span class="n">m_rectangleWindow</span><span class="p">);</span>
<span class="n">container</span><span class="o">-&gt;</span><span class="n">setMinimumSize</span><span class="p">(</span><span class="n">QSize</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">400</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>m_rectangleWindow</code> ist ein Zeiger auf die aus Tutorial 02 bekannte <code>RectangleWindow</code> Klasse. Das so erstellte Container-Widget muss natürlich noch in ein Layout gesteckt werden. Aber mehr ist eigentlich nicht zu tun.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interaktion_und_synchronisation_mit_dem_zeichnen">3.2. Interaktion und Synchronisation mit dem Zeichnen</h3>
<div class="paragraph">
<p>Grundsätzlich ist folgende Aktualisierungslogik anzustreben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>OpenGL zeichnet Bild

&lt;Anwendung wartet in Ereignis-Schleife&gt;

Ein Event wird abgearbeitet, ändert für die Darstellung relevante Daten. Registriert ein "UpdateRequest" in der Ereignisschleife.

&lt;Anwendung wartet in Ereignis-Schleife&gt;

Ein Event wird abgearbeitet, ändert für die Darstellung relevante Daten. Registriert ein "UpdateRequest" in der Ereignisschleife. Dieses wird mit dem bereits existierenden "UpdateRequest" verschmolzen.

Passend zum VSync wird das UpdateRequest-Event verschickt, was zum OpenGL Rendern führt. Und wieder von vorne...</code></pre>
</div>
</div>
<div class="paragraph">
<p>D.h., das potenziell zeitaufwändige Aktualisieren der Puffer und Zeichendaten erfolgt stets dann, wenn noch auf den nächsten VSync gewartet wird. So hat man ca. 16 ms Zeit (by üblichen 60 FPS), alles Notwendige zu erledigen.</p>
</div>
<div class="sect3">
<h4 id="_einmalige_änderungen_farbwechsel_auf_knopfdruck">3.2.1. Einmalige Änderungen: Farbwechsel auf Knopfdruck</h4>
<div class="paragraph">
<p>Eine typische Anwendung, vor allem in technischen Anwendungen (d.h. nicht in Spielen), ist die diskrete Änderung der 3D Szene, sei es durch eine Kamerabewegung, Auswahl und Hervorhebung einzelner Elemente, oder Transformation der dargestellten Geometrie. Innerhalb des Qt Frameworks wird also zunächst ein Ereignis (OnClick, Maus- oder Tastatureingabe, &#8230;&#8203;) in die Ereignisschleife gelangen und dort abgearbeitet werden.</p>
</div>
<div class="paragraph">
<p>Ein Beispiel ist der "Change Color" Button im Dialog im Tutorial 03. Es gibt eine OnClick-Ereignisbehandlungsroutine:</p>
</div>
<div class="listingblock">
<div class="title">TestDialog.cpp:TestDialog::onChangeColors()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// randomize the colors and change them in the OpenGL window</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">m_vertexColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setRgbF</span><span class="p">(</span>
	        <span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">RAND_MAX</span> <span class="p">);</span>

<span class="c1">// now update the scene -&gt; this will also request an update</span>
<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">updateScene</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Membervariable <code>m_vertexColors</code> wird mit zufälligen Farbwerten befüllt. Dann wird die Funktion <code>updateScene()</code> aufgerufen.</p>
</div>
<div class="paragraph">
<p>Zum Verständnis kann man noch einmal die geänderte Klassendeklaration von <code>RectangleWindow</code> anschauen:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">....</span>

	<span class="c1">// updates the scene and requests a paint update</span>
	<span class="kt">void</span> <span class="n">updateScene</span><span class="p">();</span>

	<span class="c1">// holds the vertex colors set on next call to updateScene()</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span>			<span class="n">m_vertexColors</span><span class="p">;</span>

<span class="nl">private:</span>

    <span class="c1">// ....</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span>			<span class="n">m_vertexBufferData</span><span class="p">;</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der im <em>Tutorial 02</em> noch als temporärer lokaler Speicherbereich verwendete Vector <code>m_vertexBufferData</code> ist jetzt eine Membervariable. Die zu verwendenden Farben sind in dem öffentlichen Vector <code>m_vertexColors</code> abgelegt.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Der Quelltext in diesem Tutorial-Beispiel ist natürlich sehr fehleranfällig und unsicher. Darauf kommt es aber nicht an und die notwendigen Fehlerprüfungen wurden der Übersichtlichkeit wegen weggelassen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Vertexfarben werden im Konstruktor mittels C++11 Initialisierungsliste initialisiert:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp: Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">RectangleWindow</span><span class="o">::</span><span class="n">RectangleWindow</span><span class="p">()</span> <span class="o">:</span>
	<span class="n">m_vertexColors</span><span class="p">{</span> 		<span class="n">QColor</span><span class="p">(</span><span class="s">"#f6a509"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#cb2dde"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#0eeed1"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#068918"</span><span class="p">)</span> <span class="p">},</span>
	<span class="n">m_program</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span>
	<span class="n">m_frameCount</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die OpenGL-Initialisierung ist minimal verändert:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:initializeGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">....</span>

<span class="c1">// resize buffer for 2 interleaved attributes: position and color, 4 vertices, 3 floats each</span>
<span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// create new data buffer - the following memory copy stuff should</span>
<span class="c1">// be placed in some convenience class in later tutorials</span>
<span class="c1">// copy data in interleaved mode with pattern p0c0|p1c1|p2c2|p3c3</span>
<span class="kt">float</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// coordinates</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
	<span class="c1">// colors</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">redF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">greenF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">blueF</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">....</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Vertex-Puffer wird auf die richtige Größe gebracht (und bleibt so), und wird dann wie bisher belegt, wobei diesmal die Farben aus der Membervariable <code>m_vertexColors</code> kommen. Sonst ändert sich nichts.</p>
</div>
<div class="paragraph">
<p>Wenn jetzt in der Ereignisbehandlungsroutine der "Change Color" Schaltfläche die Farben in <code>m_vertexColors</code> geändert werden, hat das keinerlei Einfluss auf das OpenGL-Zeichnen. Die neuen Werte müssen erst in den OpenGL-Vertexpuffer kopiert werden.</p>
</div>
<div class="paragraph">
<p>Das passiert in der Funktion <code>updateScene()</code> (hätte auch <code>updateColors()</code> heißen können):</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:updateScene()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">updateScene</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// for now we only update colors</span>

	<span class="c1">// first update our vertex buffer memory, but only those locations that are actually changed</span>
	<span class="kt">float</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// colors</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">redF</span><span class="p">();</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">greenF</span><span class="p">();</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">blueF</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// make this OpenGL context current</span>
	<span class="n">makeCurrent</span><span class="p">();</span>

	<span class="c1">// bind the vertex buffer</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// now copy buffer data over: first argument pointer to data, second argument: size in bytes</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">);</span>

	<span class="c1">// and request an update</span>
	<span class="n">update</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erst wird der Puffer aktualisiert. Aber anstelle diesen komplett neu aufzubauen (und eventuell noch Speicherbereiche neu zu reservieren), verändern wir einfach nur die Farbwerte.</p>
</div>
<div class="paragraph">
<p>Danach muss der OpenGL-Vertexpuffer die Daten bekommen. Damit der OpenGL-Context stimmt, wird <code>QOpenGLWindow::makeCurrent()</code> aufgerufen. Dann wird der Vertexpuffer eingebunden und schließlich die Daten kopiert.</p>
</div>
<div class="paragraph">
<p>Ganz zuletzt wird <code>QPaintDeviceWindow::update()</code> aufgerufen (<code>QOpenGLWindow</code> ist durch Vererbung auch ein <code>QPaintDeviceWindow</code>). Dies hängt letztlich ein <code>QEvent::UpdateRequest</code> an die Ereignisliste an, wodurch beim nächsten VSync neu gezeichnet wird.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man kann mal eine Test-Debug-Ausgabe in die Zeichenroutine einfügen. Wenn man nun in der OnClick-Ereignisbehandlungsroutine die Funktion <code>updateScene()</code> mehrfach aufruft, wird dennoch stets nur einmal je VSync gezeichnet.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_animierte_farbänderung">3.2.2. Animierte Farbänderung</h4>
<div class="paragraph">
<p>Anstelle neue Farben sofort zu setzen, kann man diese auch animiert verändern, d.h. in jedem Frame nur ein Stück von der Ursprungsfarbe zur Zielfarbe gehen.</p>
</div>
<div class="paragraph">
<p>Man benötigt zusätzliche Membervariablen und zwei neue Funktionen:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="p">....</span>

	<span class="kt">void</span> <span class="n">animateColorsTo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">toColors</span><span class="p">);</span>

<span class="nl">private:</span>
	<span class="c1">// modifies the scene a bit and call updateScene() afterwards</span>
	<span class="c1">// when already in the final state, doesn't do anything</span>
	<span class="kt">void</span> <span class="n">animate</span><span class="p">();</span>

    <span class="p">....</span>

    <span class="c1">// Stores the target colors that we animate towards</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span>			<span class="n">m_toColors</span><span class="p">;</span>
    <span class="c1">// Stores the target colors that we animate from</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span>			<span class="n">m_fromColors</span><span class="p">;</span>
    <span class="c1">// number of frames used for the animation</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>				<span class="n">m_frameCount</span><span class="p">;</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>animateColorsTo()</code> wird wieder durch eine Schaltfläche angestoßen. Die Implementierung überträgt nur die Daten in die Membervariablen und ruft <code>animate()</code> auf:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:animateColorsTo()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">animateColorsTo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">toColors</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// current colors are set to "fromColors", toColors are store in m_toColors and</span>
	<span class="c1">// animation counter is reset</span>

	<span class="n">m_fromColors</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">;</span>
	<span class="n">m_toColors</span> <span class="o">=</span> <span class="n">toColors</span><span class="p">;</span>
	<span class="n">m_frameCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">animate</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Variable <code>m_frameCount</code> zählt die animierten Frames seit Beginn der Animation. In der Funktion <code>animate()</code> wird dann zwischen den Anfangsfarbwerten <code>m_fromColors</code> und Zielfarbwerten <code>m_toColors</code> linear (im HSV Farbraum) interpoliert:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:animate()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">animate</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">FRAMECOUNT</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>
	<span class="c1">// if already at framecount end, stop</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">m_frameCount</span> <span class="o">&gt;</span> <span class="n">FRAMECOUNT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="c1">// this will also stop the frame rendering</span>

	<span class="c1">// update the colors</span>
	<span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">m_frameCount</span><span class="p">)</span><span class="o">/</span><span class="n">FRAMECOUNT</span><span class="p">;</span>

	<span class="c1">// linear blending in HSV space will probably look "interesting", but it's simple</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m_vertexColors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">double</span> <span class="n">fromH</span><span class="p">,</span> <span class="n">fromS</span><span class="p">,</span> <span class="n">fromV</span><span class="p">;</span>
		<span class="n">m_fromColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getHsvF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fromH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromV</span><span class="p">);</span>
		<span class="kt">double</span> <span class="n">toH</span><span class="p">,</span> <span class="n">toS</span><span class="p">,</span> <span class="n">toV</span><span class="p">;</span>
		<span class="n">m_toColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getHsvF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">toH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">toS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">toV</span><span class="p">);</span>

		<span class="n">m_vertexColors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">QColor</span><span class="o">::</span><span class="n">fromHsvF</span><span class="p">(</span> <span class="n">toH</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">fromH</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">),</span>
											  <span class="n">toS</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">fromS</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">),</span>
											  <span class="n">toV</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">fromV</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">updateScene</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist die Abfrage nach dem Überschreiten der Animationslänge (Anzahl von Frames). Sobald das Animationsende erreicht ist, wird die Funktion sofort verlassen und es finden keine weiteren Farbanpassungen und, was vielleicht wichtiger ist, keine weiteren UpdateRequest-Events statt. Dann wartet die Anwendung wieder einfach auf Nutzerinteraktion und verbraucht keine Resourcen.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Diese Art der Animation ist gekoppelt an <em>tatsächlich gezeichnete Frames</em>. Wenn das Fenster im Hintergrund ist (d.h. nicht <em>exposed</em>) wird die Ausführung des UpdateRequest-Events ausgesetzt, bis das Fenster wieder sichtbar ist. Damit wartet auch die Animation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_zusammenfassung_2">3.2.3. Zusammenfassung</h4>
<div class="paragraph">
<p>Die Einbettung eines <code>QWindow</code> in eine Widgets-Anwendung ist dank Widget-Container denkbar einfach. Und was das Zusammenspiel zwischen normalen <code>QWidget</code>-basierten Eingabeereignissen und der Aktualisierung der OpenGL-Ausgabe (synchron zur Bildwiederholfrequenz) betrifft, so sind die beiden Farbanpassungsvarianten in diesem Tutorial Beispiele, wie man das machen kann.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_04_verwendung_des_qopenglwidget">4. Tutorial 04: Verwendung des QOpenGLWidget</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Tutorialteil wird das <a href="https://doc.qt.io/qt-5/qopenglwidget.html">QOpenGLWidget</a> anstelle des <code>QOpenGLWindow</code> verwendet. Das Programm macht das Gleiche wie in <em>Tutorial 03</em> (nur etwas langsamer :-), aber dazu kommen wir gleich).</p>
</div>
<div class="paragraph">
<p>Damit der Screenshot nicht ganz genauso wie im letzten Tutorial aussieht, habe ich mal einen halbdurchsichtigen Hintergrund eingeschaltet - das geht aber mit dem bisherigen Implementierungsvarianten auch (siehe letzter Teil des Tutorials).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_04_linux.png" alt="Tutorial_04">
</div>
<div class="title">Figure 4. Tutorial_04 (Linux Screenshot, mit Transparenz)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_04">Tutorial_04</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_was_bietet_das_qopenglwidget">4.1. Was bietet das QOpenGLWidget</h3>
<div class="paragraph">
<p>Von den ganzen Qt OpenGL-Klassen ist das <code>QOpenGLWidget</code> die mit Abstand am besten dokumentierte Klasse. Es gibt ein paar interessante Details in der Dokumentation, hier ein paar Zitate:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>All rendering happens into an OpenGL framebuffer object.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Due to being backed by a framebuffer object, the behavior of QOpenGLWidget is very similar to QOpenGLWindow with the update behavior set to PartialUpdateBlit or PartialUpdateBlend. This means that the contents are preserved between paintGL() calls so that incremental rendering is possible.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Note:</strong> Most applications do not need incremental rendering because they will render everything in the view on every paint call.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Und vielleicht am Interessantesten:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Adding a QOpenGLWidget into a window turns on OpenGL-based compositing for the entire window. In some special cases this may not be ideal, and the old QGLWidget-style behavior with a separate, native child window is desired. Desktop applications that understand the limitations of this approach (for example when it comes to overlaps, transparency, scroll views and MDI areas), can use QOpenGLWindow with QWidget::createWindowContainer(). This is a modern alternative to QGLWidget and is faster than QOpenGLWidget due to the lack of the additional composition step. It is strongly recommended to limit the usage of this approach to cases where there is no other choice. Note that this option is not suitable for most embedded and mobile platforms, and it is known to have issues on certain desktop platforms (e.g. macOS) too. The stable, cross-platform solution is always QOpenGLWidget.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Qt Documentation (5.9)
</div>
</div>
<div class="paragraph">
<p>Grundlegend: Ein OpenGL bild wird beim <code>QOpenGLWidget</code> <em>immer</em> erst in einen Buffer gerendert, und dann entsprechend der Zusammensetzungsregeln (Compositing) auf den Bildschirm gezeichnet. Das dauert natürlich entsprechend länger als direktes Zeichnen (siehe Performance-Test unten).</p>
</div>
<div class="paragraph">
<p>Der wesentliche Vorteil des gepufferten Zeichnens ist die Möglichkeit des inkrementellen Renderns. Ob man das braucht, hängt wesentlich von der eigentlichen Anwendung ab. Eigentlich ist dies nur von Belang, wenn das zu rendernde Fenster aus mehreren individuellen Teilbereichen besteht. In diesem Fall könnte man aber auch die Anwendung aus mehreren OpenGL-Fenstern zusammensetzen, in in jedem Fenster individuell zeichnen.</p>
</div>
<div class="paragraph">
<p>Die letzte Anmerkung über die Portabilität und Stabilität ist vielleicht nicht ganz unwichtig. Man kann das Ganze also von 2 Seiten betrachten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mit <code>QOpenGLWidget</code> beginnen, und beim Auftreten von Performanceproblemen wechseln,</p>
</li>
<li>
<p>mit <code>QOpenGLWindow</code> oder einer selbstgeschriebenen leichtgewichtigen Klasse wie in <em>Tutorial 01</em>, beginnen, und im Falle von Kompatibilitätsproblemen auf <code>QOpenGLWidget</code> wechseln</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hinsichtlich der Programmierschnittstelle sind die verschiedenen Klassen sich sehr ähnlich. Nachfolgend sind die einzelnen Anpassungen von <em>Tutorial 03</em> zur Verwendung von <code>QOpenGLWidget</code> aufgeführt.</p>
</div>
<div class="sect3">
<h4 id="_anpassung_der_vererbungshierarchie">4.1.1. Anpassung der Vererbungshierarchie</h4>
<div class="paragraph">
<p>Der erste Schritt ist das Austauschen der Basisklasse.</p>
</div>
<div class="listingblock">
<div class="title">RectangleWidget.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWidget</span><span class="p">,</span> <span class="k">protected</span> <span class="n">QOpenGLFunctions</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">RectangleWindow</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">);</span>

    <span class="p">....</span>

<span class="nl">protected:</span>
	<span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

    <span class="p">....</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Klasse <code>QOpenGLWidget</code> erbt selbst nicht von <code>QOpenGLFunctions</code>, weswegen man diese Klasse als weitere Basisklasse angeben muss (geht auch noch anders, aber so muss im Quelltext sonst nicht viel angepasst werden). Der Konstruktor nimmt, wie andere Widgets auch, ein parent-Zeiger als Argument.</p>
</div>
<div class="paragraph">
<p>Die Funktionen <code>initializeGL()</code> und  <code>paintGL()</code> sind bei <code>QOpenGLWidget</code> protected. Das war&#8217;s auch schon.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung_2">4.1.2. Initialisierung</h4>
<div class="paragraph">
<p>Der Konstruktor ist entsprechend zu erweitern, sodass der <code>parent</code> Zeiger an die Basisklasse weitergereicht wird:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWidget.cpp:Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">RectangleWindow</span><span class="o">::</span><span class="n">RectangleWindow</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">QOpenGLWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
	<span class="n">m_vertexColors</span><span class="p">{</span> 		<span class="n">QColor</span><span class="p">(</span><span class="s">"#f6a509"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#cb2dde"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#0eeed1"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#068918"</span><span class="p">)</span> <span class="p">},</span>
	<span class="n">m_program</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span>
	<span class="n">m_frameCount</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setMinimumSize</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">400</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Da die Klasse nun ein Widget ist, kann man die minimale Größe auch gleich hier setzen.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das Setzen der Größe muss vor dem ersten Anzeigen gemacht werden, da sonst das Widget nicht sichtbar ist (und auch nicht vergrößert werden kann).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Verwendung der vererbten <code>QOpenGLFunctions</code> Funktionen verlangt auch eine Initialisierung, die muss aber durch Aufruf der Funktion in <code>initializeOpenGLFunctions()</code> in <code>initializeGL()</code> erfolgen.</p>
</div>
<div class="listingblock">
<div class="title">RectangleWidget.cpp:initializeGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">initializeGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">initializeOpenGLFunctions</span><span class="p">();</span>

    <span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Mehr ist nicht zu machen, und schon ist das <code>RectangleWindow</code> ein vollständiges Widget.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das <code>UpdateBehavior</code> ist beim <code>QOpenGLWidget</code> standardmäßig auf <code>QOpenGLWidget::NoPartialUpdate</code> gesetzt, muss also nicht extra angepasst werden.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_einbettung_in_ein_anderes_qwidget">4.1.3. Einbettung in ein anderes QWidget</h4>
<div class="paragraph">
<p>Der Widget-Container (siehe <em>Tutorial 03</em>) kann entfallen, und die Einbettung des Widgets wird wie mit jedem anderen Widget gemacht.</p>
</div>
<div class="listingblock">
<div class="title">TestDialog.cpp:Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">....</span>

<span class="n">m_rectangleWindow</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RectangleWindow</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>

<span class="c1">// *** create the layout and insert widget container</span>

<span class="n">QVBoxLayout</span> <span class="o">*</span> <span class="n">vlay</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
<span class="n">vlay</span><span class="o">-&gt;</span><span class="n">setMargin</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">vlay</span><span class="o">-&gt;</span><span class="n">setSpacing</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">vlay</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">m_rectangleWindow</span><span class="p">);</span>

<span class="p">....</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_performance_vergleich">4.2. Performance-Vergleich</h3>
<div class="paragraph">
<p>Die spannende Frage ist, wieviel langsamer ist das <code>QOpenGLWidget</code> im Vergleich zum direkten Zeichnen via <code>QOpenGLWindow</code> oder der eigenen <code>OpenGLWindow</code> Klasse aus <em>Tutorial 01</em>?</p>
</div>
<div class="paragraph">
<p>Im direkter Vergleich zwischen <em>Tutorial 03</em> und <em>Tutorial 04</em> fällt sofort auffällt auf, dass das Resize-Verhalten unterschiedlich ist. Es gibt eine merkliche Verzögerung bei der Größenänderung eines Widgets (sowohl unter Windows, als auch auf anderen Plattformen) und auch, wenn die Programme im Releasemodus kompiliert sind.</p>
</div>
<div class="paragraph">
<p>Da in diesen Testfällen nicht gerendert wird, liegt der Unterschied nur allein in der Widget-Compositing-Funktionalität im <code>QOpenGLWidget</code>.</p>
</div>
<div class="paragraph">
<p>Bei einem kleinen Benchmarktest (ca. 30 Sekunden lang mit dem Mauszeiger die Fenstergröße verändern, dabei die Anzahl der paintEvents() aufzeichnen und dann durch die Laufzeit teilen) kommt man auf:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>25 Fensteraktualisierungen/Sekunde bei der Variante mit <code>QOpenGLWindow</code>, und</p>
</li>
<li>
<p>15 Fensteraktualisierungen/Sekunde bei der Variante mit <code>QOpenGLWidget</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Das wohlgemerkt ohne OpenGL Zeichenaufrufe.</p>
</div>
<div class="paragraph">
<p>Interessant wird es, wenn man OpenGL-Animationen dazuschaltet. Dies kann man bei den Beispielen ganz einfach machen, wenn man die Frames für die Farbanimation von 120 auf, ca. 800 ändert. Dann läuft die Animation nach Klick auf "Animate Colors" ein paar Sekunden länger und man kann den CPU Overhead testen.</p>
</div>
<div class="paragraph">
<p>Bei beiden Varianten dauert die Animation exakt gleich lang, da jeweils mit nahezu 60 Frames pro Sekunde gerendert wird (bei mir zumindest).</p>
</div>
<div class="paragraph">
<p>Allerdings zeigen beide Varianten unterschiedliche CPU Auslastungen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2.4% (single-core) CPU Load bei der Variante mit <code>QOpenGLWindow</code>, und</p>
</li>
<li>
<p>7.9% (single-core) CPU Load bei der Variante mit <code>QOpenGLWidget</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ein Unterschied ist da, aber sicher nicht der Rede wert. Da dürfte der optimische Verzögerungseffekt beim Vergrößern/Verkleinern eines Fensters während der Animation eher noch stören.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transparenz">4.3. Transparenz</h3>
<div class="paragraph">
<p>Wie schon im Screenshot zu sehen, kann man auch halb-transparente Widgetanwendungen bauen, oder auch Anwendungen mit recht unregelmäßigen Formen.</p>
</div>
<div class="sect3">
<h4 id="_mit_qopenglwidget">4.3.1. Mit QOpenGLWidget</h4>
<div class="paragraph">
<p>Bei Verwendung des <code>QOpenGLWidgets</code> ist das recht einfach. Zunächst gibt man dem obersten Widget das Attribut <code>Qt::WA_TranslucentBackground</code>. Wer keine Titelleiste und keine Rahmen um das Fenster haben möchte, muss dem obersten Widget auch noch die Eigenschaft <code>Qt::FramelessWindowHint</code> geben, also z.B.:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="n">TestDialog</span> <span class="n">dlg</span><span class="p">;</span>
	<span class="c1">// transparent window</span>
	<span class="n">dlg</span><span class="p">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">WA_TranslucentBackground</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="c1">// no frame and flags.</span>
	<span class="n">dlg</span><span class="p">.</span><span class="n">setWindowFlag</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">FramelessWindowHint</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">dlg</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In der eigentlichen Zeichenfunktion muss man nur noch die Hintergrundfarbe auf Transparent umstellen (zumindest einen Alpha-Wert &lt; 1):</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">// fully transparent</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

	<span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Normalerweise würde man bei einem Alpha-Wert von 0 erwarten, dass der Hintergrund unverändert durchscheint, auch wenn die RGB Farbanteile der Hintergrundfarbe (clear color) irgendwelche Werte haben. Das ist aber nicht so - die Farben des Hintergrundes erscheinen etwas verblasst. Daher sollte man, wenn man wirklich den Hintergrund unverändert durchscheinen lassen möchte, die clear Color stets auf 0,0,0,0 setzen.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mit_qwindow_basierten_opengl_renderfenstern">4.3.2. Mit QWindow-basierten OpenGL Renderfenstern</h4>
<div class="paragraph">
<p>Bei den Varianten aus <em>Tutorial 01 .. 03</em> geht Transparenz auch, allerdings mit minimal mehr Aufwand. Bei der Konfiguration des <code>QSurfaceFormat</code> muss man einen AlphaBuffer festlegen (hier gezeigt beim Beispiel aus <em>Tutorial 01</em>).</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QGuiApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="c1">// Set OpenGL Version information</span>
	<span class="n">QSurfaceFormat</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setRenderableType</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">OpenGL</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setProfile</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">CoreProfile</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setVersion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setAlphaBufferSize</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

	<span class="n">TriangleWindow</span> <span class="n">window</span><span class="p">;</span>
	<span class="c1">// Note: The format must be set before show() is called.</span>
	<span class="n">window</span><span class="p">.</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
	<span class="n">window</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">FramelessWindowHint</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In der Render-Funktion muss man noch Alphablending einschalten, hier gezeigt am Beispiel aus <em>Tutorial 01</em>.</p>
</div>
<div class="listingblock">
<div class="title">TriangleWindow.cpp:render()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">TriangleWindow</span><span class="o">::</span><span class="n">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>

	<span class="c1">// Set the transparency to the scene to use the transparency of the fragment shader</span>
	<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
	<span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>

	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

    <span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_05_maus_und_tastatureingaben">5. Tutorial 05: Maus- und Tastatureingaben</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In diesem Tutorial geht es primär um Maus- und Tastatureingaben. Und damit das irgendwie Sinn macht, brauchen wir ein (schön großes) 3D Modell, und deshalb ist dieses Tutorial auch <em>sehr sehr lang</em>. Und nebenbei geht es noch um Verwaltung von Shaderobjekten, Zeichenobjekten, Nebeleffekt beim Gitterraster und und und&#8230;&#8203;</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_linux.png" alt="Tutorial_05">
</div>
<div class="title">Figure 5. Tutorial_05 (Linux Screenshot), "Die Welt aus 10000 und einer Box"</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_05">Tutorial_05</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In diesem Tutorial werden viele neue Dinge verwendet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>zwei Modelle (eins für die Boxen und eins für das Gitter), nebst dazugehörigen, unterschiedlichen Shaderprogrammen (das vom Gitter verwendet in die Tiefe abgeblendete Farben)</p>
</li>
<li>
<p>Tiefenpuffer, sodass Gitterlinien/Boxen korrekt vor/hintereinander gezeichnet werden</p>
</li>
<li>
<p>Model2World und World2View-Matrizen (mit perspektivischer Projektion)</p>
</li>
<li>
<p>Shaderprogramme und Renderobjekte (bzw. Objektgruppen) sind in Klassen zusammengefasst, wodurch der Quelltext deutlich übersichtlicher wird</p>
</li>
<li>
<p>eine Maus+Tastatursteuerung mit WASDQE + Mauslook, incl. Shift-Langsam-Bewege-Modus</p>
</li>
<li>
<p>und das Ganze wieder mit dem Schwerpunkt: Rendern nur wenn notwendig (Akku sparen!)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_überblick">5.1. Überblick</h3>
<div class="paragraph">
<p>Das Tutorial ist sehr lang, und der Quelltext entsprechend auch. Daher gehen wir in diesem Tutorial schrittweise vor. Die gezeigten Quelltextausschnitte stimmen daher nicht immer 100% mit dem finalen Quelltext überein (ich hab da aus didaktischen Gründen immer mal was weggelassen).</p>
</div>
<div class="paragraph">
<p>Folgende Implementierungsschritte werden besprochen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Anpassung der Klasse <code>OpenGLWindow</code> an die in <code>QOpenGLWidget</code> bzw. <code>QOpenGLWindow</code> verwendeten Funktionsnamen</p>
</li>
<li>
<p>Vorstellung der Klasse <code>SceneView</code>, die das bisherige <code>TriangleWindow</code> oder <code>RectangleWindow</code> ersetzt</p>
</li>
<li>
<p>Transformationsmatrizen: Model &#8594; World &#8594; Kamera &#8594; Projektion (Klassen <code>Transform3D</code> und <code>Camera</code>)</p>
</li>
<li>
<p>Tastatur- und Mauseingabebehandlung (Klasse <code>KeyboardMouseHandler</code>)</p>
</li>
<li>
<p>Kapselung der Shaderprogramme und Initialisierung und Verwendung derselben (Klasse <code>ShaderProgram</code>)</p>
</li>
<li>
<p>Kapselung der Zeichenroutinen für das Gitterraster, Abblendeffekt am Horizont im Shader (Klasse <code>GridObject</code> und Shader <code>grid.vert</code> und <code>grid.frag</code>)</p>
</li>
<li>
<p>Kapselung der Zeichenroutinen für die Boxen (Klassen <code>BoxObject</code> und <code>BoxMesh</code>, und Shader <code>withWorldAndCamera.vert</code> und <code>simple.frag</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_fenster_basisklasse_openglwindow">5.2. Fenster-Basisklasse OpenGLWindow</h3>
<div class="paragraph">
<p>Als Grundlage für die Implementierung wird die Klasse <code>OpenGLWindow</code> aus <em>Tutorial 01</em> verwendet, allerdings etwas abgewandelt. Letztlich wird die Schnittstelle angepasst, um ungefähr der des <code>QOpenGLWidget</code> zu entsprechen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">OpenGLWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWindow</span><span class="p">,</span> <span class="k">protected</span> <span class="n">QOpenGLFunctions</span> <span class="p">{</span>
	<span class="n">Q_OBJECT</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">);</span>

<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">renderLater</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">renderNow</span><span class="p">();</span>

<span class="nl">protected:</span>
	<span class="kt">bool</span> <span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">resizeEvent</span><span class="p">(</span><span class="n">QResizeEvent</span> <span class="o">*</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">resizeGL</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span> <span class="n">Q_UNUSED</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="n">Q_UNUSED</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">QOpenGLContext</span> <span class="o">*</span><span class="n">m_context</span><span class="p">;</span>

<span class="nl">private:</span>
	<span class="kt">void</span> <span class="n">initOpenGL</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktionen <code>initializeGL()</code> und <code>paintGL()</code> sind aus den vorangegangen Tutorials bekannt. Die Funktion <code>resizeGL()</code> ist eigentlich nur eine Bequemlichkeitsfunktion, welche aus dem Eventhandler <code>resizeEvent()</code> aufgerufen wird.</p>
</div>
<div class="paragraph">
<p>Neu ist jedoch die Funktion <code>initOpenGL()</code>, in der die OpenGL-Initialisierung (OpenGL Context) gemacht wird.</p>
</div>
<div class="listingblock">
<div class="title">OpenGLWindow.cpp:initOpenGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">initOpenGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">m_context</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">);</span>

	<span class="n">m_context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLContext</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">requestedFormat</span><span class="p">());</span>
	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">();</span>

	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
	<span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">m_context</span><span class="o">-&gt;</span><span class="n">isValid</span><span class="p">());</span>

	<span class="n">initializeOpenGLFunctions</span><span class="p">();</span>
	<span class="n">initializeGL</span><span class="p">();</span> <span class="c1">// call user code</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Normalerweise wird die Initialisierung beim ersten Anzeigen des Fensters (genaugenommen beim ersten ResizeEvent) aufgerufen, bzw. beim ersten Zeichnen.</p>
</div>
<div class="listingblock">
<div class="title">OpenGLWindow.cpp: Funktion resizeEvent()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">resizeEvent</span><span class="p">(</span><span class="n">QResizeEvent</span> <span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QWindow</span><span class="o">::</span><span class="n">resizeEvent</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="c1">// initialize on first call</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_context</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
		<span class="n">initOpenGL</span><span class="p">();</span>

	<span class="n">resizeGL</span><span class="p">(</span><span class="n">width</span><span class="p">(),</span> <span class="n">height</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unabhängig von dieser Initializierungsfunktion muss man natürlich die Funktion <code>initializeGL()</code> implementieren. Alles andere in der Klasse ist altbekannt.</p>
</div>
</div>
<div class="sect2">
<h3 id="_klasse_sceneview_die_konkrete_implementierung">5.3. Klasse SceneView - die konkrete Implementierung</h3>
<div class="sect3">
<h4 id="_klassendeklaration">5.3.1. Klassendeklaration</h4>
<div class="paragraph">
<p>Zwecks Überblick ist hier zunächst die Klassendeklaration in Teilen. Zuerst die üblichen Verdächtigen:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SceneView</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">SceneView</span><span class="p">();</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">SceneView</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="nl">protected:</span>
	<span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">resizeGL</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dann kommen die Ereignisbehandlungsroutinen für die Tastatur- und Mauseingaben. Dazu gehören auch die Hilfsfunktionen <code>checkInput()</code> und <code>processInput()</code>, die im Abschnitt zur Tastatur- und Mauseingabe erklärt sind. Die Member-Variablen <code>m_keyboardMouseHandler</code> und <code>m_inputEventReceived</code> gehören auch dazu.</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView, fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="kt">void</span> <span class="n">keyPressEvent</span><span class="p">(</span><span class="n">QKeyEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">keyReleaseEvent</span><span class="p">(</span><span class="n">QKeyEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">mousePressEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">mouseReleaseEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">mouseMoveEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">wheelEvent</span><span class="p">(</span><span class="n">QWheelEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
	<span class="kt">void</span> <span class="nf">checkInput</span><span class="p">();</span>
	<span class="kt">void</span> <span class="nf">processInput</span><span class="p">();</span>

	<span class="n">KeyboardMouseHandler</span>		<span class="n">m_keyboardMouseHandler</span><span class="p">;</span>
	<span class="kt">bool</span>						<span class="n">m_inputEventReceived</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dann kommt die Funktion <code>updateWorld2ViewMatrix()</code> zur Koordinatentransformation und die dazugehörigen Member-Variablen.</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView, fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="kt">void</span> <span class="nf">updateWorld2ViewMatrix</span><span class="p">();</span>

	<span class="n">QMatrix4x4</span>					<span class="n">m_projection</span><span class="p">;</span>
	<span class="n">Transform3D</span>					<span class="n">m_transform</span><span class="p">;</span>
	<span class="n">Camera</span>						<span class="n">m_camera</span><span class="p">;</span>
	<span class="n">QMatrix4x4</span>					<span class="n">m_worldToView</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zuletzt kommen Member-Variablen, die die Shader-Programme und Zeichenobjekte kapseln (beinhalten Shader, VAO, VBO, EBO, etc.)</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView, fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="n">QList</span><span class="o">&lt;</span><span class="n">ShaderProgram</span><span class="o">&gt;</span>		<span class="n">m_shaderPrograms</span><span class="p">;</span>

	<span class="n">BoxObject</span>					<span class="n">m_boxObject</span><span class="p">;</span>
	<span class="n">GridObject</span>					<span class="n">m_gridObject</span><span class="p">;</span>
<span class="err">}</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Und das war&#8217;s auch schon - recht kompakt, oder?</p>
</div>
</div>
<div class="sect3">
<h4 id="_das_aktualisierungskonzept">5.3.2. Das Aktualisierungskonzept</h4>
<div class="paragraph">
<p>Erklärtes Ziel dieser OpenGL-Implementierung ist nur dann zu rendern, wenn es wirklich notwendig ist. Also:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>wenn die Fenstergröße (Viewport) verändert wurde,</p>
</li>
<li>
<p>wenn das Fenster angezeigt/sichtbar wird (exposed),</p>
</li>
<li>
<p>wenn durch Nutzerinteraktion die Kameraposition verändert wird, und</p>
</li>
<li>
<p>wenn die Szene selbst transformiert/verändert wird (z.B. programmgesteuerte Animation&#8230;&#8203;)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Wenn man jetzt bei jedem Eintreffen eines solchen Ereignisses jedesmal neu zeichnen würde, wäre das mit ziemlichem Overhead verbunden. Besser ist es, beim Eintreffen eines solchen Ereignisses einfach nur ein Neuzeichnen anzufordern. Da die <code>UpdateRequest</code>-Ereignisse normalerweise mit der Bildschirmfrequenz synchronisiert sind, kann es natürlich sein, dass mehrfach hintereinander <code>UpdateRequest</code>-Events an die Eventloop angehängt werden. Dabei werden diese aber zusammengefasst und nur ein Event ausgeschickt. Es muss ja auch nur einmal je angezeigtem Frame gezeichnet werden.</p>
</div>
<div class="paragraph">
<p>Grundsätzlich muss man also nur die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#requestUpdate">QWindow::requestUpdate()</a> (oder unsere Bequemlichkeitsfunktion <code>renderLater()</code>) aufrufen, damit beim nächsten VSync wieder neu gezeichnet wird.</p>
</div>
<div class="paragraph">
<p>Leider funktionier das Verfahren im Fall des <code>ExposeEvent</code> bzw. <code>ResizeEvent</code> nicht perfekt. Gerade unter Windows führt das beim Vergrößern des Fensters zu unschönen Artefakten am rechten und unteren Bildschirmrand. Daher muss man in diesem Fall tatsächlich sofort in der Ereignisbehandlungsroutine neu zeichnen und dabei den OpenGL Viewport bereits an die neue Fenstergröße anpassen. Das Neuzeichnen wird direkt im ExposeEvent-Handler von <code>OpenGLWindow</code> ausgelöst:</p>
</div>
<div class="listingblock">
<div class="title">OpenGLWindow.cpp:exposeEvent()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span> <span class="cm">/*event*/</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">renderNow</span><span class="p">();</span> <span class="c1">// update right now</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Bei Größenveränderung des Fensters sendet Qt immer zuerst ein <code>ResizeEvent</code> gefolgt von einem <code>ExposeEvent</code> aus. Daher sollte man in der Funktion <code>SceneView::resizeEvent()</code> <em>nicht</em> <code>renderLater()</code> aufrufen!</p>
</div>
<div class="paragraph">
<p>Ohne eine Aufruf von <code>renderLater()</code> im ResizeEvent-Handler erhält man folgende Aufrufreihenfolge bei der Fenstervergrößerung:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1222 x 891
OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1224 x 892</pre>
</div>
</div>
<div class="paragraph">
<p>Ruft man stattdessen <code>renderLater()</code> auf, erhält man:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1283 x 910
SceneView::paintGL(): Rendering to: 1283 x 910
OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1288 x 912
SceneView::paintGL(): Rendering to: 1288 x 912</pre>
</div>
</div>
<div class="paragraph">
<p>Wie man sieht, wird jedes Mal doppelt gezeichnet, was eine deutlich spürbare Verzögerung bedeutet. Grundsätzlich hilf es zu wissen, dass:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>beim ersten Anzeigen eines Fensters immer erst ein <code>ResizeEvent</code>, gefolgt von einem <code>ExposeEvent</code> geschickt wird</p>
</li>
<li>
<p>beim Größenändern eines Fensters ebenfalls immer ein <code>ResizeEvent</code>, gefolgt von einem <code>ExposeEvent</code> geschickt wird</p>
</li>
<li>
<p>beim Minimieren und Maximieren eines Fensters nur je ein (oder auf dem Mac mehrere) <code>ExposeEvent</code> geschickt werden. Dies kann man nutzen, um eine Animation zu stoppen und beim erneuten Anzeigen (<code>isExposed() == true</code>) wieder zu starten. Dies ist aber nicht der Fokus in diesem Tutorial. Daher könnte man auch das <code>ExposeEvent</code> komplett ignorieren und <code>renderNow()</code> direkt am Ende von  <code>OpenGLWindow::resizeEvent()</code> aufrufen. So wie es aktuell implementiert ist, wird beim Minimieren und Maximieren mehrfach <code>ExposeEvent</code> mit <code>isExposed() == true</code> aufgerufen und damit wird mehrfach gezeichnet, trotz unverändertem Viewport und unveränderte Szene. Das ist aber nicht weiter bemerkbar und verschmerzbar.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_verwendung_der_klasse_sceneview">5.3.3. Verwendung der Klasse <em>SceneView</em></h4>
<div class="paragraph">
<p>Die Klasse <code>SceneView</code> wird als <code>QWindow</code>-basierte Klasse selbst via Widget-Container in den Testdialog eingebettet (siehe <em>Tutorial 03</em>).</p>
</div>
<div class="paragraph">
<p>Bei der Analyse des Tutorialquelltextes kann man sich von außen nach innen "arbeiten":</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>main.cpp</code> - Instanziert <code>TestDialog</code></p>
</li>
<li>
<p><code>TestDialog.cpp</code> - Instanziert <code>SceneView</code> und bettet das Objekt via Window-Container ein.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Es gibt im Quelltext von <code>TestDialog.cpp</code> nur ein neues Feature: Antialiasing (siehe letzter Abschnitt "Antialiasing" dieses Tutorials).</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementierung_der_klasse_sceneview">5.3.4. Implementierung der Klasse <em>SceneView</em></h4>
<div class="paragraph">
<p>Und da wären wir auch schon bei der Implementierung des Klasse <code>SceneView</code>.</p>
</div>
<div class="paragraph">
<p>Im Konstruktor werden letztlich 3 Dinge gemacht:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>dem Tastatur/Maus-Eingabemanager werden die für uns interessanten Tasten mitgeteilt, siehe  Abschnitt "Tastatur- und Mauseingabe"</p>
</li>
<li>
<p>die beiden ShaderProgramm-Container Objekte werden erstellt und konfiguriert, siehe Abschnitt "Shaderprogramme"</p>
</li>
<li>
<p>die Kamera- und Welttransformationsmatrizen werden auf ein paar Standardwerte eingestellt, siehe Abschnitt "Transformationsmatrizen"</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp, Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SceneView</span><span class="o">::</span><span class="n">SceneView</span><span class="p">()</span> <span class="o">:</span>
	<span class="n">m_inputEventReceived</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// tell keyboard handler to monitor certain keys</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_W</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_A</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_S</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_D</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Q</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_E</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Shift</span><span class="p">);</span>

	<span class="c1">// *** create scene (no OpenGL calls are being issued below, just the data structures are created.</span>

	<span class="c1">// Shaderprogram #0 : regular geometry (painting triangles via element index)</span>
	<span class="n">ShaderProgram</span> <span class="n">blocks</span><span class="p">(</span><span class="s">":/shaders/withWorldAndCamera.vert"</span><span class="p">,</span><span class="s">":/shaders/simple.frag"</span><span class="p">);</span>
	<span class="n">blocks</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"worldToView"</span><span class="p">);</span>
	<span class="n">m_shaderPrograms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">blocks</span> <span class="p">);</span>

	<span class="c1">// Shaderprogram #1 : grid (painting grid lines)</span>
	<span class="n">ShaderProgram</span> <span class="n">grid</span><span class="p">(</span><span class="s">":/shaders/grid.vert"</span><span class="p">,</span><span class="s">":/shaders/simple.frag"</span><span class="p">);</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"worldToView"</span><span class="p">);</span> <span class="c1">// mat4</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"gridColor"</span><span class="p">);</span> <span class="c1">// vec3</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"backColor"</span><span class="p">);</span> <span class="c1">// vec3</span>
	<span class="n">m_shaderPrograms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">grid</span> <span class="p">);</span>

	<span class="c1">// *** initialize camera placement and model placement in the world</span>

	<span class="c1">// move objects a little bit to the back of the scene (negative z coordinates = further back)</span>
	<span class="n">m_transform</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">m_camera</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">m_camera</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">right</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Im Konstruktor werden nur Eigenschaften für die Shaderprogramme festgelegt, die eigentliche Initialisierung (OpenGL-Aufrufe) findet in <code>initializeGL()</code> statt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Im Destruktor der Klasse werden die OpenGL-Objekte wieder freigegeben:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp, Destruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SceneView</span><span class="o">::~</span><span class="n">SceneView</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ShaderProgram</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">m_shaderPrograms</span><span class="p">)</span>
		<span class="n">p</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>

	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_gridObject</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist hier, dass der OpenGL-Context für das aktuelle Fenster aktuell gesetzt wird (<code>m_context-&gt;makeCurrent(this)</code>). Damit können dann die OpenGL-Objekte freigegeben werden. Dies erfolgt in den <code>destroy()</code> Funktionen der Shaderprogramm-Wrapper-Klasse und Zeichen-Objekt-Wrapper-Klassen.</p>
</div>
</div>
<div class="sect3">
<h4 id="_opengl_initialisierung">5.3.5. OpenGL-Initialisierung</h4>
<div class="paragraph">
<p>Die eigentlich Initialisierung der OpenGL-Objekte (Shaderprogramme und Pufferobjekte) erfolgt in <code>initializeGL()</code>:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:initializeGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define SHADER(x) m_shaderPrograms[x].shaderProgram()
</span>
<span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">initializeGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// initialize shader programs</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ShaderProgram</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">m_shaderPrograms</span><span class="p">)</span>
		<span class="n">p</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>

	<span class="c1">// tell OpenGL to show only faces whose normal vector points towards us</span>
	<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
	<span class="c1">// enable depth testing, important for the grid and for the drawing order of several objects</span>
	<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>

	<span class="c1">// initialize drawable objects</span>
	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">m_gridObject</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dank der Kapselung der Shaderprogramm-Initialisierung in der Klasse <code>ShaderProgram</code> und der Kapselung der Zeichenobjekt-spezifischen Initialisierung in den Objekten ist diese Funktion sehr viel übersichtlicher als in den bisherigen Tutorials.</p>
</div>
<div class="paragraph">
<p>Das Makro <code>SHADER(x)</code> wird verwendet, um bequem auf das <code>QOpenGLShaderProgram</code> Objekt in der Wrapper-Klasse zuzugreifen.</p>
</div>
<div class="paragraph">
<p>Die beiden <code>glXXX</code> Befehle in der Mitte der Funktion schalten zwei für 3D Szenen wichtige Funktionen ein:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>GL_CULL_FACE</code> - Zeichne Flächen nicht, welche mit dem "Rücken" zu uns stehen</p>
</li>
<li>
<p><code>GL_DEPTH_TEST</code> - Führe beim Zeichnen der Fragmente einen Tiefentest durch, und verwerfe weiter hintenliegende Fragmente. Das ist wichtig dafür, dass die gezeichneten Boxen das dahinterliegende Gitter überdecken. Der dafür benötigte Tiefenpuffer wird über <code>QSurfaceFormat</code> konfiguriert (<a href="https://doc.qt.io/qt-5/qsurfaceformat.html#setDepthBufferSize">QSurfaceFormat::setDepthBufferSize()</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Funktion <code>glDepthFunc(GL_LESS)</code> muss nicht aufgerufen werden, da das bei OpenGL der Standard ist.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man kann testweise mal das Flag <code>GL_DEPTH_TEST</code> nicht setzen - die etwas verwirrende Darstellung ist, nun ja, verwirrend.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Für den Tiefentest ist ein zusätzlicher Tiefenpuffer notwendig (bisher hatten wir nur den Farbpuffer (<em>engl. Color Buffer</em>). Wichtig ist daher, dass bei Verwendung eines Tiefenpuffers dieser Puffer ebenso wie der Farbpuffer zu Beginn des Zeichnens gelöscht wird. Dies passiert in <code>paintGL()</code>:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>

	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>

	<span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Falls bei Verwendung des Tiefenpuffers/Tiefentests das Problem des z-Fighting auftritt, kann man die Genauigkeit des Tiefenpuffers erhöhen. Dies erfolgt durch Aufruf der Funktion <code>QSurfaceFormat::setDepthBufferSize()</code>. In diesem Tutorial liegen die Boxen immer schön weit auseinander, sodass eine Genauigkeit von 8bit ausreicht. Dieser wird bei Konfiguration des <code>QSurfaceFormat</code>-Objekts in <code>TestDialog.cpp</code> gesetzt:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>format.setDepthBufferSize(8);</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tastatur_und_mauseingabe">5.4. Tastatur- und Mauseingabe</h3>
<div class="paragraph">
<p>Qt stellt in <code>QWindow</code> und <code>QWidget</code> Ereignisbehandlungsroutinen für Tastatur- und Mauseingaben zur Verfügung. Die Deklaration dieser Funktion sind oben in der <code>SceneView</code> Klassendeklaration zu sehen.</p>
</div>
<div class="paragraph">
<p>Wenn man eine Taste auf der Tastatur drückt wird ein <code>QEvent::KeyPress</code> ausgelöst und die Memberfunktion <code>keyPressEvent(QKeyEvent *event)</code> aufgerufen. Das passiert auch, wenn man die Taste <em>gedrückt</em> hält. Unterscheiden kann man dieses durch Prüfen der Eigenschaft <code>AutoRepeat</code> (<code>QKeyEvent::isAutoRepeat()</code>).</p>
</div>
<div class="paragraph">
<p>Für die Navigation in einer 3D Umgebung hält man die Tasten (z.B. WASD oder ähnliche) längere Zeit gedrückt (d.h. über mehrere Frames hinweg). Man benötigt also einen Zustandsmanager, der sich den aktuellen Zustand der Tasten merkt.</p>
</div>
<div class="paragraph">
<p>Ein solcher "Inputmanager" hält intern also für jede (berücksichtigte) Taste einen Zustand:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nicht gedrückt</p>
</li>
<li>
<p>Gerade gedrückt</p>
</li>
<li>
<p>Wurde gedrückt</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Letzterer ist eigentlich nur dann wichtig, wenn auf einzelne Tastendrücke reagiert werden soll, während eventuell eine aufwändige Neuzeichenroutine läuft.</p>
</div>
<div class="sect3">
<h4 id="_der_tastatur_und_maus_zustandsmanager">5.4.1. Der Tastatur- und Maus-Zustandsmanager</h4>
<div class="paragraph">
<p>Man könnte die gesamte Tastatur- und Mausbehandlung natürlich auch direkt in der Klasse <code>SceneView</code> implementieren, in der auch die Ereignisbehandlungsfunktionen aufgerufen werden. Es ist aber übersichtlicher, diese in der Klasse <code>KeyboardMouseHandler</code> zu kapseln.</p>
</div>
<div class="paragraph">
<p>Die Aufgabe dieser Klasse ist letztlich sich zu merken, welche Taste/Mausknopf gerade gedrückt ist. Die Implementierung der Klasse ist für das Tutorial eigentlich nicht so wichtig, vielleicht lohnt aber ein Blick auf die Klassendeklaration:</p>
</div>
<div class="listingblock">
<div class="title">KeyboardMouseHandler.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">KeyboardMouseHandler</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">KeyboardMouseHandler</span><span class="p">();</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">KeyboardMouseHandler</span><span class="p">();</span>

	<span class="c1">// functions to manage known keys</span>
	<span class="kt">void</span> <span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key</span> <span class="n">k</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">clearRecognizedKeys</span><span class="p">();</span>

    <span class="c1">// event handler helpers</span>
	<span class="kt">void</span> <span class="n">keyPressEvent</span><span class="p">(</span><span class="n">QKeyEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">keyReleaseEvent</span><span class="p">(</span><span class="n">QKeyEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">mousePressEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">mouseReleaseEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">wheelEvent</span><span class="p">(</span><span class="n">QWheelEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

    <span class="c1">// state changing helper functions</span>
	<span class="kt">bool</span> <span class="n">pressKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key</span> <span class="n">k</span><span class="p">);</span>
	<span class="kt">bool</span> <span class="n">releaseKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key</span> <span class="n">k</span><span class="p">);</span>
	<span class="kt">bool</span> <span class="n">pressButton</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">MouseButton</span> <span class="n">btn</span><span class="p">,</span> <span class="n">QPoint</span> <span class="n">currentPos</span><span class="p">);</span>
	<span class="kt">bool</span> <span class="n">releaseButton</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">MouseButton</span> <span class="n">btn</span><span class="p">);</span>

    <span class="c1">// query functions</span>
	<span class="kt">bool</span> <span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="n">buttonDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">MouseButton</span> <span class="n">btn</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
	<span class="n">QPoint</span> <span class="n">mouseDownPos</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_mouseDownPos</span><span class="p">;</span> <span class="p">}</span>
	<span class="kt">int</span> <span class="n">wheelDelta</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// state reset functions</span>
	<span class="n">QPoint</span> <span class="n">resetMouseDelta</span><span class="p">(</span><span class="k">const</span> <span class="n">QPoint</span> <span class="n">currentPos</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">resetWheelDelta</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">clearWasPressedKeyStates</span><span class="p">();</span>

<span class="nl">private:</span>
	<span class="k">enum</span> <span class="n">KeyStates</span> <span class="p">{</span>
		<span class="n">StateNotPressed</span><span class="p">,</span>
		<span class="n">StateHeld</span><span class="p">,</span>
		<span class="n">StateWasPressed</span>
	<span class="p">};</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key</span><span class="o">&gt;</span>	<span class="n">m_keys</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyStates</span><span class="o">&gt;</span>	<span class="n">m_keyStates</span><span class="p">;</span>

	<span class="n">KeyStates</span>				<span class="n">m_leftButtonDown</span><span class="p">;</span>
	<span class="n">KeyStates</span>				<span class="n">m_middleButtonDown</span><span class="p">;</span>
	<span class="n">KeyStates</span>				<span class="n">m_rightButtonDown</span><span class="p">;</span>

	<span class="n">QPoint</span>					<span class="n">m_mouseDownPos</span><span class="p">;</span>

	<span class="kt">int</span>						<span class="n">m_wheelDelta</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Eine <code>KeyboardMouseHandler</code>-Klasse wird nach der Erstellung durch Aufrufe von <code>addRecognizedKey()</code> konfiguriert (siehe Konstruktor der Klasse <code>SceneView</code>).</p>
</div>
<div class="paragraph">
<p>Für die Tastatur- und Maus-Ereignisbehandlungsroutinen gibt es passende Hilfsfunktionen, sodass man von den Event-Funktionen der eigenen View-Klasse einfach diese Hilfsfunktionen aufrufen kann. Die Zustandsänderungslogik (auch das Prüfen auf AutoRepeat) wird in diesen Funktionen gemacht. Bei bekannten Tasten wird der <code>QKeyEvent</code> oder <code>QMouseEvent</code> akzeptiert, sonst ignoriert.</p>
</div>
<div class="paragraph">
<p>Den Zustand einzelner Tasten kann man auch programmgesteuert durch die <code>pressXXX</code> und <code>releaseXXX</code> Funktionen ändern.</p>
</div>
<div class="paragraph">
<p>Danach kommen die Funktionen zum Abfragen des Zustands. Bei Tasten ist die Abfrage mit <code>keyDown()</code> oder <code>buttonDown()</code> recht klar (sowohl der Zustand "gerade gedrückt", als auch "gedrückt und wieder losgelassen" liefern hier <code>true</code> zurück).</p>
</div>
<div class="paragraph">
<p>Bei der Mausbewegung und Scroll-Rad muss immer die <em>Veränderung</em> zwischen zwei Abfragezeitpunkten angeschaut werden. Bei Verwendung einer Free-Mouse-Look-Taste (hier rechte Maustaste), wird beim Drücken dieser Taste die globale Cursorpostion abgelegt, welche über <code>mouseDownPos()</code> abgefragt werden kann. Bei Mouse-Wheel-Ereignissen werden die Drehstufen (Winkel/Ticks) addiert.</p>
</div>
<div class="paragraph">
<p>Wenn man diese Änderungen nun in eine Bewegung umwandelt, muss man diese nach dem Auslesen wieder zurücksetzen. Dies erfolgt mit den Funktionen <code>resetMouseDelta()</code> und <code>resetWheelDelta()</code>, welche beide die bislang erfassten Differenzen zurückliefern. Die const-Abfragefunktionen <code>mouseDownPos()</code> und <code>wheelDelta()</code> können also verwendet werden, um zu Testen, ob es eine Maus-/Scrollradbewegung gab. Und beim Anwender der Änderungen ruf man die <code>resetXXX()</code> Funktionen auf.</p>
</div>
<div class="paragraph">
<p>Zuletzt muss man die Funktion <code>clearWasPressedKeyStates()</code> nach Abfrage der Tasten aufrufen, um die "wurde gedrückt" Zustände wieder in den "Nicht gedrückt" Zustand zurückzusetzen.</p>
</div>
<div class="paragraph">
<p>Die Implementierung der Klasse ist recht einfach und selbsterklärend und muss hier nicht näher ausgeführt werden. Interessant ist die Verwendung der Klasse. Dazu müssen wir uns zunächst den Programmauflauf der Ereignisschleife und Auswertung der Tasteneingabe genauer anschauen.</p>
</div>
</div>
<div class="sect3">
<h4 id="_die_ereignisschleife_und_tastatur_mausevents">5.4.2. Die Ereignisschleife und Tastatur-/Mausevents</h4>
<div class="paragraph">
<p>Zwischen zwei Frames (also Aufrufen von <code>paintGL()</code>) läuft das Programm in der Ereignisschleife. Sobald eine Taste gedrückt oder losgelassen wird, ruft Qt die entsprechende Ereignisbehandlungsfunktion auf, d.h. <code>keyPressEvent()</code> bzw. <code>keyReleaseEvent()</code>. Ebenso werden bei Mausaktionen die entsprechenden Aktionen ausgelöst.</p>
</div>
<div class="paragraph">
<p>Die Aufrufe werden an die gleichnamigen Funktionen in Zustandsmanager (<code>KeyboardMouseHandler</code>) weitergereicht. Wenn die betreffende Taste dem Zustandsmanager bekannt ist, wird der aktuelle Zustand im Zustandsmanager entsprechend geändert.</p>
</div>
<div class="paragraph">
<p>Nun wird noch geprüft, ob die Taste eine Szenenveränderung (bspw. Kamerabewegung) bewirkt. Dies erfolgt in der Funktion <code>SceneView::checkInput()</code>.</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:checkInput()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">checkInput</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// trigger key held?</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">buttonDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">RightButton</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// any of the interesting keys held?</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_W</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_A</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_S</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_D</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Q</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_E</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">m_inputEventReceived</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">renderLater</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// has the mouse been moved?</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">mouseDownPos</span><span class="p">()</span> <span class="o">!=</span> <span class="n">QCursor</span><span class="o">::</span><span class="n">pos</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">m_inputEventReceived</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">renderLater</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// scroll-wheel turned?</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">wheelDelta</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_inputEventReceived</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">renderLater</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In dieser Funktion werden nun die Abfragefunktionen verwendet, d.h. der Zustand des Tastatur-/Maus-Zustandsmanagers wird nicht verändert. Auch ist zu beachten, dass die Abfrage nach dem Mausrad separat erfolgt.</p>
</div>
<div class="paragraph">
<p>Wird eine relevante Taste oder Mausbewegung erkannt, wird durch Aufruf von <code>renderLater()</code> ein Zeichenaufruf in die Event-Schleife eingereiht (kommt beim nächsten VSync) und das Flag <code>m_inputEventReceived</code> wird gesetzt dann geht die Kontrolle wieder zurück an die Ereignisschleife.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es sollte wirklich nur neu gezeichnet werden, wenn dies durch Tastendruck- oder Mausbewegung notwendig wird. Dadurch, dass das <code>UpdateRequest</code> nur bei Bedarf gesendet wird, kann man ansonsten wild auf der Tastatur herumhämmern, ohne dass auch nur ein OpenGL-Befehl aufgerufen wird.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es ist nun möglich, dass ein weiteres Tastaturereignis eintrifft, <em>bevor</em> das <code>UpdateRequest</code>-Ereignis eintritt. Bspw. könnte dies das <code>QEvent::KeyRelease</code>-Ereignis eines gerade zuvor eingetroffenen <code>QEvent::KeyPress</code>-Ereignisses derselben Taste sein. Deshalb wird der Zustand einer Taste beim <code>keyReleaseEvent()</code> auf "Wurde gedrückt" geändert, und nicht einfach wieder zurück auf "Nicht gedrückt". Sonst hätte man im Zustandsmanager keine Information mehr darüber, dass die Taste in diesem Frame kurz gedrückt wurde. Das ist zwar bei hohen Bildwiederholfrequenzen hinreichend unwahrscheinlich, kann aber bei sehr komplexen Szenen (bzw. schwacher Hardware) hilfreich sein.</p>
</div>
</div>
<div class="sect3">
<h4 id="_auswertung_der_eingabe_und_anpassung_der_kameraposition_und_ausrichtung">5.4.3. Auswertung der Eingabe und Anpassung der Kameraposition- und Ausrichtung</h4>
<div class="paragraph">
<p>Die eigentliche Auswertung der Tastenzustände und Bewegung der Kamera erfolgt am Anfang der <code>SceneView::paintGL()</code>-Funktion:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// process input, i.e. check if any keys have been pressed</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_inputEventReceived</span><span class="p">)</span>
		<span class="n">processInput</span><span class="p">();</span>

    <span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Da die Zeichenfunktion aus einer Vielzahl von Gründen aufgerufen werden kann, dient das Flag <code>m_inputEventReceived</code> dazu, nur dann die Eingaben auszuwerten, wenn es tatsächlich welche gab.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Der Zeitaufwand für die Auswertung der Eingaben ist nicht wirklich groß. Da aber einige Matrizenoperationen involviert sind, kann man sich die Arbeit auch sparen, daher das "dirty" Flag <code>m_inputEventReceived</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Auswertung des Tastatur- und Mauszustandes erfolgt in der Funktion <code>SceneView::processInput()</code>:</p>
</div>
<div class="listingblock">
<div class="title">SceneView:processInput()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">processInput</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_inputEventReceived</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">buttonDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">RightButton</span><span class="p">))</span> <span class="p">{</span>

		<span class="c1">// Handle translations</span>
		<span class="n">QVector3D</span> <span class="n">translation</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_W</span><span class="p">))</span> 		<span class="n">translation</span> <span class="o">+=</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_S</span><span class="p">))</span> 		<span class="n">translation</span> <span class="o">-=</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_A</span><span class="p">))</span> 		<span class="n">translation</span> <span class="o">-=</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">right</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_D</span><span class="p">))</span> 		<span class="n">translation</span> <span class="o">+=</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">right</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Q</span><span class="p">))</span> 		<span class="n">translation</span> <span class="o">-=</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">up</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_E</span><span class="p">))</span> 		<span class="n">translation</span> <span class="o">+=</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">up</span><span class="p">();</span>

		<span class="kt">float</span> <span class="n">transSpeed</span> <span class="o">=</span> <span class="mf">0.8</span><span class="n">f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Shift</span><span class="p">))</span>
			<span class="n">transSpeed</span> <span class="o">=</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">;</span>
		<span class="n">m_camera</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">transSpeed</span> <span class="o">*</span> <span class="n">translation</span><span class="p">);</span>

		<span class="c1">// Handle rotations</span>
		<span class="c1">// get and reset mouse delta (pass current mouse cursor position)</span>
		<span class="n">QPoint</span> <span class="n">mouseDelta</span> <span class="o">=</span> <span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">resetMouseDelta</span><span class="p">(</span><span class="n">QCursor</span><span class="o">::</span><span class="n">pos</span><span class="p">());</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">rotatationSpeed</span>  <span class="o">=</span> <span class="mf">0.4</span><span class="n">f</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">QVector3D</span> <span class="n">LocalUp</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">// same as in Camera::up()</span>
		<span class="n">m_camera</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">rotatationSpeed</span> <span class="o">*</span> <span class="n">mouseDelta</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">LocalUp</span><span class="p">);</span>
		<span class="n">m_camera</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">rotatationSpeed</span> <span class="o">*</span> <span class="n">mouseDelta</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">right</span><span class="p">());</span>

		<span class="c1">// finally, reset "WasPressed" key states</span>
		<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">clearWasPressedKeyStates</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">wheelDelta</span> <span class="o">=</span> <span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">resetWheelDelta</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wheelDelta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">transSpeed</span> <span class="o">=</span> <span class="mf">8.</span><span class="n">f</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">keyDown</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Shift</span><span class="p">))</span>
			<span class="n">transSpeed</span> <span class="o">=</span> <span class="mf">0.8</span><span class="n">f</span><span class="p">;</span>
		<span class="n">m_camera</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">wheelDelta</span> <span class="o">*</span> <span class="n">transSpeed</span> <span class="o">*</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">forward</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">updateWorld2ViewMatrix</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Auch in dieser Funktion werden Bewegungen der Kamera durch Tastendrücke und Schwenker durch Mausbewegung unabhängig vom Scrollrad-Zoom behandelt. Am Ende der Funktion werden die Welt-zu-Perspektive-Transformationsmatrizen angepasst. Die relevanten Matrizen und auch das Kamera-Objekt (Klasse <code>Camera</code>) sind im Abschnitt "Transformationsmatrizen und Kamera" weiter unten beschrieben.</p>
</div>
<div class="paragraph">
<p>Die Bewegung der Kamera ist recht einfach nachvollziehbar - je nach gedrückter Taste wird eine Verschieberichtung auf den Vektor <code>translation</code> addiert. Der tatsächliche Verschiebevektor wird durch Multiplikation mit einer Geschwindigkeit <code>transSpeed</code> berechnet. Hier ist auch die "Verlangsamung-bei-Shift-Tastendruck"-eingebaut.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Geschwindigkeit ist hier als "Bewegung je Frame" zu verstehen, was bei stark veränderlichen Frameraten (z.B. bei komplexer Geometrie) zu einer variablen Fortbewegungsgeschwindigkeit führen kann. Hier kann man alternativ eine Zeitmessung einbauen und den Zeitabstand zwischen Abfragen des Eingabezustands in die Berechnung der Verschiebung einfließen lassen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Drehung der Kamera hängt von der Mausbewegung ab. Hier wird die Funktion <code>resetMouseDelta()</code> aufgerufen, welche zwei Funktionen hat:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>die Bewegung der Maus seit dem Druck auf die rechte Maustaste bzw. seit letztem Aufruf von <code>resetMouseDelta()</code> wird zurückgeliefert, und</p>
</li>
<li>
<p><code>mouseDownPos</code> wird auf die aktuelle Maus-Cursorposition gesetzt (sodass beim nächsten Aufruf</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bei der Bewegung erfolgt die Neigung der Kamera um die x-Achse des lokalen Kamerakoordinatensystems (wird zurückgeliefert durch die Funktion <code>m_camera.right()</code>. Analog könnte man die Kamera auch um die lokale y-Achse der Kamera schwenken (wie in einem Flugsimulator üblich), dies führt aber zu recht beliebigen Ausrichtungen. Möchte man die Kamera eher parallel zum "Fußboden" halten, dann dreht man die Kamera um die y-Achse des Weltenkoordinatensystems (Vektor 0,1,0).</p>
</div>
<div class="paragraph">
<p>Am Ende des Tastaturabfrageteils werden noch die "wurde gedrückt"-Zustände zurückgesetzt.</p>
</div>
<div class="paragraph">
<p>Das Scrollrad soll in diesem Beispiel ein deutlich schnelleres Vorwärts- oder Rückwärtsbewegen durch die Szene ermöglichen. Deshalb werden die Mausradbewegungen mit größerer Verschiebegeschwindigkeit skaliert. Wie auch bei der Abfrage der Mausbewegung wird in der Funktion <code>resetWheelDelta()</code> der aktuell akkumulierte Scrollweg zurückgeliefert und intern im Zustandsmanager wieder auf 0 gesetzt.</p>
</div>
</div>
<div class="sect3">
<h4 id="_auf_gedrückte_tasten_reagieren">5.4.4. Auf gedrückte Tasten reagieren</h4>
<div class="paragraph">
<p>Wie oben erläutert wird das Neuzeichnen nur bei Registrieren eines Tastendrucks angefordert. Nehmen wir mal an, die rechte Maustaste ist gedrückt und die Vorwärtstaste W wird gedrückt gehalten. Dann sendet das Betriebssystem (bzw. Window-Manager) in regelmäßigen Abständen KeyPress-Events (z.B. 50 je Sekunde, je nach Einstellung). Diese sind dann als <code>AutoRepeat</code> gekennzeichnet und führen damit nicht zu einer Änderung im Eingabe-Zustandsmanager, aber zu einer erneuten Prüfung der Neuzeichnung (Aufruf von <code>checkInput()</code>). Und da eine Kamera-relevante Taste gedrückt gehalten ist, wird ein Neuzeichnen via <code>renderLater()</code> angefordert. Als Konsequenz ruckelt das Bild dann im Rythmus der Tastenwiederholrate&#8230;&#8203; nicht sehr angenehm anzusehen.</p>
</div>
<div class="paragraph">
<p>Daher muss das Prüfen auf gedrückte Tasten regelmäßig, d.h. einmal pro Frame erfolgen. Und der geeignete Ort dafür ist das Ende der <code>paintGL()</code>-Funktion:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code>void SceneView::paintGL() {
    ...

	checkInput();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ganz zum Schluss wird nochmal auf eine Tasteneingabe geprüft und damit bei Bedarf ein <code>UpdateRequest</code> eingereiht.</p>
</div>
<div class="paragraph">
<p>Damit wäre die Tastatur- und Mauseingabe auch schon komplett.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_shaderprogramme_2">5.5. Shaderprogramme</h3>
<div class="paragraph">
<p>Die Verwaltung der Shaderprogramme macht Qt ja eigentlich schon durch die Klasse <code>QOpenGLShaderProgram</code>. Wenn man eine weitere Wrapper-Klasse außen herum packt, dann wird der Quelltext noch deutlich übersichtlicher. In der Deklaration der Wrapper-Klasse <code>ShaderProgram</code> findet man die gekapselte Qt Klasse wieder:</p>
</div>
<div class="listingblock">
<div class="title">ShaderProgram.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ShaderProgram</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">ShaderProgram</span><span class="p">();</span>
	<span class="n">ShaderProgram</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">vertexShaderFilePath</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">fragmentShaderFilePath</span><span class="p">);</span>

	<span class="kt">void</span> <span class="n">create</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">destroy</span><span class="p">();</span>

	<span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgram</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_program</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// paths to shader programs, used in create()</span>
	<span class="n">QString</span>		<span class="n">m_vertexShaderFilePath</span><span class="p">;</span>
	<span class="n">QString</span>		<span class="n">m_fragmentShaderFilePath</span><span class="p">;</span>

	<span class="n">QStringList</span>	<span class="n">m_uniformNames</span><span class="p">;</span> <span class="c1">// uniform (variable) names</span>
	<span class="n">QList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>	<span class="n">m_uniformIDs</span><span class="p">;</span>   <span class="c1">// uniform IDs (resolved in create())</span>

<span class="nl">private:</span>
	<span class="n">QOpenGLShaderProgram</span>	<span class="o">*</span><span class="n">m_program</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zur Verwaltung von Shaderprogrammen gehören auch die Variablen, die man dem Vertex- und/oder Fragment-Shaderprogramm übergeben möchte (siehe Shaderprogramme in Abschnitt "Zeichenobjekte"). Die Verwendung der Klasse sieht vor, dass man erst alle Eigenschaften setzt (Resourcen-Pfade zu den Shaderprogrammen, und die uniform-Namen im Vektor <code>m_uniformNames</code>). Dies wird im Konstruktor der <code>SceneView</code>-Klasse gemacht:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:SceneView()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SceneView</span><span class="o">::</span><span class="n">SceneView</span><span class="p">()</span> <span class="o">:</span>
	<span class="n">m_inputEventReceived</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

	<span class="c1">// Shaderprogram #0 : regular geometry (painting triangles via element index)</span>
	<span class="n">ShaderProgram</span> <span class="n">blocks</span><span class="p">(</span><span class="s">":/shaders/withWorldAndCamera.vert"</span><span class="p">,</span><span class="s">":/shaders/simple.frag"</span><span class="p">);</span>
	<span class="n">blocks</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"worldToView"</span><span class="p">);</span>
	<span class="n">m_shaderPrograms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">blocks</span> <span class="p">);</span>

	<span class="c1">// Shaderprogram #1 : grid (painting grid lines)</span>
	<span class="n">ShaderProgram</span> <span class="n">grid</span><span class="p">(</span><span class="s">":/shaders/grid.vert"</span><span class="p">,</span><span class="s">":/shaders/grid.frag"</span><span class="p">);</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"worldToView"</span><span class="p">);</span> <span class="c1">// mat4</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"gridColor"</span><span class="p">);</span> <span class="c1">// vec3</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"backColor"</span><span class="p">);</span> <span class="c1">// vec3</span>
	<span class="n">m_shaderPrograms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">grid</span> <span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Konfiguration aller Shaderprogramme kann vor der eigentlichen OpenGL-Initialisierung erfolgen. Diese erfolgt für jedes Shaderprogramm beim Aufruf der Funktion <code>ShaderProgram::create()</code>. Die macht dann die eigentliche Initialisierung, die in den vorangegangenen Tutorials in der <code>initializeGL()</code> Funktion gemacht wurde:</p>
</div>
<div class="listingblock">
<div class="title">ShaderProgram.cpp:create()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">ShaderProgram</span><span class="o">::</span><span class="n">create</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">m_program</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">);</span>

	<span class="n">m_program</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLShaderProgram</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">m_vertexShaderFilePath</span><span class="p">))</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Vertex shader errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Fragment</span><span class="p">,</span> <span class="n">m_fragmentShaderFilePath</span><span class="p">))</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Fragment shader errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">())</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Shader linker errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

	<span class="n">m_uniformIDs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">uniformName</span> <span class="o">:</span> <span class="n">m_uniformNames</span><span class="p">)</span>
		<span class="n">m_uniformIDs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">uniformLocation</span><span class="p">(</span><span class="n">uniformName</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dank der netten Hilfsfunktionen <code>QOpenGLShaderProgram::addShaderFromSourceFile()</code> und <code>QOpenGLShaderProgram::uniformLocation()</code> ist das auch recht übersichtlich. Die Fehlerbehandlung könnte noch besser sein, aber das kann man ja schnell nachrüsten.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beim Aufruf von <code>QOpenGLShaderProgram::addShaderFromSourceFile()</code> ist das erste Argument zu beachten, welches den Typ des Shaderprogramms festlegt!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Funktion <code>uniformLocation()</code> sucht in beiden Shaderprogrammen nach <code>uniform</code> Deklarationen, also Variablen, die unabhängig von Vertex oder Fragment dem Shaderprogramm zur Verfügung stehen. Diese werden beim compilieren und linken durchnummeriert und den zu einem uniform-Variablennamen passenden Index kann man mit <code>uniformLocation()</code> ermitteln.</p>
</div>
<div class="paragraph">
<p>Bei der Verwendung des Shaders kann man dann mit <a href="https://doc.qt.io/qt-5/qopenglshaderprogram.html#setUniformValue">setUniformValue()</a> den entsprechenden Wert setzen (siehe auch Shaderprogramm-Beispiele im Abschnitt "Zeichenobjekte").</p>
</div>
<div class="paragraph">
<p>Die Shaderprogramme wissen selbst nicht, für welche Objekte sie zum Zeichnen gebraucht werden. Auch werden die Variablen (uniforms), die sie zur Funktion benötigen, meist woanders gespeichert. Daher gibt es in der Klasse nicht mehr zu tun.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transformationsmatrizen_und_kamera">5.6. Transformationsmatrizen und Kamera</h3>
<div class="sect3">
<h4 id="_transformationen">5.6.1. Transformationen</h4>
<div class="paragraph">
<p>Das Thema <em>Transformationsmatrizen</em> ist in den in der Einleitung zitierten Webtutorials/Anleitungen ausreichend beschrieben. Die Format zur Transformation eines Punktes/Vektors <code>pModel</code> in den Modellkoordinaten zu den View-Koordinaten <code>pView</code> benötigt 3 Transformationsmatrizen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pView = M_projection * M_World2Camera * M_Model2World * pModel</pre>
</div>
</div>
<div class="paragraph">
<p>Dies entspricht den Schritten:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Transformation des Punktes von Modellkoordinaten in das Weltenkoordinatensystem. Dies ist bei bewegten/animierten Objekten sinnvoll, d.h. eine Objekteigenschaft. Manchmal möchte man auch die gesamte Welt transformieren, auch dafür nimmt man die Model-zu-Welt-Transformationsmatrix.</p>
</li>
<li>
<p>Transformation von Welt- zu Beobachterkoordinatensystem (Kamera). Ist eigentlich das Gleiche, jedoch ist die Kamera, deren Ausrichtung und Position modellunabhängig.</p>
</li>
<li>
<p>Projektionstransformation (othogonal, perspektivisch, &#8230;&#8203;), kann z.B. durch near/far-plane und Angle-of-View definiert werden.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Da die Objekte in Modell bzw. Weltkoordinaten definiert und verwaltet werden, sollte besser OpenGL die Transformationen durchführen (dafür ist es ja gemacht). Je nach Anzahl der zu transformierenden Objekte kann nun den objektspezifischen ersten Transformationsschritt in das Weltenkoordinatensystem auf der CPU durchführen (idealerweise parallelisiert). Die Transformation von Weltkoordinaten in die projezierte Darstellung macht dann OpenGL. Da diese Matrix für <em>alle</em> Objekte gleich ist, kann man diese auch bequem den Shaderprogrammen übergeben. D.h. die Matrix:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>M_World2View = M_Projection * M_World2Camera * M_Model2World</pre>
</div>
</div>
<div class="paragraph">
<p>wird als uniform-Variable an die Shaderprogramme übergeben. Die Transformieren dann damit hocheffizient auf der Grafikkarte alle Vertex-Koordinaten.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aktualisierung_der_world2view_matrix">5.6.2. Aktualisierung der World2View Matrix</h4>
<div class="paragraph">
<p>Die Projektionsmatrix ändert sich bei jeder Viewport-Änderung, da sich damit zumeist das Breite/Höhe-Verhältnis ändert. Sonst ändert sich diese Matrix eigentlich nie, außer vielleicht in den Benutzereinstellungen (wenn z.B. Linseneigenschaften wie Öffnungswinkel oder Zoom verändert werden).</p>
</div>
<div class="paragraph">
<p>Die Model2World-Matrix bleibt wie oben geschrieben außen vor, da objektabhängig.</p>
</div>
<div class="paragraph">
<p>Die Kameramatrix (World2Camera) ändert sich jedoch ständig während der Navigation durch die Szene. Da die Navigation am Anfang der Neuzeichenroutine ausgewertet wird, erfolgt die Neuberechnung der Matrix (falls notwendig) auch direkt vorm Neuzeichnen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es ist denkbar, dass ein MouseMove-Event mehrfach während eines Frames ausgelöst wird. Wenn man nun die Neuberechnung der Matrix daran koppelt, führt das mitunter zu unnützer Rechenarbeit. Daher ist es sinnvoller, die Berechnung erst zu Beginn des Zeichenzyklus durchzuführen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die eigentliche Berechnung erfolgt in der Funktion <code>updateWorld2ViewMatrix</code>. Dank der Funktionalität der Matrixklasse <code>QMatrix4x4</code> eine sehr kompakte Funktion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">updateWorld2ViewMatrix</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// transformation steps:</span>
	<span class="c1">//   model space -&gt; transform -&gt; world space</span>
	<span class="c1">//   world space -&gt; camera/eye -&gt; camera view</span>
	<span class="c1">//   camera view -&gt; projection -&gt; normalized device coordinates (NDC)</span>
	<span class="n">m_worldToView</span> <span class="o">=</span> <span class="n">m_projection</span> <span class="o">*</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">toMatrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">m_transform</span><span class="p">.</span><span class="n">toMatrix</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Multiplikation mit der Modell-Transformationsmatrix (<code>m_transform</code>) ist eigentlich nicht zwingend notwendig, dient aber der Demonstration der Animationsfähigkeit (konstantes Rotieren der Welt um die y-Achse). Dazu den <code>#if 0</code> Block in <code>paintGL()</code> nach <code>#if 1</code> ändern.</p>
</div>
<div class="paragraph">
<p>Die ganze Arbeit der Konfiguration und Erstellung der Translations, Rotations, und Skalierungsmatrizen macht die Klasse <code>Transform3D</code>. In der Funktion <code>toMatrix()</code> werden diese einzelnen Matrizen zur Gesamtmatrix kombiniert (implementiert mit Lazy-Evaluation):</p>
</div>
<div class="listingblock">
<div class="title">Transform3D.cpp:toMatrix()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">const</span> <span class="n">QMatrix4x4</span> <span class="o">&amp;</span><span class="n">Transform3D</span><span class="o">::</span><span class="n">toMatrix</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">m_world</span><span class="p">.</span><span class="n">setToIdentity</span><span class="p">();</span>
		<span class="n">m_world</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">m_translation</span><span class="p">);</span>
		<span class="n">m_world</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">m_rotation</span><span class="p">);</span>
		<span class="n">m_world</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">m_scale</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">m_world</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Kamera-Klasse ist davon abgeleitet und beinhaltet letztlich nur die inverse Transformation vom Welten- zum Beobachterkoordinatensystem (siehe auch <a href="https://www.trentreed.net/blog/qt5-opengl-part-3b-camera-control" class="bare">https://www.trentreed.net/blog/qt5-opengl-part-3b-camera-control</a>). Im Prinzip hilft es sich vorzustellen, dass die Kamera ein positioniertes und ausgerichtetes Objekt selbst ist. Nun wollen wir dieses Kamera-Objekt nicht mittels einer Model2World-Transformationsmatrix in das Weltenkoordinatensystem hieven, sondern uns eher aus der Weltsicht in die lokale Sicht des Kamera-Objekts bewegen. Dies bedeuted, wir müssen alle Weltkoordinaten mittels der Inversen der Kamera-Objekt-Model2World-Matrix multiplizieren. Das macht dann die entsprechend spezialisiert <code>toMatrix()</code>-Funktion:</p>
</div>
<div class="listingblock">
<div class="title">Camera.h:toMatrix()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">const</span> <span class="n">QMatrix4x4</span> <span class="o">&amp;</span> <span class="n">toMatrix</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">m_world</span><span class="p">.</span><span class="n">setToIdentity</span><span class="p">();</span>
		<span class="n">m_world</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">m_rotation</span><span class="p">.</span><span class="n">conjugated</span><span class="p">());</span>
		<span class="n">m_world</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">m_translation</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">m_world</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Daneben bietet die Kameraklasse noch 3 interessante Abfragefunktionen, welche die Koordinatenrichtungen des lokalen Kamera-Koordinatensystems im Weltenkoordinatensystem zurückliefern:</p>
</div>
<div class="listingblock">
<div class="title">Camera.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// negative Kamera-z-Achse</span>
<span class="n">QVector3D</span> <span class="nf">forward</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">QVector3D</span> <span class="n">LocalForward</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">m_rotation</span><span class="p">.</span><span class="n">rotatedVector</span><span class="p">(</span><span class="n">LocalForward</span><span class="p">);</span>
<span class="err">}</span>

<span class="c1">// Kamera-y-Achse</span>
<span class="n">QVector3D</span> <span class="nf">up</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">QVector3D</span> <span class="n">LocalUp</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">m_rotation</span><span class="p">.</span><span class="n">rotatedVector</span><span class="p">(</span><span class="n">LocalUp</span><span class="p">);</span>
<span class="err">}</span>

<span class="c1">// Kamera-x-Achse</span>
<span class="n">QVector3D</span> <span class="nf">right</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">QVector3D</span> <span class="n">LocalRight</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">m_rotation</span><span class="p">.</span><span class="n">rotatedVector</span><span class="p">(</span><span class="n">LocalRight</span><span class="p">);</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die eigentliche Arbeit macht hier die Klasse <code>QQuaternion</code>, welche man dankenswerterweise nicht selbst implementieren muss.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_zeichenobjekte">5.7. Zeichenobjekte</h3>
<div class="paragraph">
<p>In diesem Abschnitt geht es um die Verwaltung von Zeichenobjekten. Dies ist nicht wirklich ein Qt-Thema, da diese Art von Datenmanagement in der einen oder anderen Art in jeder OpenGL-Anwendung zu finden ist. Wen also nur die Qt-spezifischen Dinge interessieren, kann dieses Kapitel gerne überspringen.</p>
</div>
<div class="sect3">
<h4 id="_effizientes_zeichnen_großer_geometrien">5.7.1. Effizientes Zeichnen großer Geometrien</h4>
<div class="paragraph">
<p>Es gibt eine wesentliche Grundregel in OpenGL:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man effizient große Geometrien zeichnen möchte, dann muss man die Anzahl der <code>glDrawXXX</code> Aufrufe so klein wie möglich halten.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ein Beispiel: wenn man <strong>2</strong> Würfel zeichen möchte, hat man folgende Möglichkeiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>alle 12 Seiten einzeln Zeichen (12 <code>glDrawXXX</code> Aufrufe), z.B. als:</p>
<div class="ulist">
<ul>
<li>
<p><code>GL_TRIANGLES</code> (6 Vertices je Seite)</p>
</li>
<li>
<p><code>GL_TRIANGLE_STRIP</code> (4 Vertices je Seite)</p>
</li>
<li>
<p><code>GL_QUADS</code> (4 Vertices je Seite)</p>
</li>
</ul>
</div>
</li>
<li>
<p>jeden Würfel einzeln zeichnen (2 <code>glDrawXXX</code> Aufrufe), dabei alle Seiten des Würfels zusammen zeichnen via:</p>
<div class="ulist">
<ul>
<li>
<p><code>GL_TRIANGLES</code> (8 Vertices, 6*6 Elementindices)</p>
</li>
<li>
<p><code>GL_QUADS</code> (8 Vertices, 6*4 Elementindices)</p>
</li>
</ul>
</div>
</li>
<li>
<p>beide Würfel zusammen zeichnen (1 <code>glDrawXXX</code> Aufruf), dabei alle Seiten beider Würfels zusammen zeichnen via:</p>
<div class="ulist">
<ul>
<li>
<p><code>GL_TRIANGLES</code> (2*8 Vertices, 2*6*6 Elementindices)</p>
</li>
<li>
<p><code>GL_QUADS</code> (2*8 Vertices, 2*6*4 Elementindices)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die oben angegebene Anzahl der Vertexes gilt natürlich nur für einfarbige Würfel. Sollen die Seitenflächen unterschiedlich gefärbt sein, braucht man natürlich für jede Seite 4 Vertices, also bspw. bei <code>GL_TRIANGLES</code> brauch man für die 2 Würfel 2*6*4 Vertices.</p>
</div>
<div class="paragraph">
<p>Wenn man Objekte mit gemischten Flächenprimitiven hat (also z.B. Dreiecke und Rechtecke, oder Polygone), dann kann man entweder nach Flächentyp zusammenfassen und je Flächentyp ein <code>glDrawXXX</code> Aufruf ausführen, oder eben alles als Dreiecke behandeln und nur einen Zeichenaufruf verwenden. Kann man mal durch Profiling ausprobieren, was dann schneller ist. Der Speicherverbrauch spielt auch eine Rolle, da der Datentransfer zwischen CPU und GPU immer auch an der Geschwindigkeit der Speicheranbindung hängt.</p>
</div>
<div class="paragraph">
<p>Die Gruppierung von Zeichenelementen erfolgt im Prinzip nach folgenden Kriterien:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Vertexdaten bei interleaved Storage (z.B. nur Koordinaten wie beim Gitter unten, Koordinaten-und-Farben, Koordinaten-Normalen-Texturcoords-Farben)</p>
</li>
<li>
<p>Geometrietyp (siehe oben)</p>
</li>
<li>
<p>Objektveränderlichkeit</p>
</li>
<li>
<p>Transparenz (dazu in einem späteren Tutorial mehr)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Das Ganze hängt also stark von der Anwendung ab. Im <em>Tutorial 05</em> gibt es zwei Arten von Objekten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>das Gitter, bestehend aus Linien und ausschließlich Koordinaten, gezeichnet via <code>GL_LINES</code></p>
</li>
<li>
<p>die Boxen, mit <code>GL_TRIANGLES</code> gezeichnet.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_verwaltung_von_zeichenobjekten">5.7.2. Verwaltung von Zeichenobjekten</h4>
<div class="paragraph">
<p>Eine Möglichkeit, die für das Zeichnen derart gruppierter Daten benötigten Objekte, d.h. VertexArrayObject (VAO), VertexBufferObject (VBO) und ElementBufferObject (EBO), zu verwalten, ist eigene Datenhalteklassen zu verwenden. Diese sehen allgemein so aus:</p>
</div>
<div class="listingblock">
<div class="title">Deklaration einer Zeichenobjektklasse</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">DrawObject</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">DrawObject</span><span class="p">();</span>

    <span class="c1">// create native OpenGL objects</span>
    <span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">);</span>
    <span class="c1">// release native OpenGL objects</span>
	<span class="kt">void</span> <span class="n">destroy</span><span class="p">();</span>

    <span class="c1">// actual render objects</span>
	<span class="kt">void</span> <span class="n">render</span><span class="p">();</span>

    <span class="c1">// Data members to store state</span>
    <span class="p">....</span>

    <span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vbo</span><span class="p">;</span> <span class="c1">// Vertex buffer</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_ebo</span><span class="p">;</span> <span class="c1">// Element/index buffer</span>

	<span class="c1">// other buffer objects</span>

	<span class="p">....</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die drei wichtigen Lebenszyklusphasen der Objekte sind durch die Funktionen <code>create()</code>, <code>destroy()</code> und <code>render()</code> abgebildet.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Speichermanagement bei OpenGL Objekten sollte explizit erfolgen, und nicht im Destruktor der Zeichenobjekt-Klassen. Es ist beim Aufräumen im Destruktor durch die automatisiert generierte Aufrufreihenfolge der einzelnen Destruktoren schwierig sicherzustellen, dass der dazugehörige OpenGL-Kontext aktiv ist. Daher empfiehlt es sich, stets eine explizite <code>destroy()</code> Funktion zu verwenden.</p>
</div>
<div class="paragraph">
<p>Außerdem werden die Zeichenobjekte so kopierbar und können, unter anderem, in <code>std::vector</code> oder ähnlichen Container verwendet werden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Am Besten wird das Datenmanagement in einer Beispielimplementierung sichtbar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_zeichenobjekt_1_gitterraster_in_x_z_ebene">5.7.3. Zeichenobjekt #1: Gitterraster in X-Z Ebene</h4>
<div class="paragraph">
<p>Beginnen wir mit einem einfachen Beispiel: Ein Gitterraster soll auf dem Bildschirm gezeichnet werden, sozusagen als "Boden". Es werden also Linien in der X-Z-Ebene (y=0) gezeichnet, wofür der Elementtyp <code>GL_LINES</code> zum Zeichnen verwendet wird.</p>
</div>
<div class="paragraph">
<p>Für jede Linie sind Start- und Endkoordinaten anzugeben, wobei die y-Koordinate eingespart werden kann.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man muss nicht immer alle Koordinaten (x,y,z) an den Vertexshader übergeben, wenn es nicht notwendig ist.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Wir stellen also den Vertexpuffer mit folgendem Schema zusammen:</p>
</div>
<div class="paragraph">
<p><code>x1sz1sx1ez1ex2sz2sx2ez2e...</code> also jeweils x und z Koordinatentuple für je Start- (s) und Endpunkt (e) einer Linie nacheinander.</p>
</div>
<div class="paragraph">
<p>Diese Geometrieinformation wird in der Klasse <code>GridObject</code> zusammengestellt:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.h, Klassendeklaration</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">GridObject</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">destroy</span><span class="p">();</span>

	<span class="kt">void</span> <span class="n">render</span><span class="p">();</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>				<span class="n">m_bufferSize</span><span class="p">;</span>
	<span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vbo</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Implementierung der <code>create()</code> Funktion ist das eigentlich Interessante:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.cpp:create()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">GridObject</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// number of lines to draw in x and z direction</span>
	<span class="c1">// width is in "space units", whatever that means for you (meters, km, nanometers...)</span>
	<span class="kt">float</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="c1">// grid is centered around origin, and expands to width/2 in -x, +x, -z and +z direction</span>

	<span class="c1">// create a temporary buffer that will contain the x-z coordinates of all grid lines</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span>			<span class="n">gridVertexBufferData</span><span class="p">;</span>
	<span class="c1">// we have 2*N lines, each line requires two vertexes, with two floats (x and z coordinates) each.</span>
	<span class="n">m_bufferSize</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">gridVertexBufferData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m_bufferSize</span><span class="p">);</span>
	<span class="kt">float</span> <span class="o">*</span> <span class="n">gridVertexBufferPtr</span> <span class="o">=</span> <span class="n">gridVertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="c1">// compute grid lines with z = const</span>
	<span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">gridVertexBufferPtr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// compute grid lines with x = const</span>
	<span class="kt">float</span> <span class="n">z1</span> <span class="o">=</span> <span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">gridVertexBufferPtr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z1</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2</span><span class="p">;</span>
	<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im ersten Teil wird ein linearer Speicherbereich (bereitgestellt in einem <code>std::vector</code>) mit den Liniendaten gefüllt. Das Raster besteht aus Linien in X und Z Richtung (2), jeweils N Linien, und jede Linie hat einen Start- und einen Endpunkt (2) und jeder Punkt besteht aus 2 Koordinaten. Dies macht 2*N*2*2 floats (=NVertices).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es ist ok an dieser Stelle den Speicherbereich in einem temporären Vektor anzulegen, da beim Erzeugen des OpenGL-Vertexpuffers die Daten kopiert werden und der Vektor danach nicht mehr benötigt wird. Dies ist im Falle von veränderlichen Daten (siehe BoxObjekte unten) anders.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Im zweiten Teil der Funktion werden dann wie gehabt die OpenGL-Pufferobjekte erstellt:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.cpp:create(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="c1">// Create Vertex Array Object</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>		<span class="c1">// create Vertex Array Object</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>		<span class="c1">// and bind it</span>

	<span class="c1">// Create Vertex Buffer Object</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">vertexMemSize</span> <span class="o">=</span> <span class="n">m_bufferSize</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">gridVertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vertexMemSize</span><span class="p">);</span>

	<span class="c1">// layout(location = 0) = vec2 position</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// array with index/id 0</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span>
								  <span class="mi">0</span> <span class="cm">/* position/vertex offset */</span><span class="p">,</span>
								  <span class="mi">2</span> <span class="cm">/* two floats per position = vec2 */</span><span class="p">,</span>
								  <span class="mi">0</span> <span class="cm">/* vertex after vertex, no interleaving */</span><span class="p">);</span>

	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Aufrufe von <code>shaderProgramm-&gt;enableAttributeArray</code> und <code>shaderProgramm-&gt;setAttributeBuffer</code> definieren, wie der Vertexshader auf diesen Speicherbereich zugreifen soll. Deshalb muss die Funktion <code>create()</code> auch das dazugehörige Shaderprogramm als Funktionsargument erhalten.</p>
</div>
<div class="paragraph">
<p>Nachdem nun die Puffer erstellt und konfiguriert wurden, ist der Rest der Klassenimplementierung recht übersichtlich:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.cpp:destroy() und render()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">GridObject</span><span class="o">::</span><span class="n">destroy</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">GridObject</span><span class="o">::</span><span class="n">render</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// draw the grid lines, m_bufferSize = number of floats in buffer</span>
	<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_LINES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m_bufferSize</span><span class="p">);</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>destroy()</code> ist sicher selbsterklärend. Und die Render-Funktion ebenso.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beachte, dass die Funktion <code>glDrawArrays()</code> als drittes Argument die Länge des Puffers als Anzahl der Elemente vom Typ des Puffers (hier GL_FLOAT) erwartet, und <em>nicht</em> die Länge in Bytes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Funktion <code>render()</code> wird direkt aus <code>SceneView::paintGL()</code> aufgerufen. Hier ist der entsprechende Abschnitt aus der Funktion:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>

	<span class="c1">// set the background color = clear color</span>
	<span class="n">QVector3D</span> <span class="n">backColor</span><span class="p">(</span><span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.15</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.3</span><span class="n">f</span><span class="p">);</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.15</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.3</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>

	<span class="n">QVector3D</span> <span class="n">gridColor</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.7</span><span class="n">f</span><span class="p">);</span>

    <span class="p">...</span>

	<span class="c1">// *** render grid ***</span>

	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_worldToView</span><span class="p">);</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gridColor</span><span class="p">);</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">backColor</span><span class="p">);</span>
	<span class="n">m_gridObject</span><span class="p">.</span><span class="n">render</span><span class="p">();</span> <span class="c1">// render the grid</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

    <span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier sieht man auch, wie die Variablen an die Shaderprogramme übergeben werden. In Abschnitt "Shaderprogramme" oben wurde ja gezeigt, wie die IDs der <code>uniform</code> Variablen ermittelt werden. Nun müssen diese Variablen <em>vor jeder Verwendung</em> des Shaderprogramms gesetzt werden. Dies erfolgt direkt vor dem Aufruf der <code>GridObject::render()</code> Funktion.</p>
</div>
<div class="paragraph">
<p>Das Ergebnis dieses Zeichnens (mit uniformer Gitterfarbe) ist zunächst ganz nett:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_gridplain.png" alt="Raster">
</div>
<div class="title">Figure 6. Einfaches Gitterraster (einfarbig) mit sichtbarer endlicher Ausdehnung</div>
</div>
<div class="paragraph">
<p>Aber schöne wäre es, wenn das Gitter mit zunehmender Tiefe verblasst.</p>
</div>
<div class="sect4">
<h5 id="_gitter_mit_abblendung_in_der_tiefe">Gitter mit Abblendung in der Tiefe</h5>
<div class="paragraph">
<p>Das Gitter sollte sich nun in weiter Ferne der Hintergrundfarbe annähern. Man könnte das zum Beispiel erreichen, wenn man die Farbe des Gitters an weiter entfernten Punkte einfärbt.</p>
</div>
<div class="paragraph">
<p>Den Vertexshader könnte man wie folgt erweitern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330
</span>
<span class="c1">// GLSL version 3.3</span>
<span class="c1">// vertex shader</span>

<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">position</span><span class="p">;</span> <span class="c1">// input:  attribute with index '0'</span>
                                       <span class="c1">//         with 2 floats (x, z coords) per vertex</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>                    <span class="c1">// output: computed vertex color for shader</span>

<span class="k">const</span> <span class="kt">float</span> <span class="n">FARPLANE</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>             <span class="c1">// threshold</span>
<span class="kt">float</span> <span class="n">fragDepth</span><span class="p">;</span>                       <span class="c1">// normalized depth value</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">worldToView</span><span class="p">;</span>              <span class="c1">// parameter: the view transformation matrix</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gridColor</span><span class="p">;</span>                <span class="c1">// parameter: grid color as rgb triple</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">backColor</span><span class="p">;</span>                <span class="c1">// parameter: background color as rgb triple</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">worldToView</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fragDepth</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gl_Position</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">FARPLANE</span><span class="p">));</span>
  <span class="n">fragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">mix</span><span class="p">(</span><span class="n">gridColor</span><span class="p">,</span> <span class="n">backColor</span><span class="p">,</span> <span class="n">fragDepth</span><span class="p">),</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt 3 Parameter, die dem Shaderprogramm gegeben werden müssen (das passiert in  <code>SceneView::paintGL()</code>, siehe Quelltextausschnitt oben):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>worldToView</code> - Transformationsmatrix (von Weltkoordinaten zur perspektivischen Ansicht)</p>
</li>
<li>
<p><code>gridColor</code> - Farbe des Gitters</p>
</li>
<li>
<p><code>backColor</code> - Hintergrundfarbe</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Variable <code>gl_Position</code> enthält nach der Transformation die normalisierten Koordinaten. In der Berechnung wird die zweite Komponente des Vertex-Vektors (angesprochen über <code>.y</code>) als z-Koordinate verwendet.</p>
</div>
<div class="paragraph">
<p>Für die Abblendefunktionalität ist die Entfernung des Linienstart- bzw. -endpunktes  interessant. Nun sind die z-Koordinaten dieser normalisierten Position alle sehr dicht an 1 dran. Deshalb werden sie noch skaliert (entsprechend der perspektivischen Transformationsregeln etwas wie eine Farplane). Nun kann man diese Tiefe, gespeichert in der Variable <code>fragDepth</code> nutzen, um zwischen Gitterfarbe und Hintergrundfarbe linear mit der GLSL-Funktion <code>mix()</code> zu interpolieren.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_grid_vertexshaderfade.png" alt="Gitter" width="Vertexshaderfade">
</div>
<div class="title">Figure 7. Gitterraster mit Vertex-basierter Abblendung</div>
</div>
<div class="paragraph">
<p>Das Ergebnis geht schon in die richtige Richtung, aber es gibt einen unschönen Effekt, wenn man parallel zu den Linien schaut. Die Koordinaten der Endpunkte der seitlich laufenden Linien sind sehr weit weg (in der perspektivischen Projekten), sodass beide Linienenden nahezu Hintergrundfarbe bekommen. Und da die Fragmentfarbe eine lineare Interpolation zwischen den Vertexfarben ist, verschwindet die gesamte Linie.</p>
</div>
<div class="paragraph">
<p>Das Problem lässt sich nur beheben, wenn man die Ablendfunktionalität in den Fragment-Shader steckt.</p>
</div>
<div class="paragraph">
<p>Der Vertex-Shader wird dadurch total einfach:</p>
</div>
<div class="listingblock">
<div class="title">grid.vert (Vertexshader)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330
</span>
<span class="c1">// GLSL version 3.3</span>
<span class="c1">// vertex shader</span>

<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">position</span><span class="p">;</span> <span class="c1">// input:  attribute with index '0'</span>
                                       <span class="c1">//         with 2 floats (x, z coords) per vertex</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">worldToView</span><span class="p">;</span>              <span class="c1">// parameter: world to view transformation matrix</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">worldToView</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Letztlich werden nur noch die Vertex-Koordinaten transformiert und an den Fragment-Shader weitergereicht. Der sieht dann so aus:</p>
</div>
<div class="listingblock">
<div class="title">grid.frag (Fragmentshader)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330
</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">fColor</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gridColor</span><span class="p">;</span>                <span class="c1">// parameter: grid color as rgb triple</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">backColor</span><span class="p">;</span>                <span class="c1">// parameter: background color as rgb triple</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">FARPLANE</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>            <span class="c1">// threshold</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">distanceFromCamera</span> <span class="o">=</span> <span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">FARPLANE</span><span class="p">;</span>
  <span class="n">distanceFromCamera</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">distanceFromCamera</span><span class="p">));</span> <span class="c1">// clip to valid value range</span>
  <span class="n">fColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">mix</span><span class="p">(</span><span class="n">gridColor</span><span class="p">,</span> <span class="n">backColor</span><span class="p">,</span> <span class="n">distanceFromCamera</span><span class="p">),</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Variable <code>gl_FragCoord</code> wird für jeden einzelnen Bildpunkt von OpenGL bereitgestellt und enthält die Normalized Device Coordinates (NDC). Wenn man beachtet, dass diese Koordinaten durch Division mit w berechnet werden, dann bekommt man die originale z-Koordinate durch Multiplikation mit w. Das ganze wird dann noch mit einem Begrenzungswert (<code>FARPLANE</code>) skaliert. Falls bei der Definition des View-Frustums andere Werte für Near/Farplane verwendet werden, muss man die Formel entsprechend anpassen (siehe <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing" class="bare">https://learnopengl.com/Advanced-OpenGL/Depth-testing</a> für die dahinterliegende Mathematik).</p>
</div>
<div class="paragraph">
<p>Damit sieht das Ergebnis dann wie gewünscht aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_grid_fragshaderfade.png" alt="Gitter" width="Fragmentshaderfade">
</div>
<div class="title">Figure 8. Gitterraster mit Fragment-basierter Abblendung (Fog/Nebeleffekt)</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_zeichenobjekt_2_viele_viele_boxen">5.7.4. Zeichenobjekt #2: Viele viele Boxen</h4>
<div class="paragraph">
<p>Um die Performance der Grafikkarte (und der Anwendung) zu testen, kann man sehr viele Boxen modellieren und dann mittels eines einzigen <code>glDrawElements()</code>-Aufrufs zeichnen lassen. Bei modernen Grafikkarten sollten locker Millionen von Boxen flüssig gezeichnet werden können.</p>
</div>
<div class="paragraph">
<p>Die Aufgabe besteht nun darin, die Vertexdaten aller Boxen und die dazugehörigen Elementindexe in die zwei Puffer (VBO und EBO) zu stecken, und den Quelltext auch noch einigermaßen verstehen zu können.</p>
</div>
<div class="paragraph">
<p>Zunächst wird wie beim Gitter ein Boxen-Zeichenobjekt erstellt:</p>
</div>
<div class="listingblock">
<div class="title">BoxObject.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">BoxObject</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">BoxObject</span><span class="p">();</span>

    <span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">destroy</span><span class="p">();</span>

	<span class="kt">void</span> <span class="n">render</span><span class="p">();</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BoxMesh</span><span class="o">&gt;</span>		<span class="n">m_boxes</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span>			<span class="n">m_vertexBufferData</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GLuint</span><span class="o">&gt;</span>			<span class="n">m_elementBufferData</span><span class="p">;</span>

    <span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vbo</span><span class="p">;</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_ebo</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sieht erstmal fast genauso aus wie bei der Klasse <code>GridObject</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beide Klassen stellen ja die gleichen Funktionen zur Verfügung. Man könnte also auf die Idee kommen, hinsichtlich Initialisierung und Aufräumen alle Zeichenobjekte gleich zu behandeln. Geht sicher, hängt aber vom Programm ab (und der Datenveränderlichkeit), ob das sinnvoll ist. Beim <em>Tutorial 05</em> wäre das sicher gut gewesen (hab ich mir aber wegen nur zwei Objekten gespart).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Vielleicht noch ein Hinweis zu den Puffern. Neben OpenGL-Pufferobjekten <code>m_vbo</code> und <code>m_ebo</code> sind die ursprünglichen Datenpuffer <code>m_vertexBufferData</code> und <code>m_elementBufferData</code> dauerhaft als Membervariablen vorhanden. Dies ermöglicht eine nachträgliche Aktualisierung eines Teils der Daten (z.B. Farben einer einzelnen Box oder einer Seite), ohne dass neu Speicher reserviert werden muss und die Puffer erneut aufgebaut werden.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Teilweise Aktualisierung von Pufferdaten spielt in diesem Tutorial keine Rolle. Es lohnt sich aber, die Funktion <a href="https://doc.qt.io/qt-5/qopenglbuffer.html#mapRange">QOpenGLBuffer::mapRange</a> anzuschauen (bzw. die darunterliegenden nativen OpenGL-Funktionen <code>glMapBuffer</code> und <code>glMapBufferRange</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die eigentliche Geometrie, d.h. Größe und Position der Boxen wird durch die <code>BoxMesh</code>-Objekte bereitgestellt, welche im Vektor <code>m_boxes</code> vorgehalten werden.</p>
</div>
<div class="paragraph">
<p>Die Implementierung der 3 Funktionen ist dann auch recht ähnlich wie beim <code>GridObject</code>.</p>
</div>
<div class="listingblock">
<div class="title">BoxObject.cpp:destroy() und render()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxObject</span><span class="o">::</span><span class="n">destroy</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_ebo</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">BoxObject</span><span class="o">::</span><span class="n">render</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="n">m_elementBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktionen <code>destroy()</code> und <code>render()</code> sind selbsterklärend (wie schon beim <code>GridObject</code>. Zur Vollständigkeit sei nocheinmal der Aufruf der Zeichenfunktion gezeigt:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>

	<span class="c1">// *** render boxes</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_worldToView</span><span class="p">);</span>
	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">render</span><span class="p">();</span> <span class="c1">// render the boxes</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

    <span class="p">...</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_erstellung_der_opengl_puffer_struct_vertex">Erstellung der OpenGL-Puffer - struct <em>Vertex</em></h5>
<div class="paragraph">
<p>Interessanter ist dann schon die <code>create()</code>-Funktion, in der die Puffer befüllt werden:</p>
</div>
<div class="listingblock">
<div class="title">BoxObject.cpp:create()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxObject</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// create and bind Vertex Array Object</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>

	<span class="c1">// create and bind vertex buffer</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">vertexMemSize</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">);</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vertexMemSize</span><span class="p">);</span>

    <span class="c1">// create and bind element buffer</span>
	<span class="n">m_ebo</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
	<span class="n">m_ebo</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">m_ebo</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">elementMemSize</span> <span class="o">=</span> <span class="n">m_elementBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">GLuint</span><span class="p">);</span>
	<span class="n">m_ebo</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_elementBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">elementMemSize</span><span class="p">);</span>

    <span class="c1">// set shader attributes</span>

	<span class="c1">// index 0 = position</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// array with index/id 0</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">));</span>
	<span class="c1">// index 1 = color</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// array with index/id 1</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">));</span>

	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
	<span class="n">m_ebo</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die <code>create()</code>-Funktion ist inzwischen sicher gut verständlich (ansonsten siehe <em>Tutorial 03</em> und <em>Tutoral 04</em>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>das Vertex Array Objekt wird erstellt,</p>
</li>
<li>
<p>die Pufferobjekte werden erstellt und die Inhalte der bereits initialisierten Puffer (<code>m_vertexBufferData</code> und <code>m_elementBufferData</code> werden in die OpenGL-Puffer kopiert)</p>
</li>
<li>
<p>die Attribute im Shaderprogramm werden gesetzt, d.h. die Zusammensetzung des Puffers</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Hier kommt das erste Mal die Struktur <code>Vertex</code> zum Einsatz. Diese gruppiert alle Attribute eines einzelen Vertex:</p>
</div>
<div class="listingblock">
<div class="title">Vertex.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="n">Vertex</span> <span class="p">{</span>
	<span class="n">Vertex</span><span class="p">()</span> <span class="p">{}</span>
	<span class="n">Vertex</span><span class="p">(</span><span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">coords</span><span class="p">,</span> <span class="k">const</span> <span class="n">QColor</span> <span class="o">&amp;</span> <span class="n">col</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">x</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">x</span><span class="p">())),</span>
		<span class="n">y</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">y</span><span class="p">())),</span>
		<span class="n">z</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">z</span><span class="p">())),</span>
		<span class="n">r</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">redF</span><span class="p">())),</span>
		<span class="n">g</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">greenF</span><span class="p">())),</span>
		<span class="n">b</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">blueF</span><span class="p">()))</span>
	<span class="p">{</span>
	<span class="p">}</span>

	<span class="kt">float</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Klasse enthält derzeit lediglich 6 floats, 3 für die Koordinaten, und 3 für das rgb-Farbtuple.</p>
</div>
<div class="paragraph">
<p>Beim Erstellen eines Puffers im <em>interleaved</em>-Modus werden nun die Vertex-Daten nacheinander in den Puffer kopiert (Details dazu im nächsten Abschnitt).</p>
</div>
<div class="paragraph">
<p>Dem Shaderprogramm muss man nun mitteilen, wo in diesem kontinuierlichen Speicherbereich die einzelen Attribute zu finden sind. Der <code>stride</code>-Parameter ist die Größe eines Vertex-Datemblocks in Bytes, welches <code>sizeof(Vertex)</code> zurückliefert. Das <code>offset</code> Argument (3. Argument in <code>setAttributeBuffer()</code>) ist die Anzahl der Bytes seit Beginn eines Vertexblocks, bei dem das jeweilige Datenelement beginnt. Im Fall des rgb-Farbtuples beginnt dieser Speicherbereich bei dem float <code>r</code>, und das passende Byte-Offset liefert <code>offset(Vertex, r)</code> zurück.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man könnte statt <code>offset(Vertex, r)</code> auch <code>3*sizeof(float)</code> oder <code>12</code> schreiben. <strong>ABER</strong> dann besteht die Gefahr, dass bei komplexeren Strukturen durch implizites Padding ungewollt eine Speicherbereichsverschiebung auftritt und das Shaderprogramm dann auf einen falschen Speicherbereich zugreift (siehe auch <a href="http://www.catb.org/esr/structure-packing" class="bare">http://www.catb.org/esr/structure-packing</a>). Dies ist auch der Grund, warum <code>sizeof(Vertex)</code> statt <code>6*sizeof(float)</code> als stride verwendet wird. Solange nur floats in der Struktur verwendet werden, wird der Compiler (normalerweise) kein Padding einfügen.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_initialisieren_der_vertex_und_elementpuffer_für_die_boxen">Initialisieren der Vertex- und Elementpuffer für die Boxen</h5>
<div class="paragraph">
<p>Die ganze Arbeit der Vertex- und Index-Puffer-Erstellung wird im Konstruktor der Klasse <code>BoxObject</code> und der Hilfsklasse <code>BoxMesh</code> gemacht.</p>
</div>
<div class="listingblock">
<div class="title">BoxObject.cpp:Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">BoxObject</span><span class="o">::</span><span class="n">BoxObject</span><span class="p">()</span> <span class="o">:</span>
	<span class="n">m_vbo</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">VertexBuffer</span><span class="p">),</span> <span class="c1">// actually the default, so default constructor would have been enough</span>
	<span class="n">m_ebo</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">IndexBuffer</span><span class="p">)</span> <span class="c1">// make this an Index Buffer</span>
<span class="p">{</span>

	<span class="c1">// create center box</span>
	<span class="n">BoxMesh</span> <span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">b</span><span class="p">.</span><span class="n">setFaceColors</span><span class="p">({</span><span class="n">Qt</span><span class="o">::</span><span class="n">blue</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">red</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">yellow</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">green</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">magenta</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">darkCyan</span><span class="p">});</span>
	<span class="n">Transform3D</span> <span class="n">trans</span><span class="p">;</span>
	<span class="n">trans</span><span class="p">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">b</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">trans</span><span class="p">.</span><span class="n">toMatrix</span><span class="p">());</span>
	<span class="n">m_boxes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">b</span><span class="p">);</span>

	<span class="k">const</span> <span class="kt">int</span> <span class="n">BoxGenCount</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">GridDim</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c1">// must be an int, or use cast below</span>

	<span class="c1">// initialize grid (block count)</span>
	<span class="kt">int</span> <span class="n">boxPerCells</span><span class="p">[</span><span class="n">GridDim</span><span class="p">][</span><span class="n">GridDim</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">GridDim</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">GridDim</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">boxPerCells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">BoxGenCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// create other boxes in randomize grid, x and z dimensions fixed, height varies discretely</span>
		<span class="c1">// x and z translation in a grid that has 500 units width/depths with 5 m grid line spacing</span>
		<span class="kt">int</span> <span class="n">xGrid</span> <span class="o">=</span> <span class="n">qrand</span><span class="p">()</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">GridDim</span><span class="p">)</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">zGrid</span> <span class="o">=</span> <span class="n">qrand</span><span class="p">()</span><span class="o">*</span><span class="kt">double</span><span class="p">(</span><span class="n">GridDim</span><span class="p">)</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">boxCount</span> <span class="o">=</span> <span class="n">boxPerCells</span><span class="p">[</span><span class="n">xGrid</span><span class="p">][</span><span class="n">zGrid</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="kt">float</span> <span class="n">boxHeight</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">;</span>
		<span class="n">BoxMesh</span> <span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">boxHeight</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
		<span class="n">b</span><span class="p">.</span><span class="n">setFaceColors</span><span class="p">({</span><span class="n">Qt</span><span class="o">::</span><span class="n">blue</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">red</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">yellow</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">green</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">magenta</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">darkCyan</span><span class="p">});</span>
		<span class="n">trans</span><span class="p">.</span><span class="n">setTranslation</span><span class="p">((</span><span class="o">-</span><span class="n">GridDim</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">xGrid</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="n">boxCount</span><span class="o">*</span><span class="mi">5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">boxHeight</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">GridDim</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">zGrid</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">b</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">trans</span><span class="p">.</span><span class="n">toMatrix</span><span class="p">());</span>
		<span class="n">m_boxes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">NBoxes</span> <span class="o">=</span> <span class="n">m_boxes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

	<span class="c1">// resize storage arrays</span>
	<span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">NBoxes</span><span class="o">*</span><span class="n">BoxMesh</span><span class="o">::</span><span class="n">VertexCount</span><span class="p">);</span>
	<span class="n">m_elementBufferData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">NBoxes</span><span class="o">*</span><span class="n">BoxMesh</span><span class="o">::</span><span class="n">IndexCount</span><span class="p">);</span>

	<span class="c1">// update the buffers</span>
	<span class="n">Vertex</span> <span class="o">*</span> <span class="n">vertexBuffer</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">GLuint</span> <span class="o">*</span> <span class="n">elementBuffer</span> <span class="o">=</span> <span class="n">m_elementBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">BoxMesh</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">:</span> <span class="n">m_boxes</span><span class="p">)</span>
		<span class="n">b</span><span class="p">.</span><span class="n">copy2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">vertexCount</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist zunächst die Initialisierung der <code>QOpenGLBuffer</code> Objekte. Als Konstruktorargument wird der Typ des Buffers angegeben (<code>VertexBuffer</code> ist der Standard, aber beim <code>m_ebo</code> Objekt muss man <code>IndexBuffer</code> festlegen).</p>
</div>
<div class="paragraph">
<p>Dann wird zunächst eine Testbox erstellt. Dies beinhaltet die folgenden Schritte:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Erstellung eines <code>BoxMesh</code> Objekts mit den Ausdehnungen 4x2x3 (die Box wird zentriert um das eigene Koordinatensystem erstellt, also x=-2&#8230;&#8203;-2, y=-1&#8230;&#8203;1, z=-1,5&#8230;&#8203;1,5):</p>
<div class="literalblock">
<div class="content">
<pre>BoxMesh b(4,2,3);</pre>
</div>
</div>
</li>
<li>
<p>Festlegen der Seitenfarben:</p>
<div class="literalblock">
<div class="content">
<pre>b.setFaceColors({Qt::blue, Qt::red, Qt::yellow, Qt::green, Qt::magenta, Qt::darkCyan});</pre>
</div>
</div>
</li>
<li>
<p>Verschiebung der Box in das Weltenkoordinatensystem (erst Erstellung der Transformationsmatrix, dann anwenden der Transformation auf die Box):</p>
<div class="literalblock">
<div class="content">
<pre>Transform3D trans;
trans.setTranslation(0,1,0);
b.transform(trans.toMatrix());</pre>
</div>
</div>
</li>
<li>
<p>Zuletzt ablegen der Box im Vektor <code>m_boxes</code>:</p>
<div class="literalblock">
<div class="content">
<pre>m_boxes.push_back( b);</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Die Klasse <code>BoxMesh</code> merkt sich zunächst nur die Koordinaten und Farbzuordnungen.</p>
</div>
<div class="paragraph">
<p>Als nächstes werden noch eine Reihe weiterer Boxen erstellt, und in einem Raster mit Dimension <em>GridDim x GridDim</em> gestapelt. Wenn man mal die eienen Grafikkarte testen will, kann man gerne <code>BoxGenCount</code> auf eine Million erhöhen und/oder das Gitterraster vergrößern (z.B. <code>GridDim=500</code>) um eine etwas größere "Stadt" zu bekommen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bei größeren Rasterdimensionen sieht man auch gut den Effekt des Tiefenclippings, d.h. Objekte hinter der FARPLANE werden nicht mehr gerendert.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nun kommt der eigentlich interessante Teil. Es werden erst Pufferspeicher reserviert. Dabei liefern die Funktionen <code>BoxMesh::VertexCount</code> und <code>BoxMesh::IndexCount</code> die je Meshobjekt benötigte Anzahl von Elementen zurück. Man hätte hier auch gleich die Anzahl eintragen können, aber so bleibt der Code hinreichend universell und kann auf beliebige andere Meshobjekte übertragen werden.</p>
</div>
<div class="paragraph">
<p>Zuletzt kommt das Befüllen der Puffer in traditioneller C-Methodik zum Befüllen kontinuierlicher Speicherbereiche mit Elementen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Vertex</span> <span class="o">*</span> <span class="n">vertexBuffer</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">GLuint</span> <span class="o">*</span> <span class="n">elementBuffer</span> <span class="o">=</span> <span class="n">m_elementBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">BoxMesh</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">:</span> <span class="n">m_boxes</span><span class="p">)</span>
	<span class="n">b</span><span class="p">.</span><span class="n">copy2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">vertexCount</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es werden erst Zeiger auf den Beginn des Pufferspeichers geholt und der Startindex der Vertices auf 0 gesetzt. Dann werden in jedem Schleifendurchlauf die Daten eines BoxMeshes in die Puffer geschrieben und die Zeigervariablen entsprechend vorgerückt. Ebenso wird der Startindex der Vertexes erhöht (<code>vertexCount</code>), sodass bei er nächsten Box neue Vertexnummern vergeben werden.</p>
</div>
<div class="paragraph">
<p>In dieser Art ließen sich ohne weiteres andere Objekttypen verwalten und zusammengefasst in einen Zeichenpuffer kopieren. Die ganze objektspezifische Geometriearbeit passiert im jeweiligen Mesh-Objekt, in diesem Fall in der Klasse <code>BoxMesh</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_die_klasse_boxmesh">Die Klasse BoxMesh</h5>
<div class="paragraph">
<p>Inzwischen sollte die Aufgabe der Klasse <code>BoxMesh</code> klar sein:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>speichern der originalen Geometrie (im lokalen Koordinatensystem)</p>
</li>
<li>
<p>speichern/anwenden der Transformation zum Weltenkoordinatensystem</p>
</li>
<li>
<p>befüllen des linearen Vertexpuffer-Speichers und Elementpuffer-Speichers</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Auch hier gibt es wieder verschiedene Möglichkeiten. Man kann sich, nach dem Prinzip der <em>lazy evaluation</em> erst einmal nur die für die Schritte benötigten Parameter merken, also z.B. Breite, Höhe und Länge der Box, und die Transformationsmatrix. Wenn dann der Vertexpuffer gefüllt werden soll, erstellt man die Vertexkoordinaten, führt die Transformation aus und kopiert dann die resultierenden Koordinaten. Das Verfahren ist sinnvoll, wenn sich die Transformation (also Model-zu-Weltkoordinaten) häufig ändert.</p>
</div>
<div class="paragraph">
<p>Alternativ kann man, wie hier in Tutorial 05, auch die Koordinaten gleich berechnen, d.h. beim Erstellen des Objekt die Vertexkoordinaten im lokalen Koordinatensystem festlegen, und dann bei Ausführen der Transformation sofort an Ort und Stelle transformieren. Dies reduziert die Arbeit beim eigentlichen Befüllen des OpenGL-Vertex-Puffers, führt aber zu witzigen Effekten bei mehrfacher Anwendung der in-place Transformation (wegen der unvermeidlichen Rundungsfehler&#8230;&#8203; einfach mal mehrere 100 Mal im Kreis drehen und sich über die Geometrieveränderung freuen). Da Animation oder Transformation in diesem Tutorial keine Rolle spielt, werden die Boxen gleich zu Beginn ins Weltenkoordinatensystem transformiert.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bevor wir uns der eigentlichen Implementierung widmen, hift vielleicht die eine oder andere Skizze, die Box-Geometrie zu verstehen:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_BoxVertexNumbering.png" alt="Box Vertex Numbering">
</div>
<div class="title">Figure 9. Nummerierung der Knoten (Vertices) der Box</div>
</div>
<div class="paragraph">
<p>Die Nummerierung der Vertexes ist zunächst einmal für die Datenhaltung in der <code>BoxMesh</code>-Klasse notwendig. Es werden nämlich im Konstruktor schon einmal die Vertexkoordinaten berechnet:</p>
</div>
<div class="listingblock">
<div class="title">BoxMesh.cpp, Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">BoxMesh</span><span class="o">::</span><span class="n">BoxMesh</span><span class="p">(</span><span class="kt">float</span> <span class="n">width</span><span class="p">,</span> <span class="kt">float</span> <span class="n">height</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depth</span><span class="p">,</span> <span class="n">QColor</span> <span class="n">boxColor</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// a = 0</span>
	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span> <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// b = 1</span>
	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span> <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// c = 2</span>
	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// d = 3</span>

	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// e = 4</span>
	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span> <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// f = 5</span>
	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span> <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// g = 6</span>
	<span class="n">m_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">QVector3D</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">width</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">height</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="o">*</span><span class="n">depth</span><span class="p">));</span> <span class="c1">// h = 7</span>

	<span class="n">setColor</span><span class="p">(</span><span class="n">boxColor</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Knotenkoordinaten sind zunächst in einem Vektor von <code>QVector3D</code> abgelegt. Bei einem nachfolgenden Aufruf zur Transformation werden diese Koordinaten einfach <em>verändert</em>:</p>
</div>
<div class="listingblock">
<div class="title">BoxMesh.cpp:transform()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxMesh</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="k">const</span> <span class="n">QMatrix4x4</span> <span class="o">&amp;</span> <span class="n">transform</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">m_vertices</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">transform</span><span class="o">*</span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bei mehrfacher Ausführung von <code>transform()</code> auf die Rundungsfehler achten!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nun sind die Boxen also bereits im Weltenkoordinatensystem verankert und der Vertexpuffer und Indexpuffer können befüllt werden.</p>
</div>
<div class="paragraph">
<p>Für das weitere Vorgehen ist es hilfreich, das Speicherlayout des Vertexpuffers einmal gesehen zu haben. Die folgende Abbildung zeigt das Ziel dieser Kopieraktion.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_vertexbuffer.png" alt="Vertex Buffer Layout">
</div>
<div class="title">Figure 10. Speicherlayout des Vertexpuffers</div>
</div>
<div class="paragraph">
<p>Alle Boxen werden nacheinander im VBO abgelegt. Je Box sind das 6 Seiten, wobei für jede Seite 4 Vertexes mit je Koordinaten und Farbwerten abgelegt werden. Das Kopieren erfolgt in der Funktion <code>copy2Buffer()</code>, wobei jeweils die Daten für eine einzelne Box kopiert werden. In der Abbildung ist auch der <em>stride</em> (Länge eines Vertexdatenblocks) gezeigt.</p>
</div>
<div class="paragraph">
<p>In der Funktion <code>copy2Buffer()</code> wird zunächst ein temporärer Vektor <code>cols</code> mit Farben für jede Seite angelegt, für den Fall, dass einfarbige Boxen verwendet werden:</p>
</div>
<div class="listingblock">
<div class="title">BoxMesh.cpp:copy2Buffer()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxMesh</span><span class="o">::</span><span class="n">copy2Buffer</span><span class="p">(</span><span class="n">Vertex</span> <span class="o">*&amp;</span> <span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">GLuint</span> <span class="o">*&amp;</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">elementStartIndex</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="n">cols</span><span class="p">;</span>
	<span class="n">Q_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">m_colors</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
	<span class="c1">// three ways to store vertex colors</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_colors</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cols</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">m_colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">m_colors</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">cols</span> <span class="o">=</span> <span class="n">m_colors</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun werden die Seiten nacheinander in der Reihenfolge <em>vorne, rechts, hinten, links, unten</em> und <em>oben</em> in die Puffer geschrieben:</p>
</div>
<div class="listingblock">
<div class="title">BoxMesh.cpp:copy2Buffer(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxMesh</span><span class="o">::</span><span class="n">copy2Buffer</span><span class="p">(</span><span class="n">Vertex</span> <span class="o">*&amp;</span> <span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">GLuint</span> <span class="o">*&amp;</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">elementStartIndex</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="p">...</span>

	<span class="c1">// front plane: a, b, c, d, vertexes (0, 1, 2, 3)</span>
	<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="p">);</span>

	<span class="c1">// right plane: b=1, f=5, g=6, c=2, vertexes</span>
	<span class="c1">// Mind: colors are numbered up</span>
	<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="p">);</span>

	<span class="c1">// back plane: g=5, e=4, h=7, g=6</span>
	<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="p">);</span>

	<span class="c1">// left plane: 4,0,3,7</span>
	<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="p">);</span>

	<span class="c1">// bottom plane: 4,5,1,0</span>
	<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
		<span class="p">);</span>

	<span class="c1">// top plane: 3,2,6,7</span>
	<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
			<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
		<span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Beim Aufruf der Funktion <code>copyPlane2Buffer()</code> stehen die Zeiger <code>vertexBuffer</code> und <code>elementBuffer</code> stehts am Anfang des Speicherbereichs, in den die nun folgenden Seitendaten geschrieben werden.</p>
</div>
<div class="paragraph">
<p>Ebenso enthält die Variable <code>elementStartIndex</code> den Vertexindex, bei dem die Nummerierung beginnt. Bei der ersten Box beginnt die Nummerierung auf der Vorderseite mit 0 (d.h. Vertexes 0&#8230;&#8203;3 sind auf der Vorderseite), siehe auch folgende Abbildung:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_PlaneVertexNumbering.png" alt="Vertex-Nummerierung der Seiten">
</div>
<div class="title">Figure 11. Seitennummerierung und generierte Dreieckselemente</div>
</div>
<div class="paragraph">
<p>Die Koordinaten und Farben werden beim Aufruf in die Vertex-Struktur kopiert.</p>
</div>
<div class="paragraph">
<p>Nachdem die Daten für die Vorderseite kopiert wurden, sind die Zeiger entsprechend verschoben worden und zeigen nun auf den Speicherbereich der nächsten Seite. Beim Aufruf der Funktion <code>copyPlane2Buffer()</code> muss auf die korrekte Reihenfolge der Vertexes geachtet werden, sodass die Vertices immer entgegen des Uhrzeigersinns übergeben werden.</p>
</div>
<div class="paragraph">
<p>Die letzte Abbildung zeigt auch die zwei Dreiecke, welche die Seite bilden. Deshalb wird in dieser Funktion sowohl der Vertexpuffer als auch der Indexpuffer befüllt. Innerhalb der Funktion <code>copyPlane2Buffer()</code> wird die Nummerierung relativ durchgeführt, d.h. die Vertices sind <em>immer</em> 0 bis 3, wobei allerdings stets der Startindex addiert wird (siehe Abbildung, rechte Seite).</p>
</div>
<div class="listingblock">
<div class="title">BoxMesh.cpp:copyPlane2Buffer()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">copyPlane2Buffer</span><span class="p">(</span><span class="n">Vertex</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">GLuint</span> <span class="o">*</span> <span class="o">&amp;</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">elementStartIndex</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Vertex</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vertex</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vertex</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vertex</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// first store the vertex data (a,b,c,d in counter-clockwise order)</span>

	<span class="n">vertexBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">vertexBuffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">vertexBuffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">vertexBuffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

    <span class="p">...</span>

	<span class="c1">// advance vertexBuffer</span>
	<span class="n">vertexBuffer</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="c1">// we generate data for two triangles: a, b, d  and b, c, d</span>

	<span class="n">elementBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">elementStartIndex</span><span class="p">;</span>
	<span class="n">elementBuffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">elementStartIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">elementBuffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">elementStartIndex</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">elementBuffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">elementStartIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">elementBuffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">elementStartIndex</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">elementBuffer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">elementStartIndex</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span>

	<span class="c1">// advance elementBuffer</span>
	<span class="n">elementBuffer</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="c1">// 4 vertices have been added, so increase start number for next plane</span>
	<span class="n">elementStartIndex</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier machen wir uns nun eine nette Eigenschaft von C/C++ zu Nutze. Wenn wir einen Speicherbereich als Vektor einer Struktur behandeln, und via Index Objekte zuweisen, dass wird automatisch der Speicherbereich mit den Inhalten der Strukturen in der Reihenfolge der Deklaration der Variablen befüllt.</p>
</div>
<div class="paragraph">
<p>Da die Addressen und der Startindex als Referenzvariablen übergeben wurden, können wir die Zeiger "weiterschieben" und die Vertexanzahl entsprechend erhöhen.</p>
</div>
<div class="paragraph">
<p>Das schöne an der Funktion <code>copyPlane2Buffer()</code> ist, dass sie unverändert auch funktioniert, wenn die <code>Vertex</code>-Struktur später um Normalenvektoren und/oder Texturkoordinaten erweitert wird.</p>
</div>
<div class="paragraph">
<p>Mehr gibt es auch zur Klasse <code>BoxMesh</code> nicht zu sagen, womit wir am Ende des <em>Tutorial 05</em> angelangt wären. Um das ganze aber noch abzurunden (und etwas schicker aussehen zu lassen) fehlt noch Kantenglättung.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_antialiasing">5.8. Antialiasing</h3>
<div class="paragraph">
<p>Es gibt hier verschiedene Möglichkeiten, Antialiasing (Kantenglättung) zu verwenden. Die wohl einfachste aus Sicht der Programmierung ist das Einschalten von Multisampling (MSAA) (siehe Erläuterung auf <a href="https://www.khronos.org/opengl/wiki/Multisampling" class="bare">https://www.khronos.org/opengl/wiki/Multisampling</a>).</p>
</div>
<div class="paragraph">
<p>Dazu muss man beim Konfigurieren des <code>QSurfaceFormat</code>-Objekts nur folgende Zeile hinzufügen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">format</span><span class="p">.</span><span class="n">setSamples</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>	<span class="c1">// enable multisampling (antialiasing)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Multisampling braucht mehr Grafikkartenspeicher und ist durch das mehrfache Samplen von Pixeln/Fragmenten natürlich langsamer. Daher gibt es auch die Möglichkeit, Antialiasing in das Shaderprogramm einzubauen. Das ist aber, ebenso wie ein Drahtgittereffekt, ein Thema für ein anderes Tutorial.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_06_fehlerbehandlung_und_und_profiling_mit_qopengldebuglogger_und_qopengltimemonitor">6. Tutorial 06: Fehlerbehandlung und und Profiling mit QOpenGLDebugLogger und QOpenGLTimeMonitor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In diesem Tutorial geht es um zwei Themen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sinnvolle Fehlerbehandlung und Kapselung der Fehlerausgaben</p>
</li>
<li>
<p>Profiling von GPU Operationen (sinnvoll für die nächsten Tutorials, in denen durchaus zeitkritische Operationen angestoßen werden)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Qt-Klassen in diesem Tutorial:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QOpenGLDebugLogger</code></p>
</li>
<li>
<p><code>QOpenGLTimerQuery</code></p>
</li>
<li>
<p><code>QOpenGLTimeMonitor</code></p>
</li>
<li>
<p><code>QElapsedTimer</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_06">Tutorial_06</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_fehlerbehandlung">6.1. Fehlerbehandlung</h3>
<div class="paragraph">
<p>Alle bisher vorgestellten Qt-Wrapper-Klassen um native OpenGL-Aufrufe haben bereits eine Fehleranalyse eingebaut, also bspw. <code>QOpenGLShaderProgram</code>, <code>QOpenGLBuffer</code> oder <code>QOpenGLContext</code>.</p>
</div>
<div class="paragraph">
<p>Viele der Funktionen, die native OpenGL-Funktionen aufrufen, liefern ein <code>bool</code> zurück, und im Falle eines Fehlers (<code>false</code>) kann man mit der Memberfunktion <code>log()</code> eine Fehlermeldung abfragen.</p>
</div>
<div class="paragraph">
<p>Eine typische Debugausgabe wurde in den bisherigen Tutorials schon verwendet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">...</span>

<span class="n">m_program</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QOpenGLShaderProgram</span><span class="p">();</span>

<span class="c1">// read the shader programs from the resource</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Vertex</span><span class="p">,</span> <span class="s">":/shaders/pass_through.vert"</span><span class="p">))</span>
	<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Vertex shader errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Fragment</span><span class="p">,</span> <span class="s">":/shaders/simple.frag"</span><span class="p">))</span>
	<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Fragment shader errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">())</span>
	<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Shader linker errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

<span class="p">...</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_exceptions_und_qt">6.1.1. Exceptions und Qt</h4>
<div class="paragraph">
<p>Es wäre natürlich sinnvoll, wenn man zwischen akzeptablen Fehlern (Warnungen) und kritischen Fehlern unterscheidet.</p>
</div>
<div class="paragraph">
<p>Ein Qt-typischer Weg der Fehlerbehandlung wäre die Prüfung von Fehlern in Funktionen und dann Kommunikation via Funktionsrückgabewerten, ob ein Fehler aufgetreten ist oder nicht. Alternativ können auch Fehlerflags gesetzt werden, die dann an verschiedenen Stellen geprüft werden müssen. Diese Art der Fehlerbehandlung verlangt jedoch selbst viel Disziplin von Programmierern und führt in der Praxis leider häufig dazu, dass ein Fehlerflag/Rückgabewert nicht getestet wird und deshalb das Programm irgendwas macht. In Zusammenhang mit OpenGL heißt das meist, ein leeres oder unvollständig gezeichnetes Bild.</p>
</div>
<div class="paragraph">
<p>Bei kritischen Fehler, bei denen das Programm nicht sinnvoll weitergeführt werden kann, möchte man vielleicht in klassischer C++-Manier Exceptions verwenden. Dieses Kapitel behandelt eine Möglichkeit, mit Qt und Exceptions eine Fehlerbehandlung zu realisieren.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die nachfolgend diskutierten Ansätze zur Exceptionbehandlung und Meldungsausgabe gelten aber eigentlich für jede Qt Anwendung, unabhängig von OpenGL.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bei Verwendung von Exceptions wäre obiger Quelltext dann etwas länglicher und würde eventuell so aussehen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">initializeGL</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>

        <span class="p">...</span>

        <span class="n">m_program</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLShaderProgram</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Vertex</span><span class="p">,</span> <span class="s">":/shaders/pass_through.vert"</span><span class="p">))</span>
        	<span class="k">throw</span> <span class="n">MyOpenGLException</span><span class="p">(</span><span class="s">"Vertex shader compile error"</span><span class="p">,</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">()</span> <span class="p">);</span>

        <span class="p">...</span>

    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">MyOpenGLException</span> <span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">MyOpenGLException</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s">"OpenGL Initialization failed."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>und irgendwo weiter draußen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">        <span class="p">...</span>

    <span class="err">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">MyOpenGLException</span> <span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ex</span><span class="p">.</span><span class="n">writeMsgStackToStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Entscheidend bei der Verwendung von Exceptions ist das kontrollierte Aufräumen der OpenGL-Resourcen. Auch gelten natürlich alle normalen Vorsichtsmaßnahmen und Programmierregeln für Exception-Code (siehe auch <em>Scott Meyers "Effektives C++"</em>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An anderer Stelle im Quelltext möchte man sich einfach darauf verlassen, dass ein bestimmter Aufruf korrekt abläuft. Hier kann man asserts verwenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es lohnt sich allerdings, die jeweiligen Gründe für ein Fehlschlagen nachzulesen. Beim <code>QOpenGLBuffer</code> kann die <code>bind()</code> Funktion aus mehreren Gründen fehlschlagen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Der Puffertyp wird bei der gerade verwendeten OpenGL-Implementierung (treiberseitig) nicht unterstützt (ein Portabilitätsproblem).</p>
</li>
<li>
<p>Der OpenGL-Context ist nicht aktuell (ein Programmierfehler).</p>
</li>
<li>
<p>Der Puffer wurde (noch) nicht erstellt (auch ein Programmierfelhler).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also bis auf den ersten Grund, ist ein <code>Q_ASSERT</code> sicher das Mittel der Wahl. Bei der  Plattformunterstützung hilft letztlich nur ein explizites Abfragen der Funktionalität - und, falls dies im Vorfeld nicht für alle Funktionen möglich ist, eben doch die Verwendung einer Exception.</p>
</div>
<div class="sect4">
<h5 id="_beispiel_für_eine_exceptionklasse">Beispiel für eine Exceptionklasse</h5>
<div class="paragraph">
<p>Eine eigene Exceptionklasse zu schreiben ist nicht wirklich ein Qt-typisches Problem, daher hier nur kurz ein minimalistischer Vorschlag zum selber ausbauen:</p>
</div>
<div class="listingblock">
<div class="title">OpenGLException.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#ifndef OPENGLEXCEPTION_H
#define OPENGLEXCEPTION_H
</span>
<span class="cp">#include &lt;stdexcept&gt;
#include &lt;list&gt;
</span>
<span class="cp">#include &lt;QString&gt;
</span>
<span class="k">class</span> <span class="nc">OpenGLException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">OpenGLException</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">OpenGLException</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">where</span><span class="p">);</span>
	<span class="n">OpenGLException</span><span class="p">(</span><span class="n">OpenGLException</span> <span class="o">&amp;</span> <span class="n">previous</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">OpenGLException</span><span class="p">(</span><span class="n">OpenGLException</span> <span class="o">&amp;</span> <span class="n">previous</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">where</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">writeMsgStackToStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">strm</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">QString</span><span class="p">,</span> <span class="n">QString</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_msgStack</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FUNCID(x) const char * const FUNC_ID = "[" #x "]"
</span>
<span class="cp">#endif // OPENGLEXCEPTION_H</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>wobei die Implementierung recht selbsterklärend ist:</p>
</div>
<div class="listingblock">
<div class="title">OpenGLException.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include "OpenGLException.h"
</span>
<span class="cp">#include &lt;QStringList&gt;
</span>
<span class="n">OpenGLException</span><span class="o">::</span><span class="n">OpenGLException</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">m_msgStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">QString</span><span class="p">()));</span>
<span class="p">}</span>

<span class="n">OpenGLException</span><span class="o">::</span><span class="n">OpenGLException</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">where</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">m_msgStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">where</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">OpenGLException</span><span class="o">::</span><span class="n">OpenGLException</span><span class="p">(</span><span class="n">OpenGLException</span> <span class="o">&amp;</span> <span class="n">previous</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">m_msgStack</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">m_msgStack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m_msgStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">QString</span><span class="p">()));</span>
<span class="p">}</span>

<span class="n">OpenGLException</span><span class="o">::</span><span class="n">OpenGLException</span><span class="p">(</span><span class="n">OpenGLException</span> <span class="o">&amp;</span> <span class="n">previous</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">where</span><span class="p">)</span>  <span class="o">:</span>
	<span class="n">m_msgStack</span><span class="p">(</span><span class="n">previous</span><span class="p">.</span><span class="n">m_msgStack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m_msgStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">where</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">OpenGLException</span><span class="o">::</span><span class="n">writeMsgStackToStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">strm</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">QString</span><span class="p">,</span> <span class="n">QString</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m_msgStack</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
		<span class="n">it</span> <span class="o">!=</span> <span class="n">m_msgStack</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">QStringList</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">QString</span> <span class="n">indx</span><span class="p">(</span><span class="s">"[%1] "</span><span class="p">);</span>
		<span class="n">indx</span> <span class="o">=</span> <span class="n">indx</span><span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">m_msgStack</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">it</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">l</span> <span class="o">:</span> <span class="n">lines</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
				<span class="n">strm</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">).</span><span class="n">toStdString</span><span class="p">();</span>
			<span class="k">else</span>
				<span class="n">strm</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">).</span><span class="n">toStdString</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">strm</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Interessanter ist eher die Verwendung, also bspw. in <code>ShaderProgram.cpp</code>:</p>
</div>
<div class="listingblock">
<div class="title">ShaderProgram.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">ShaderProgram</span><span class="o">::</span><span class="n">create</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">FUNCID</span><span class="p">(</span><span class="n">ShaderProgram</span><span class="o">::</span><span class="n">create</span><span class="p">);</span>

    <span class="p">...</span>

	<span class="c1">// read the shader programs from the resource</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">m_vertexShaderFilePath</span><span class="p">))</span>
		<span class="k">throw</span> <span class="n">OpenGLException</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"Error compiling vertex shader %1:</span><span class="se">\n</span><span class="s">%2"</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">m_vertexShaderFilePath</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">()),</span> <span class="n">FUNC_ID</span><span class="p">);</span>

	<span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Vielleicht kurz noch eine Erläuterung zum <code>FUNCID()</code> Makro. Ist eigentlich nur eine Lese-/Schreibvereinfachung:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">FUNCID</span><span class="p">(</span><span class="n">ShaderProgram</span><span class="o">::</span><span class="n">create</span><span class="p">);</span>

<span class="c1">// wird zu</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">FUNC_ID</span> <span class="o">=</span> <span class="s">"[ShaderProgram::create]"</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Klasse <code>OpenGLException</code> nimmt im Konstruktor entweder ein oder zwei Argumente, im Beispiel oben ist die Variante mit den zwei Argumenten verwendet. Nun kann man in der Aufrufhierarchie weiter oben die Exception fangen und mit weiteren Informationen anreichern. Zum Beispiel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">initializeGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">FUNCID</span><span class="p">(</span><span class="n">SceneView</span><span class="o">::</span><span class="n">initializeGL</span><span class="p">);</span>
	<span class="k">try</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ShaderProgram</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">m_shaderPrograms</span><span class="p">)</span>
			<span class="n">p</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>

        <span class="p">...</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">OpenGLException</span> <span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">throw</span> <span class="n">OpenGLException</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s">"OpenGL initialization failed."</span><span class="p">,</span> <span class="n">FUNC_ID</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier wird die Exception gefangen und erneut geworfen. Damit die bisherigen Informationen nicht verloren gehen, wird der Konstruktor mit <code>OpenGLException</code>-Argument verwendet. In der Implementierung oben sieht man, dass die neue Klasse die Meldungsliste der bisherigen Exception-Instanz übernimmt, und einfach die neue Information anhängt.</p>
</div>
<div class="paragraph">
<p>Beim Aufruf von <code>ex.writeMsgStackToStream(std::cerr)</code> wird nun z.B. Folgendes ausgegeben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[0] [ShaderProgram::create] : Error compiling fragment shader :/shaders/simple.frag:
[0] [ShaderProgram::create] : 0(8) : error C1503: undefined variable "fragsColor"
[0] [ShaderProgram::create] :
[1] [SceneView::initializeGL] : OpenGL initialization failed.</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_qapplicationnotify">QApplication::notify</h5>
<div class="paragraph">
<p>Man könnte jetzt die geworfene Exception einfach in der <code>main.cpp</code> fangen, also so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">try</span> <span class="p">{</span>
	<span class="n">TestDialog</span> <span class="n">dlg</span><span class="p">;</span>
	<span class="n">dlg</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">OpenGLException</span> <span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">writeMsgStackToStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Aber wenn nun eine Exception geworfen wird, bekommt man folgende Warnung ausgegeben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Qt has caught an exception thrown from an event handler. Throwing
exceptions from an event handler is not supported in Qt.
You must not let any exception whatsoever propagate through Qt code.
If that is not possible, in Qt 5 you must at least reimplement
QCoreApplication::notify() and catch all exceptions there.</pre>
</div>
</div>
<div class="paragraph">
<p>Wenn man in Qt eine Exception wirft, sollte diese eigentlich nicht bis in die Ereignisschleife gelangen (ursprünglich war Qt ohne Exception-Unterstützung konzipiert). Die "saubere" Variante besteht also darin, diese <code>notify()</code>-Funktion zu überladen:</p>
</div>
<div class="listingblock">
<div class="title">DebugApplication.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">DebugApplication</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QApplication</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">DebugApplication</span><span class="p">(</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="o">:</span>  <span class="n">QApplication</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">),</span> <span class="n">m_aboutToTerminate</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">notify</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">recv</span><span class="p">,</span> <span class="n">QEvent</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">QApplication</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span> <span class="n">recv</span><span class="p">,</span> <span class="n">e</span> <span class="p">);</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">OpenGLException</span> <span class="o">&amp;</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ex</span><span class="p">.</span><span class="n">writeMsgStackToStream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">);</span>
			<span class="n">m_aboutToTerminate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">QApplication</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Flag to check for program abort</span>
	<span class="kt">bool</span> <span class="n">m_aboutToTerminate</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Soweit recht klar, es sollte jedoch noch erwähnt werden, was das Flag <code>m_aboutToTerminate</code> for eine Bewandnis hat. Letztlich wird <code>notify()</code> als Teil der Ereignisschleife aufgerufen, d.h. nach Rückkehr aus <code>notify()</code> landet man wieder in der Ereignisschleife, und weitere Teiles des Programms (wie z.B. <code>paintGL()</code>-Funktionen) können aufgerufen werden, bevor <code>exit()</code> greift.</p>
</div>
<div class="paragraph">
<p>Damit man nicht auf un-initialisierte Variablen zugreift, kann man am Anfang von Funktionen dieses Flag prüfen, und notfalls einfach die Arbeit verweigern. In der <code>paintGL()</code>-Funktion sähe das z.B. so aus:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">DebugApplication</span> <span class="o">*</span><span class="p">)</span><span class="n">qApp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_aboutToTerminate</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der alte C-cast ist natürlich nicht ganz auf der Höhe der Zeit, aber einen (teuren) dynamic cast braucht man nur, wenn man sich nicht sicher ist, ob tatsächlich ein <code>DebugApplication</code>-Objekt verwendet wird (also z.B. in einer Bibliotheksfunktion).</p>
</div>
<div class="paragraph">
<p>Ist die Ereignisschleife dann abgearbeitet, wird das Programm kontrolliert beendet, als hätte man das Hauptfenster geschlossen. Damit muss man dann auch das Aufräumen des Speichers nur einmal programmieren.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_qt_messagehandler">6.1.2. Qt-MessageHandler</h4>
<div class="paragraph">
<p>An verschiedenen Stellen im Qt-Quelltext (und natürlich eigenem Quelltext) werden die Funktionen <code>qDebug()</code> oder <code>qWarning()</code> verwendet. Wenn man diese Ausgaben in einem QWidget sehen möchte (bspw. <code>QPlainTextEdit</code>), oder in eine Log-Datei schreiben möchte, kann man einen eigenen Qt-MessageHandler installieren:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre>void qDebugMsgHandler(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg) {
	(void) context;
	QString msgPrefix = "[" + QDateTime::currentDateTime().toString() + "] ";
	switch (type) {
		case QtDebugMsg		: msgPrefix += "Debug:    "; break;
		case QtWarningMsg	: msgPrefix += "Warning:  "; break;
		case QtCriticalMsg	: msgPrefix += "Critical: "; break;
		case QtFatalMsg		: msgPrefix += "Fatal:    "; break;
		case QtInfoMsg		: msgPrefix += "Info:     "; break;
	}
	QStringList lines = msg.split("\n");
	for (const QString &amp; l : lines)
		std::cout &lt;&lt; (msgPrefix + l).toStdString() &lt;&lt; std::endl;
}


int main(int argc, char **argv) {
	qInstallMessageHandler(qDebugMsgHandler);

    ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Das führt dann zu schön formatierten Ausgaben mit Zeitstempel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[So. Apr. 5 21:17:58 2020] Debug:    GL_KHR_debug extension available
[So. Apr. 5 21:18:02 2020] Debug:    Debug Logger initialized
[So. Apr. 5 21:18:02 2020] Debug:
[So. Apr. 5 21:18:13 2020] Debug:    BoxObject - VertexBuffer size = 5625.56 kByte
[So. Apr. 5 21:18:21 2020] Debug:    ++++ [APISource:OtherType] Buffer detailed info: Buffer object 1 (bound to GL_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.
[So. Apr. 5 21:18:21 2020] Debug:
[So. Apr. 5 21:18:27 2020] Debug:    BoxObject - ElementBuffer size = 1406.39 kByte
[So. Apr. 5 21:18:27 2020] Debug:    ++++ [APISource:OtherType] Buffer detailed info: Buffer object 2 (bound to GL_ELEMENT_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.
[So. Apr. 5 21:18:27 2020] Debug:
[So. Apr. 5 21:18:27 2020] Debug:    GridObject - VertexBuffer size = 31.25 kByte
[So. Apr. 5 21:18:27 2020] Debug:    ++++ [APISource:OtherType] Buffer detailed info: Buffer object 3 (bound to GL_ARRAY_BUFFER_ARB, usage hint is GL_STATIC_DRAW) will use VIDEO memory as the source for buffer object operations.
[So. Apr. 5 21:18:27 2020] Debug:
[So. Apr. 5 21:18:27 2020] Debug:    SceneView::paintGL(): Rendering to: 700 x 416
[So. Apr. 5 21:18:27 2020] Debug:       0.002048 ms/frame
[So. Apr. 5 21:18:27 2020] Debug:       6.18394 ms/frame
[So. Apr. 5 21:18:27 2020] Debug:       0.001024 ms/frame
[So. Apr. 5 21:18:27 2020] Debug:       1.97427 ms/frame
[So. Apr. 5 21:18:27 2020] Debug:    Total render time:  8.16128 ms/frame
[So. Apr. 5 21:18:27 2020] Debug:    Total paintGL time:  11 ms----</pre>
</div>
</div>
<div class="paragraph">
<p>In dieser Logausgabe sieht man schonmal zwei interessante Inhalte:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OpenGL-Debug-Informationen</p>
</li>
<li>
<p>Profiling-Ausgaben</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_qopengldebuglogger">6.1.3. QOpenGLDebugLogger</h4>
<div class="paragraph">
<p>Zusätzliche Debug-Ausgaben lassen sich mit der Klasse <code>QOpenGLDebugLogger</code> erhalten (welche intern <code>glGetError()</code> aufruft und Meldungen via signal-slot-Verbindung an eigene Slots weiterleitet. Die Qt-Dokumentation beschreibt das Feature ausreichend - der Tutorial 06 Quelltext enthält ein Beispiel der Verwendung dieser Klasse.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_profiling_und_performance_tuning">6.2. Profiling und Performance-Tuning</h3>
<div class="paragraph">
<p>Wenn man OpenGL-Performance-Probleme analysieren und beheben will, braucht man Messungen. Hierfür gibt es OpenGL-Timers bzw. Zeitstempel, die durch die Qt-Klasse <code>QOpenGLTimerQuery</code> gekapselt sind.</p>
</div>
<div class="paragraph">
<p>Die Verwendung ist denkbar einfach, allerdings mit einer kleinen Tücke:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QOpenGLTimerQuery</span> <span class="n">startTimer</span><span class="p">;</span>
<span class="n">QOpenGLTimerQuery</span> <span class="n">endTimer</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">startTimer</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">endTimer</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>

<span class="p">...</span>

<span class="n">startTimer</span><span class="p">.</span><span class="n">recordTimestamp</span><span class="p">();</span>

<span class="n">OPEN_GL_CODE</span>

<span class="n">endTimer</span><span class="p">.</span><span class="n">recordTimestamp</span><span class="p">();</span>

<span class="p">...</span>

<span class="n">GLuint64</span> <span class="n">startT</span> <span class="o">=</span> <span class="n">m_startTimer</span><span class="p">.</span><span class="n">waitForResult</span><span class="p">();</span>
<span class="n">GLuint64</span> <span class="n">endT</span> <span class="o">=</span> <span class="n">m_endTimer</span><span class="p">.</span><span class="n">waitForResult</span><span class="p">();</span>
<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Render time: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">endT</span> <span class="o">-</span> <span class="n">startT</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-6</span> <span class="o">&lt;&lt;</span> <span class="s">"ms/frame"</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">startTimer</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
<span class="n">endTimer</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Problem besteht nun darin, dass es etwas Zeit dauern kann, bis die Funktionen <code>waitForResult()</code> fertig sind. Während dieser Zeit wartet der Thread und blockiert die CPU. Ist also eventuell nicht die ideale Variante. Man kann auch erfragen, ob die Werte bereits da sind, mittels der Funktion <code>isResultAvailable()</code>.</p>
</div>
<div class="paragraph">
<p>Man kann dann in der <code>paintGL()</code>-Funktion einfach diese Abfrage einbauen und die bis dahin gesammelten Daten ausgeben. Die einfachste Form ist jedoch das Warten auf die Daten am Ende der Schleife:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">....</span>

    <span class="c1">// record start time stamp</span>
	<span class="n">m_startTimer</span><span class="p">.</span><span class="n">recordTimestamp</span><span class="p">();</span>

	<span class="c1">// *** render boxes</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_worldToView</span><span class="p">);</span>
	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">render</span><span class="p">();</span> <span class="c1">// render the boxes</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

	<span class="c1">// *** render grid ***</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_worldToView</span><span class="p">);</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gridColor</span><span class="p">);</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">backColor</span><span class="p">);</span>
	<span class="n">m_gridObject</span><span class="p">.</span><span class="n">render</span><span class="p">();</span> <span class="c1">// render the grid</span>
	<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

	<span class="n">m_endTimer</span><span class="p">.</span><span class="n">recordTimestamp</span><span class="p">();</span>

	<span class="n">GLuint64</span> <span class="n">startT</span> <span class="o">=</span> <span class="n">m_startTimer</span><span class="p">.</span><span class="n">waitForResult</span><span class="p">();</span>
	<span class="n">GLuint64</span> <span class="n">endT</span> <span class="o">=</span> <span class="n">m_endTimer</span><span class="p">.</span><span class="n">waitForResult</span><span class="p">();</span>
	<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Render time: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">endT</span> <span class="o">-</span> <span class="n">startT</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-6</span> <span class="o">&lt;&lt;</span> <span class="s">"ms/frame"</span><span class="p">;</span>

	<span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn man etwas genauer wissen möchte, welcher Teil des OpenGL-Codes den größten Zeitaufwand bedeutet, so könnte man einfach mehrere Timer verwenden. Qt stellt zu diesem Zweck jedoch die hilfreiche Klasse <code>QOpenGLTimeMonitor</code> zur Verfügung, die mehrere in Sequenz aufgerufenen OpenGL-Timer-Objekte verwaltet.</p>
</div>
<div class="paragraph">
<p>Die Verwendung ist hinreichend einfach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QOpenGLTimeMonitor</span> <span class="n">m_timers</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// Initialisierung</span>
<span class="n">m_timers</span><span class="p">.</span><span class="n">setSampleCount</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">m_timers</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>

<span class="p">...</span>

<span class="c1">// Render loop</span>

<span class="n">m_timers</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="n">m_timers</span><span class="p">.</span><span class="n">recordSample</span><span class="p">();</span> <span class="c1">// setup paint #1</span>

<span class="c1">// *** render boxes</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_worldToView</span><span class="p">);</span>

<span class="n">m_timers</span><span class="p">.</span><span class="n">recordSample</span><span class="p">();</span> <span class="c1">// render #1</span>
<span class="n">m_boxObject</span><span class="p">.</span><span class="n">render</span><span class="p">();</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

<span class="c1">// *** render grid afterwards ***</span>

<span class="n">m_timers</span><span class="p">.</span><span class="n">recordSample</span><span class="p">();</span> <span class="c1">// setup paint #2</span>

<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_worldToView</span><span class="p">);</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gridColor</span><span class="p">);</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">backColor</span><span class="p">);</span>

<span class="n">m_timers</span><span class="p">.</span><span class="n">recordSample</span><span class="p">();</span> <span class="c1">// render #2</span>
<span class="n">m_gridObject</span><span class="p">.</span><span class="n">render</span><span class="p">();</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>

<span class="n">m_timers</span><span class="p">.</span><span class="n">recordSample</span><span class="p">();</span> <span class="c1">// finish</span>

<span class="c1">// Intervallausgabe</span>
<span class="n">QVector</span><span class="o">&lt;</span><span class="n">GLuint64</span><span class="o">&gt;</span> <span class="n">intervals</span> <span class="o">=</span> <span class="n">m_timers</span><span class="p">.</span><span class="n">waitForIntervals</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="n">GLuint64</span> <span class="n">it</span> <span class="o">:</span> <span class="n">intervals</span><span class="p">)</span>
	<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">*</span><span class="mf">1e-6</span> <span class="o">&lt;&lt;</span> <span class="s">"ms/frame"</span><span class="p">;</span>

<span class="c1">// Zeitstempel</span>
<span class="n">QVector</span><span class="o">&lt;</span><span class="n">GLuint64</span><span class="o">&gt;</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">m_timers</span><span class="p">.</span><span class="n">waitForSamples</span><span class="p">();</span>
<span class="c1">// Gesamtzeitausgabe</span>
<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Render time: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">-</span> <span class="n">samples</span><span class="p">.</span><span class="n">front</span><span class="p">())</span><span class="o">*</span><span class="mf">1e-6</span> <span class="o">&lt;&lt;</span> <span class="s">"ms/frame"</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// Cleanup</span>
<span class="n">m_timers</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist, dass vor der Initialisierung mittels <code>setSamplesCount()</code> die Anzahl der geplanten <code>recordSample()</code>-Aufrufe festgelegt wird.</p>
</div>
<div class="sect3">
<h4 id="_gpu_und_cpu_profiling">6.2.1. GPU und CPU Profiling</h4>
<div class="paragraph">
<p>Die Schwierigkeit bei der Optimierung von OpenGL-Code liegt in der parallelen Ausführung von GPU und CPU-Code, und den mitunter schwierig zu erkennenden Sychronisationsstellen. Grundregel sollte sein, dass <code>paintGL()</code>-Aufrufe schnell genug hintereinander erfolgen, um Animationen/Kamerabewegungen flüssig darzustellen. D.h. die <em>Summe</em> aus OpenGL-Zeit und CPU-Zeit (z.B. für Eingabebehandlung oder Datenverwaltung) sollte &lt; als die zur Verfügung stehende Zeit pro Frame sein.</p>
</div>
<div class="paragraph">
<p>Was man machen kann, ist die Zeit der gesamten <code>paintGL()</code>-Funktion zu messen, wobei man die Klasse <code>QElapsedTimer</code> verwenden kann, also z.B. so:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_cpuTimer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>

	<span class="p">....</span>

	<span class="n">qint64</span> <span class="n">elapsedMs</span> <span class="o">=</span> <span class="n">m_cpuTimer</span><span class="p">.</span><span class="n">elapsed</span><span class="p">();</span>
	<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Total paintGL time: "</span> <span class="o">&lt;&lt;</span> <span class="n">elapsedMs</span> <span class="o">&lt;&lt;</span> <span class="s">"ms"</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_07_markierenauswählen_von_flächen">7. Tutorial 07: Markieren/Auswählen von Flächen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In diesem Tutorial geht es darum, Flächen bzw. Objekte in der Scene auszuwählen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_07_RayTracking.png" alt="Tutorial_07">
</div>
<div class="title">Figure 12. Tutorial_07, Visualisierung eines Bildschirmstrahls</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_07">Tutorial_07</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es gibt für das Markieren/Auswählen von Objekten und Flächen eigentlich nur grundlegende Techniken:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Strahlenverfolgung (Ray Picking), d.h. Bestimmung der Sichtlinie im Weltenkoordinatensystem und dann Schnittpunktberechnung aller Objekte und Sortierung nach Tiefe.</p>
</li>
<li>
<p>Rendern in einen offscreen-Framenbuffer mit individuellen Farben aller anklickbaren Objekte und Identifizierung der Objekte durch Abbildung der Farben auf originale Objekte/Flächen.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_option_1_strahlenverfolgung">7.1. Option 1: Strahlenverfolgung</h3>
<div class="paragraph">
<p>Der Grundgedanke ist einfach: Die Mausposition im lokalen Fenster umrechnen in Weltkoordinaten und entlang dieser Linie alle Schnittpunkte mit auswählbaren Objekten finden. Das näheste Objekte zum Betrachter ist dann das ausgewählte Objekt.</p>
</div>
<div class="paragraph">
<p>Die Welt (in der perspektivischen Darstellung) hat eine <em>near plane</em> und eine <em>far plane</em>. Alles davor und dahinter wird geklippt und nicht dargestellt. Daher kann hier auch nichts sinnvoll ausgewählt werden. Der Betrachter schaut durch die <em>near plane</em> hindurch auf die Scene, und der Blickstrahl trifft irgendwo hinten auf die <em>far plane</em>. Da der Blickstrahl senkrecht zum Bildschirmoberfläche steht, sieht man die Linie selbst nur als Punkt.</p>
</div>
<div class="paragraph">
<p>Die Berechnung ist hinreichend trivial:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Globale Mauskoordinaten von <code>QCursor::pos()</code> in lokale Mauskoordinaten umrechnen (mittels <a href="https://doc.qt.io/qt-5/qwidget.html#mapFromGlobal">QWindow::mapFromGlobal()</a> )</p>
</li>
<li>
<p>Mausposition des lokalen Fensters in Normalized Device Coordinates (NDC) umrechnen. Dabei hilft sich vorzustellen, dass das Fenster das normalisierte x-y-Koordinatensystem beinhaltet, mit dem Mittelpunkt genau in der Mitte des Fensters und der Ausdehnung -1..1 in beide Achsen. Wenn man also genau in die Mitte klickt, ist das 0,0 in NDC. Ganz oben links geklickt ist das -1,1 (y-Achse zeigt nach oben in NFC). Die z-Koordinate ist -1 für die <em>far plane</em> und 1 für die <em>near plane</em>. W-Komponente auf 1 setzen.</p>
</li>
<li>
<p>Model2Projection-Matrix (also Produkt aller Transformationsmatrizen) invertieren</p>
</li>
<li>
<p>Beide Punkte mit der inversen Matrix transformieren</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Fertig. Hier ist der Quelltext:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:pick()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">pick</span><span class="p">(</span><span class="k">const</span> <span class="n">QPoint</span> <span class="o">&amp;</span> <span class="n">globalMousePos</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// local mouse coordinates</span>
	<span class="n">QPoint</span> <span class="n">localMousePos</span> <span class="o">=</span> <span class="n">mapFromGlobal</span><span class="p">(</span><span class="n">globalMousePos</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">my</span> <span class="o">=</span> <span class="n">localMousePos</span><span class="p">.</span><span class="n">y</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">localMousePos</span><span class="p">.</span><span class="n">x</span><span class="p">();</span>

	<span class="c1">// viewport dimensions</span>
	<span class="k">const</span> <span class="n">qreal</span> <span class="n">retinaScale</span> <span class="o">=</span> <span class="n">devicePixelRatio</span><span class="p">();</span> <span class="c1">// needed for Macs with retina display</span>
	<span class="n">qreal</span> <span class="n">vpw</span> <span class="o">=</span> <span class="n">width</span><span class="p">()</span><span class="o">*</span><span class="n">retinaScale</span><span class="p">;</span>
	<span class="n">qreal</span> <span class="n">vph</span> <span class="o">=</span> <span class="n">height</span><span class="p">()</span><span class="o">*</span><span class="n">retinaScale</span><span class="p">;</span>

	<span class="c1">// invert world2view matrix, with m_worldToView = m_projection * m_camera.toMatrix() * m_transform.toMatrix();</span>
	<span class="kt">bool</span> <span class="n">invertible</span><span class="p">;</span>
	<span class="n">QMatrix4x4</span> <span class="n">projectionMatrixInverted</span> <span class="o">=</span> <span class="n">m_worldToView</span><span class="p">.</span><span class="n">inverted</span><span class="p">(</span><span class="o">&amp;</span><span class="n">invertible</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">invertible</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qWarning</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">"Cannot invert projection matrix."</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// mouse position in NDC space, one point on near plane and one point on far plane</span>
	<span class="kt">float</span> <span class="n">halfVpw</span> <span class="o">=</span> <span class="n">vpw</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">halfVph</span> <span class="o">=</span> <span class="n">vph</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
	<span class="n">QVector4D</span> <span class="n">near</span><span class="p">(</span>
				<span class="p">(</span><span class="n">mx</span> <span class="o">-</span> <span class="n">halfVpw</span><span class="p">)</span> <span class="o">/</span> <span class="n">halfVpw</span><span class="p">,</span>
				<span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">my</span> <span class="o">-</span> <span class="n">halfVph</span><span class="p">)</span> <span class="o">/</span> <span class="n">halfVph</span><span class="p">,</span>
				<span class="o">-</span><span class="mi">1</span><span class="p">,</span>
				<span class="mf">1.0</span><span class="p">);</span>

	<span class="n">QVector4D</span> <span class="n">far</span><span class="p">(</span>
				<span class="n">near</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span>
				<span class="n">near</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span>
				<span class="mi">1</span><span class="p">,</span>
				<span class="mf">1.0</span><span class="p">);</span>

	<span class="c1">// transform from NDC to model coordinates</span>
	<span class="n">QVector4D</span> <span class="n">nearResult</span> <span class="o">=</span> <span class="n">projectionMatrixInverted</span><span class="o">*</span><span class="n">near</span><span class="p">;</span>
	<span class="n">QVector4D</span> <span class="n">farResult</span> <span class="o">=</span> <span class="n">projectionMatrixInverted</span><span class="o">*</span><span class="n">far</span><span class="p">;</span>
	<span class="c1">// don't forget normalization!</span>
	<span class="n">nearResult</span> <span class="o">/=</span> <span class="n">nearResult</span><span class="p">.</span><span class="n">w</span><span class="p">();</span>
	<span class="n">farResult</span> <span class="o">/=</span> <span class="n">farResult</span><span class="p">.</span><span class="n">w</span><span class="p">();</span>

	<span class="c1">// update pick line vertices (visualize pick line)</span>
	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
	<span class="n">m_pickLineObject</span><span class="p">.</span><span class="n">setPoints</span><span class="p">(</span><span class="n">nearResult</span><span class="p">.</span><span class="n">toVector3D</span><span class="p">(),</span> <span class="n">farResult</span><span class="p">.</span><span class="n">toVector3D</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ganz am Ende wird noch ein neu eingeführtes OpenGL-Zeichenobjekt aktualisiert. Nach der Lektüre von <em>Tutorial 05</em> sollte der Quelltext in <code>PickLineObject.*</code> selbsterklärend sein. Diese Objekt nutzt übrigends den gleichen Vertex- und Fragmentshader wie er für die Boxen eingesetzt wird.</p>
</div>
<div class="sect3">
<h4 id="_erkennung_von_mausklick_ereignissen">7.1.1. Erkennung von Mausklick-Ereignissen</h4>
<div class="paragraph">
<p>Bisher wurde mit dem Eingabemanager das Gedrückthalten der rechten Maustaste behandelt. Nun soll aber darauf reagiert werden, dass die linke Maustaste geklickt wurde (Linksklick=Auswahl). Das macht man am besten, indem man auf das Loslassen der Maustaste wartet. Gleichzeitig muss man sich dann aber die Position der Maus beim Loslassen merken, da die Maus ja hinterher noch bewegt werden kann.</p>
</div>
<div class="paragraph">
<p>Der Eingabemanager hat ja, wie in <em>Tutorial 05</em> erklärt, für Tasten (einschließlich Maustasten) einen Zustand "Wurde gedrückt". Den kann man nun einfach abfragen, z.B. in <code>SceneView::checkInput()</code>:</p>
</div>
<div class="listingblock">
<div class="title">SceneView::checkInput()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">checkInput</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// this function is called whenever _any_ key/mouse event was issued</span>

    <span class="p">....</span>

	<span class="c1">// has the left mouse butten been release</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">buttonReleased</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">LeftButton</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">m_inputEventReceived</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">renderLater</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

    <span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>KeyboardMouseHandler::buttonReleased(btn)</code> macht dabei nichts weiter, als zu prüfen, ob der Status der Taste auf <code>KeyboardMouseHandler::StateWasPressed</code> steht.</p>
</div>
<div class="paragraph">
<p>In der selben Art und Weise, wie auf andere Tastendrücke und Mausbewegungen reagiert wurde, kann man nun die Auswahlroutine anstoßen:</p>
</div>
<div class="listingblock">
<div class="title">SceneView::processInput()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">processInput</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>

	<span class="c1">// check for picking operation</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">buttonReleased</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">LeftButton</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pick</span><span class="p">(</span><span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">mouseReleasePos</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="c1">// finally, reset "WasPressed" key states</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">clearWasPressedKeyStates</span><span class="p">();</span>

    <span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist hier vielleicht nur, dass man abschließend auch die Flags der Maustasten zurücksetzt.</p>
</div>
<div class="paragraph">
<p>Mit dem derzeitigen Quelltextstand kann man nun wild in der Scene herumklicken, wobei man natürlich erstmal nichts sieht. Erst bei Bewegung in der Scene wird die nun visualisierte Sichtgerade erkennbar - bis zum nächsten Linksklick.</p>
</div>
</div>
<div class="sect3">
<h4 id="_finden_von_angeklickten_objekten">7.1.2. Finden von angeklickten Objekten</h4>
<div class="paragraph">
<p>Die zweite, auch nicht sonderlich komplizierte Aufgabe besteht darin, alle Objekte zu finden, die von der Sichtlinie geschnitten werden. Wenn es sich hierbei um Flächen handelt, ist das recht einfache Mathematik aus dem Tafelwerk (siehe <a href="https://de.wikipedia.org/wiki/Analytische_Geometrie">Wikipedia</a>).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Mathematische Grundlagen</strong></p>
</div>
<div class="paragraph">
<p>Ich schreibe die Mathematik hier nochmal kurz auf (aber nur um zu testen, wie man mit Asciidoctor ordentliche Gleichungen hinbekommt :-) )</p>
</div>
<div class="paragraph">
<p>Ebenengleichung in Normalenform, mit <strong>a</strong> als Bezugspunkt der Ebene und <strong>n</strong> als Normalenvektor:</p>
</div>
<div class="stemblock">
<div class="content">
\[(\boldsymbol{x}-\boldsymbol{a}) \cdot \boldsymbol{n} = 0\]
</div>
</div>
<div class="paragraph">
<p>Geradengleichung, mit <strong>d</strong> als Richtung und <strong>s</strong> als Startpunkt:</p>
</div>
<div class="stemblock">
<div class="content">
\[\boldsymbol{x} = \boldsymbol{s} + t \, \boldsymbol{d}\]
</div>
</div>
<div class="paragraph">
<p>Einsetzen und Ausmultiplizieren ergibt:</p>
</div>
<div class="stemblock">
<div class="content">
\[t_0 = \frac{\left( \boldsymbol{a} - \boldsymbol{s}\right) \cdot \boldsymbol{n}}{\boldsymbol{d} \cdot \boldsymbol{n}}\]
</div>
</div>
<div class="paragraph">
<p>Falls der Richtungsvektor der Geraden <strong>d</strong> und der Normalenvektor <strong>n</strong> senkrecht aufeinanderstehen wird der Nenner zu 0, d.h. die Gerade liegt parallel zur Ebene (entweder neben oder in der Ebene, ist uns aber hier egal). Dann soll es keinen Schnittpunkt geben.</p>
</div>
<div class="paragraph">
<p>Auch wenn Normalenvektor und Sichtgeradenvektor in die gleiche Richtung zeigen, soll kein Schnittpunkt berechnet werden (man würde ja sonst auf die Rückseite einer Fläche klicken).</p>
</div>
<div class="paragraph">
<p>Damit hätte man das erste Prüfkriterium (Bedingung 1):</p>
</div>
<div class="stemblock">
<div class="content">
\[\boldsymbol{d} \cdot \boldsymbol{n} &lt; 0\]
</div>
</div>
<div class="paragraph">
<p>Ob eine begrenzte <em>Fläche</em> von der <em>Strecke</em> (unserer Sichtlinie) geschnitten wird, hängt von der Lage des Schnittpunkts ab.</p>
</div>
<div class="paragraph">
<p>Wird die Sichtlinie durch den Start- und Endpunkt <strong>p1</strong> und <strong>p2</strong> (near und far-Punkte) definiert, und damit <strong>s</strong> = <strong>p1</strong> und <strong>d</strong> = <strong>p2</strong> - <strong>p1</strong>, dann muss t zwischen 0 und 1 liegen (Bedingung 2).</p>
</div>
<div class="paragraph">
<p>Der berechnete Schnittpunkt</p>
</div>
<div class="stemblock">
<div class="content">
\[\boldsymbol{x_0} = \boldsymbol{s} + t_0 \, \boldsymbol{d}\]
</div>
</div>
<div class="paragraph">
<p>liegt in der Ebene. Man kann nun die Ebenengleichung in Parameterform schreiben und die Parameter für den Schnittpunkt bestimmen. Wiederum definieren wir die Ebene über die Eckpunkte, hier <strong>a</strong>, <strong>b</strong> und <strong>c</strong>:</p>
</div>
<div class="stemblock">
<div class="content">
\[\boldsymbol{x} = \boldsymbol{a} + r\, (\boldsymbol{b} - \boldsymbol{a}) + s\, (\boldsymbol{c} - \boldsymbol{a})\]
</div>
</div>
<div class="paragraph">
<p>Der Normalenvektor für die Schnittpunktberechnung oben ist dann:</p>
</div>
<div class="stemblock">
<div class="content">
\[\boldsymbol{n} = (\boldsymbol{b} - \boldsymbol{a}) \times (\boldsymbol{c} - \boldsymbol{a})\]
</div>
</div>
<div class="paragraph">
<p>Nach Einsetzen und Auflösen nach <em>r</em> und <em>s</em> kann man prüfen, ob sowohl <em>r</em> als auch <em>s</em> zwischen 0 und 1 liegen (Bedingung 3).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Nachdem nun die Mathematik klar ist, hier nochmal die Zusammenfassung des Angeklickt-Prüf-Algorithmus:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(Vorberechnung: Normalenvektoren, Seitenvektoren der Flächen)</p>
</li>
<li>
<p>Prüfung ob Sichtgeradenvektor und Normalenvektor der Ebene zueinander zeigen (Skalarprodukt der Vektoren liefert (absoluten) Winkel &lt; 90°) (damit ist auch der Fall "Gerade liegt parallel zur Ebene" ausgeschlossen)</p>
</li>
<li>
<p>Berechnung Schnittpunkt (Geradenfaktor <em>t</em>) und Test, ob im Interval [ 0..1]</p>
</li>
<li>
<p>Berechnung Punkt in Ebene (Faktoren <em>r</em> und <em>s</em>) und Test, ob im Interval [0..1]</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Falls statt einer rechteckigen Ebene ein Dreieck getestet wird, so muss bei der Schnittpunktprüfung gelten:</p>
</div>
<div class="paragraph">
<p>\(r \ge 0\), \(s \ge 0\) und \(r + s \le 1\)</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_die_pick_implementierung">7.1.3. Die pick-Implementierung</h4>
<div class="paragraph">
<p>Die Funktion <code>pick()</code> oben wird um den Aufruf der eigentlichen Auswahl-/Markierfunktion erweitert:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp::pick()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">pick</span><span class="p">(</span><span class="k">const</span> <span class="n">QPoint</span> <span class="o">&amp;</span> <span class="n">globalMousePos</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>

	<span class="c1">// now do the actual picking - for now we implement a selection</span>
	<span class="n">selectNearestObject</span><span class="p">(</span><span class="n">nearResult</span><span class="p">.</span><span class="n">toVector3D</span><span class="p">(),</span> <span class="n">farResult</span><span class="p">.</span><span class="n">toVector3D</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>selectNearestObject()</code> wird mit Start- und Endpunkt der Sichtlinie aufgerufen und ist selbst auch recht kompakt:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp::selectNearestObject()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">selectNearestObject</span><span class="p">(</span><span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">nearPoint</span><span class="p">,</span> <span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">farPoint</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QElapsedTimer</span> <span class="n">pickTimer</span><span class="p">;</span>
	<span class="n">pickTimer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>

	<span class="c1">// compute view direction</span>
	<span class="n">QVector3D</span> <span class="n">d</span> <span class="o">=</span> <span class="n">farPoint</span> <span class="o">-</span> <span class="n">nearPoint</span><span class="p">;</span>

	<span class="c1">// create pick object</span>
	<span class="n">PickObject</span> <span class="n">p</span><span class="p">(</span><span class="o">-</span><span class="mf">10000000.</span><span class="n">f</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>

	<span class="c1">// now process all objects and update p to hold the closest hit</span>
	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">pick</span><span class="p">(</span><span class="n">nearPoint</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="c1">// ... other objects</span>

	<span class="c1">// any object accepted a pick?</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">m_objectId</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span> <span class="c1">// nothing selected</span>

	<span class="n">qDebug</span><span class="p">().</span><span class="n">nospace</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Pick successful (Box #"</span>
					   <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_objectId</span> <span class="o">&lt;&lt;</span>  <span class="s">", Face #"</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_faceId</span> <span class="o">&lt;&lt;</span> <span class="s">", z = "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">m_z</span> <span class="o">&lt;&lt;</span> <span class="s">") after "</span>
					   <span class="o">&lt;&lt;</span> <span class="n">pickTimer</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" ms"</span><span class="p">;</span>

	<span class="c1">// Mind: OpenGL-context must be current when we call this function!</span>
	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">highlight</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">m_objectId</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">m_faceId</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zum Testen der Performance hab ich in die Funktion einen Timer reingelegt (siehe Kapitel <em>Picking Performance</em> unten). Den Timer und die <code>qDebug()</code>-Ausgabe kann man aber getrost rauswerfen.</p>
</div>
<div class="paragraph">
<p>In der Funktion wird zuerst der Linienvektor <strong>d</strong> berechnet. Dann wird ein <code>PickObject</code> (eine Struktur mit Infos über angeklickte Objekte) erstellt und deren z-Wert ganz weit hinten initialisiert. Dann geht man alle Zeichenobjekte durch (bzw. alle Datenstrukturen, die Modellgeometrien enthalten) und testet alle enthaltenen Flächen auf Kollision mit dem Sichtstrahl. In diesem Tutorial gibt es nur ein Zeichenobjekt (<code>m_boxObject</code>), aber das Schema ist klar.</p>
</div>
<div class="paragraph">
<p>Hinterher kann man über Vergleich der Objekt-ID mit dem Initialisierungswert (hier größter <code>unsigned int</code>) prüfen, ob überhaupt eine Fläche getroffen wurde.</p>
</div>
<div class="paragraph">
<p>Und zuletzt kann man durch Aufruf der Funktion <code>BoxObject::highlight()</code> noch das angeklickte Objekt hervorheben (siehe Abschnitt <em>Einfärben ausgewählter Objekte</em> weiter unten).</p>
</div>
<div class="paragraph">
<p>Die ganze Arbeit der Kollisionsprüfung erfolgt und <code>BoxObject::pick()</code> und davon aufgerufenen Funktionen:</p>
</div>
<div class="listingblock">
<div class="title">BoxObject.cpp::pick()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxObject</span><span class="o">::</span><span class="n">pick</span><span class="p">(</span><span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="n">PickObject</span> <span class="o">&amp;</span> <span class="n">po</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="c1">// now process all box objects</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m_boxes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">BoxMesh</span> <span class="o">&amp;</span> <span class="n">bm</span> <span class="o">=</span> <span class="n">m_boxes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
			<span class="c1">// is intersection point closes to viewer than previous intersection points?</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">po</span><span class="p">.</span><span class="n">m_z</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">po</span><span class="p">.</span><span class="n">m_z</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
					<span class="n">po</span><span class="p">.</span><span class="n">m_objectId</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">po</span><span class="p">.</span><span class="n">m_faceId</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In dieser Funktion wird letztlich jede Box einzeln geprüft, und in jeder Box jede einzelne Fläche. Der eigentliche Schnittpunkt-Test erfolgt in der Funktion <code>BoxMesh::intersects()</code>.  Wurde ein Schnittpunkte gefunden, aktualisiert man die <code>PickObject</code> Struktur, aber nur, wenn das Objekt dichter am Betrachter liegt (größerer z-Wert).</p>
</div>
<div class="listingblock">
<div class="title">BoxMesh.cpp::intersects()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="n">BoxMesh</span><span class="o">::</span><span class="n">intersects</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">planeIdx</span><span class="p">,</span> <span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&amp;</span> <span class="n">z</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">Rect</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">m_planeInfo</span><span class="p">[</span><span class="n">planeIdx</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">intersectsRect</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">m_a</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">m_b</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">m_normal</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">m_offset</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier wird die objektunabhängige Schnittpunkt-Testfunktion <code>intersectsRect</code> aufgerufen, und dieser Funktion die für den mathematischen Algorithmus oben benötigten Parameter der aktuell gewählten Seite (mit Index <code>planeIdx</code>) übergeben. Das sind die Parameter der Ebenegleichung (<strong>a</strong>, <strong>b</strong>, <strong>n</strong>, <strong>offset</strong>) und die Parameter der Sichtline <strong>p1</strong> und <strong>d</strong>. Die z-Koordinate des gefundenen Schnittpunkts wird im Falle eines Treffers in das Argument <strong>z</strong> eingetragen.</p>
</div>
<div class="paragraph">
<p>Die Parameter der Seitenfläche werden bei Übertragung der Boxobjekt-Koordinante in den Vertexpuffer aktualisiert (dann sind die Vertexkoordinaten des Boxobjekts bereits transformiert).</p>
</div>
<div class="paragraph">
<p>Der oben beschriebene mathematische Algorithmus zur Schnittpunkterkennung steckt nun in der Funktion <code>intersectsRect()</code>:</p>
</div>
<div class="listingblock">
<div class="title">PickObject.cpp:intersectsRect()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">intersectsRect</span><span class="p">(</span><span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">normal</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span>
				<span class="kt">float</span> <span class="o">&amp;</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// first the normal test</span>
	<span class="kt">double</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">QVector3D</span><span class="o">::</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span><span class="o">/</span><span class="n">qAbs</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// same direction, no intersection possible</span>

	<span class="c1">// intersection point on line</span>
	<span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="n">QVector3D</span><span class="o">::</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">p1</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">/</span> <span class="n">QVector3D</span><span class="o">::</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
	<span class="c1">// outside viewing range?</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">QVector3D</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="c1">// now determine location on plane</span>
	<span class="n">QVector3D</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span> <span class="c1">// right hand side of equation system:  a * x  +  b * y = (x - offset)</span>

	<span class="c1">// we have three possible ways to get the intersection point, try them all until we succeed</span>
	<span class="kt">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
	<span class="c1">// rows 1 and 2</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>   <span class="p">{</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="n">z</span><span class="p">();</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
		<span class="k">else</span>			                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// rows 1 and 3</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">z</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>   <span class="p">{</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="n">z</span><span class="p">();</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
		<span class="k">else</span>			                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// rows 2 and 3</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">z</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">z</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>   <span class="p">{</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="n">z</span><span class="p">();</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
		<span class="k">else</span>			                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im Prinzip ist das 1-zu-1 der Algorithmus oben, mit der Prüfung der 3 Bedingungen. Bei der Berechnung der Parameter der Ebenengleichungen gibt es letztlich 3 Variante, wobei durchaus 2 davon je nach Lage der Ebene und Sichtlinie fehlschlagen können.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Liegt beispielsweise eine Fläche in der x-y Ebene, d.h. z = 0 und Normalenvektor = [0,0,1]. Dann wären z.B. <strong>a</strong> = [4,0,0] und <strong>b</strong> = [0,2,0]. Die Ebene wird von einem Sichtstrahl durchstoßen, mit <strong>d</strong> = [-1,-1,-1].</p>
</div>
<div class="paragraph">
<p>Die Gleichungssysteme 2 und 3 sind damit nicht lösbar, da die Determinante jeweils zu 0 wird. Ähnliches kann für andere Ebenenausrichtungen passieren, weswegen alle 3 Kombinationen getestet werden müssen.</p>
</div>
<div class="paragraph">
<p>Man kann das bei der Box und den 6 Seiten sehr schön sehen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Vorne und Hinten benötigen Gleichungssystem 1</p>
</li>
<li>
<p>Links und Rechts benötigen Gleichungssystem 3</p>
</li>
<li>
<p>Oben und Unten benötigen Gleichungssystem 2</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Lösungsfunktion ist einfach eine Implementierung der Cramerschen Regel (<a href="https://de.wikipedia.org/wiki/Cramersche_Regel" class="bare">https://de.wikipedia.org/wiki/Cramersche_Regel</a>):</p>
</div>
<div class="listingblock">
<div class="title">PickObject.cpp:solve()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cm">/* Solves equation system with Cramer's rule:
	 a x + c y = e
	 b x + d y = f
*/</span>
<span class="kt">bool</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">,</span> <span class="kt">double</span> <span class="n">e</span><span class="p">,</span> <span class="kt">double</span> <span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">double</span> <span class="n">det</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">det</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">det</span><span class="p">;</span>
	<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">f</span> <span class="o">-</span> <span class="n">e</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">det</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_picking_performance">7.1.4. Picking Performance</h4>
<div class="paragraph">
<p>Anhand der möglicherweise vielen Flächen in einer komplexen Szene mag man auf die Idee kommen, dass die CPU-basierte Schnittpunktberechnung zu langsam wäre. Machen wir mal den Test:</p>
</div>
<div class="paragraph">
<p>1 Mio Boxen (<code>BoxObject.cpp:Zeile 34</code>), macht 6 Mio Flächen. Im Debug Modus dauert die Schnittpunktberechnung mit <em>allen</em> Flächen nach obigem Algorithmus insgesamt ca. 240 ms. Da lohnt es sich nicht, irgendwelche Performanceoptimierungen zu untersuchen (wie BSD- oder Octrees zur Partitionierung des Raumes etc., was man so in anderen Texten dazu findet).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Möchte man Hervorhebungen wie bei einem "mouse over"-Effekt implementieren, sollte man versuchen, die Strahlensverfolgungszeit in den Bereich &lt; 30 ms zu bekommen, damit das bei Bildwiederholraten von 60 Hz immer noch einigermaßen flüssig aussieht. Dies kann z.B. mit OpenMP Parallelisierung erfolgen, oder durch Beschränkung des Suchraums, z.B. durch Verwendung eines dichter am Beobachter liegenden <em>farplane</em> - Punktes (also statt z=-1 z=-0.2 oder so verwenden) - damit fallen viele Ebenen bereits bei Bedingung 2 raus und man spart deutlich Rechenzeit.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_einfärben_ausgewählter_objekte">7.1.5. Einfärben ausgewählter Objekte</h4>
<div class="paragraph">
<p>Ist nun Objekt und Seite identifiziert, so möchte man das jeweilige Objekt vielleicht hervorheben. Dafür müssen die entsprechenden Vertex-Farbeigenschaften geändert werden.</p>
</div>
<div class="paragraph">
<p>Auch dies ist wieder nicht übermäßig kompliziert, da die Datenstrukturen in <em>Tutorial 05</em> bereits in geeigneter Form angelegt wurden, als hätte man geahnt, dass man sowas mal brauchen würde :-):</p>
</div>
<div class="listingblock">
<div class="title">BoxObject:highlight()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxObject</span><span class="o">::</span><span class="n">highlight</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">boxId</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">faceId</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// we change the color of all vertexes of the selected box to lightgray</span>
	<span class="c1">// and the vertex colors of the selected plane/face to light blue</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="n">faceCols</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">faceId</span><span class="p">)</span>			<span class="n">faceCols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">QColor</span><span class="p">(</span><span class="s">"#b40808"</span><span class="p">);</span>
		<span class="k">else</span>			            <span class="n">faceCols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">QColor</span><span class="p">(</span><span class="s">"#f3f3f3"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">m_boxes</span><span class="p">[</span><span class="n">boxId</span><span class="p">].</span><span class="n">setFaceColors</span><span class="p">(</span><span class="n">faceCols</span><span class="p">);</span>

	<span class="c1">// then we update the respective portion of the vertexbuffer memory</span>
	<span class="n">Vertex</span> <span class="o">*</span> <span class="n">vertexBuffer</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">GLuint</span> <span class="o">*</span> <span class="n">elementBuffer</span> <span class="o">=</span> <span class="n">m_elementBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="c1">// advance pointers to position of the box</span>

	<span class="n">vertexBuffer</span> <span class="o">+=</span> <span class="n">boxId</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// 6 planes, with 4 vertexes each</span>
	<span class="n">elementBuffer</span> <span class="o">+=</span> <span class="n">boxId</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">6</span><span class="p">;</span> <span class="c1">// 6 planes, with 2 triangles with 3 indexes each</span>
	<span class="n">vertexCount</span> <span class="o">+=</span> <span class="n">boxId</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">m_boxes</span><span class="p">[</span><span class="n">boxId</span><span class="p">].</span><span class="n">copy2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">vertexCount</span><span class="p">);</span>

	<span class="c1">// and now update the entire vertex buffer</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">));</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Am Ende der Funktion wird der gesamte Vertexpuffer in die Grafikkarte kopiert. Bei größeren Objekten (&gt; 1 Mio Elemente) kann das dann schonmal etwas dauern. Daher gibt es auch die Funktion <code>QOpenGLBuffer::write()</code>, welche nur einen Teil des Puffers ersetzt. Dann müsste die Funktion so angepasst werden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">BoxObject</span><span class="o">::</span><span class="n">highlight</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">boxId</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">faceId</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>

	<span class="c1">// and now update the respective portion of the vertex buffer</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">boxId</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">),</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">boxId</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Vertex</span><span class="p">));</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>QOpenGLBuffer::write()</code> ruft intern <code>glBufferSubData(GL_ARRAY_BUFFER, offset, count, data)</code> auf. Wichtig ist hier das Verständnis der Parameter der Funktion <code>QOpenGLBuffer::write(int offset, const void *data, int count)</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>offset</em> - Byte offset</p>
</li>
<li>
<p><em>data</em> - Zeiger auf die Daten, die hineinkopiert werden sollen (das Offset wird hier nicht angewendet!)</p>
</li>
<li>
<p><em>count</em> - Anzahl der Bytes zum kopieren</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Man darf also nicht den Fehler machen, und <code>m_vertexBufferData.data()</code> als zweites Argument übergeben, sondern muss auch hier den Zeiger auf den Beginn des modifizierten Bereiches vorrücken <code>m_vertexBufferData.data() + boxId*6*4</code>.</p>
</div>
<div class="paragraph">
<p>Was bringt die Änderung? Bei 1 Mio Boxen dauert die Variante mit <code>allocate()</code> ca. 160 ms (Debugmodus), mit <code>write()</code> deutlich weniger als 1 ms.</p>
</div>
<div class="paragraph">
<p>Natürlich sollte man sich die markierten Boxen merken, sodass man die Markierung hinterher wieder entfernen kann. Das sollte selbst aber nicht übermäßig kompliziert sein.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Ähnlich, wie hier die Farben in den Vertexdaten aktualisiert wurden, kann man auch geometrische Objekte verschieben. Also bei Mausbewegung (und bspw. gedrückter linker Maustaste) die Vertexkoordinaten des markierten Objekts anpassen, den Vertexpuffer aktualisiern und siehe da - Objekte werden verschoben.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_option_2_falschfarbenrendering">7.2. Option 2: Falschfarbenrendering</h3>
<div class="paragraph">
<p>Technisch gibt es eine Einschränkung: es stehen <strong>256^4 - 1</strong> Farben stehen zur Verfügung (rgba) für ebenso viele Elemente. Reicht das nicht aus, muss entweder gefiltert werden (d.h. nur die <em>prinzipiell</em> sichtbaren Objekte bekommen eine Nummer/Farbe), oder man benutzt Ray-Tracking.</p>
</div>
<div class="paragraph">
<p>Die zahlreichen Tutorials zum Thema <em>Picking</em> verwenden die folgende Technik:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Schleife über alle anklickbaren Elemente</p>
<div class="ulist">
<ul>
<li>
<p>Setzen der eindeutigen Farbe je Element via <code>uniform</code> im Shader</p>
</li>
<li>
<p>Zeichen jedes Elements via <code>glDrawXXX</code>-Aufruf</p>
</li>
</ul>
</div>
</li>
<li>
<p>Lesen der Pixelfarbe unter dem Mauscursor</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unnötig zu erwähnen, dass alleine die Vielzahl an <code>glDrawXXX</code> Calls problematisch ist. Außerdem ist es je anch Anwendung nicht notwendig, dieses Prozedere bei <em>jedem</em> Mausklick zu wiederholen.</p>
</div>
<div class="sect3">
<h4 id="_optimierungsidee_für_quasi_statische_szenen">7.2.1. Optimierungsidee für quasi-statische Szenen</h4>
<div class="paragraph">
<p>Nehmen wir mal an, es handelt sich um ein Programm mit vorwiegend nicht-animierten Szenen (Zielvorgabe dieses Tutorials). Dann könnte man die Falschfarbenberechnung stets kurz nach dem Abschluss der Kamerabewegung machen (d.h. mit kleiner Zeitverzögerung), und das resultierende Falschfarbenbild im CPU-Speicher vorhalten. Wenn man nun mit der Maus klickt, hat man sofort den Farbwert unter dem Mauscursor zur Hand. Man könnte auch viele Klicks abfragen, ohne die GPU zu beschäftigen.</p>
</div>
<div class="paragraph">
<p>Ist sicher eine recht einfache Variante und klingt super nach Arbeitseinsparung. Vor allem, wenn bei der Anwendungen ein Auswahl-Klick in der Scene zunächst nur mit irgendeiner Art der Hervorhebung verbunden ist. Die Scene müsste dann zwar neu gezeichnet werden, aber an der Falschfarbendarstellung zur Auswahl ändert sich nichts.</p>
</div>
<div class="paragraph">
<p>Ohne die kleine "mit etwas Verzögerung zeichnen" Optimierung sieht der Algorithmus dann also so aus:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Falls Scenensicht bewegt: zeichnen der Scene in einen Framebuffer, wobei hier der Vertexshader die Farben der Flächen aus einem separaten Farbpuffer holt - dies erlaubt weiterhin die Verwendung von Indexlisten und Vertexarrays</p>
</li>
<li>
<p>Zeichnen der Scene wie gehabt</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Wir bräuchten dafür also:
- ein weiteres ShaderProgramm, welches die Koordinaten aus dem Vertexarray (mit interleaved Storage) liest, aber die Falsch-Farben aus einem <em>separaten Puffer</em> holt
- einen Framebuffer, in den die Falschfarbendarstellung kopiert wird
- eine Möglichkeit, die Farbwerte des Puffers im CPU-Speicher abzulegen
- eine Abfrage der Farbwerte und Identifikation des angeklickten Elements</p>
</div>
<div class="paragraph">
<p>Hmm, wenn ich so darüber nachdenke, dass wir bereits einen funktionierenden und ausreichend schnellen Pickingalgorithmus oben haben, will man sich diesen Aufwand eigentlich nicht machen. Daher lass ich das jetzt mal bleiben und würde das Thema "Falschfarbenrendering" in einem späteren Tutorial zum Zweck der Sichtfaktorberechnung wieder ausbuddeln.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_08_texturen_mit_qopengltexture">8. Tutorial 08: Texturen mit QOpenGLTexture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In diesem Tutorial geht es um Texturen, und die Qt-Klasse <code>QOpenGLTexture</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_08_Textures.png" alt="Tutorial_08">
</div>
<div class="title">Figure 13. Tutorial_08, Texturen</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_08">Tutorial_08</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Verwendung von Texturen ist eigentlich nicht besonders schwierig und wird auch im Qt Beispiel <em>Cube OpenGL ES 2.0 example</em>  und diversen Tutorials im Internet gut erklärt (siehe auch <a href="https://learnopengl.com/Getting-started/Textures" class="bare">https://learnopengl.com/Getting-started/Textures</a>).</p>
</div>
<div class="paragraph">
<p>Aber es gibt da ein paar Dinge, die nicht ganz so trivial sind:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>korrekte Initialisierungsreihenfolge bei Texturen</p>
</li>
<li>
<p>Speicheraufräumen von Texturen</p>
</li>
<li>
<p>Verwendung mehrerer Texturen im Fragment Shader und Verwendung eines <code>glDrawXXX</code>-Aufrufs für viele Flächen unterschiedlicher Texturen</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_initialisierung_von_texturen">8.1. Initialisierung von Texturen</h3>
<div class="paragraph">
<p>wenn man eine Textur mit nativem OpenGL-Code anlegt, sieht das ungefähr so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// erstelle Texturobjekt</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">texture</span><span class="p">;</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
<span class="c1">// binde Textur</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>
<span class="c1">// setze Attribute:</span>

<span class="c1">// Wrap style</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span>

<span class="c1">// Border color in case of GL_CLAMP_TO_BORDER</span>
<span class="kt">float</span> <span class="n">borderColor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="p">};</span>
<span class="n">glTexParameterfv</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_BORDER_COLOR</span><span class="p">,</span> <span class="n">borderColor</span><span class="p">);</span>

<span class="c1">// Texture Filtering</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>

<span class="c1">// Lade Texturdaten mittels 'stb_image.h'</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">stbi_load</span><span class="p">(</span><span class="s">"container.jpg"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nrChannels</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Kopiere Daten in Texture und Erstelle Mipmap</span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Mit <code>QOpenGLTexture</code> ist das Ganze etwas kürzer:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:initializeGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// erstelle Texturobjekt</span>
<span class="n">QOpenGLTexture</span> <span class="o">*</span> <span class="n">texture</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QOpenGLTexture</span><span class="p">(</span><span class="n">QOpenGLTexture</span><span class="o">::</span><span class="n">Target2D</span><span class="p">);</span>
<span class="n">texture</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">();</span>
<span class="c1">// setze Attribute</span>

<span class="c1">// Wrap style</span>
<span class="n">texture</span><span class="o">-&gt;</span><span class="n">setWrapMode</span><span class="p">(</span><span class="n">QOpenGLTexture</span><span class="o">::</span><span class="n">ClampToBorder</span><span class="p">);</span>
<span class="n">texture</span><span class="o">-&gt;</span><span class="n">setBorderColor</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">red</span><span class="p">);</span>

<span class="c1">// Texture Filtering</span>
<span class="n">texture</span><span class="o">-&gt;</span><span class="n">setMinificationFilter</span><span class="p">(</span><span class="n">QOpenGLTexture</span><span class="o">::</span><span class="n">NearestMipMapLinear</span><span class="p">);</span>
<span class="n">texture</span><span class="o">-&gt;</span><span class="n">setMagnificationFilter</span><span class="p">(</span><span class="n">QOpenGLTexture</span><span class="o">::</span><span class="n">Linear</span><span class="p">);</span>

<span class="c1">// Lade Bild</span>
<span class="n">QImage</span> <span class="nf">img</span><span class="p">(</span><span class="s">":/textures/brickwall.jpg"</span><span class="p">);</span>
<span class="c1">// Kopiere Daten in Texture und Erstelle Mipmap</span>
<span class="n">texture</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="n">img</span><span class="p">);</span> <span class="c1">// allocate() will be called internally</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Mipmap-Daten werden standardmäßig beim Aufruf von <code>setData()</code> ohne weitere Parameter generiert.</p>
</div>
<div class="paragraph">
<p>Beim Aufruf von <code>setData()</code> wird automatisch gleich <code>allocate()</code> aufgerufen, und die Bilddaten in die OpenGL-Textur kopiert. Ruft man hinterher nocheinmal <code>allocate()</code> auf, erhält man die Fehlermeldung:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GL_INVALID_OPERATION error generated. Texture is immutable.</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Texturobjekte sind unveränderlich, zumindest was die Eigenschaften des eingebundenen Bildes (und der Mipmap) betrifft. Nach Aufruf von <code>setData()</code> können eigentlich nur noch Attribute geändert werden, die die Interpretation der gebundenen Daten betreffen (also Filter und Wrap-Style). Möchte man die Textur selbst ändern, heißt es Objekt zerstören und neu erstellen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_shader_texture_verknüpfung">8.1.1. Shader-Texture-Verknüpfung</h4>
<div class="paragraph">
<p>Wenn man mehrere Texturen in einem Shader verwendet, muss man dem Shaderprogramm noch mitteilen, unter welcher ID eine Texture zu finden ist.</p>
</div>
<div class="paragraph">
<p>Die Informationskette sieht so aus:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>im Shaderprogram (Fragment-Shader) werden Texturen (<code>sampler2D</code>) benannt, bspw. <em>brickTexture</em> oder <em>roofTiles</em></p>
</li>
<li>
<p>man erfragt deren Parameter/Uniform-Index ab, als wären es gewöhnliche uniform-Variablen  &#8594; <em>brickTextureUniformID</em>, <em>roofTilesUniformID</em>. Mit diesen Variablen-IDs kann man dem Shader Parameter geben.</p>
</li>
<li>
<p>man gibt jeder dieser Variablen eine Texture-ID, also bspw. Variable <em>brickTextureUniformID</em> bekommt Texture #0, und <em>roofTilesUniformID</em> bekommt Texture #1. Das Durchnummerieren der eigenen Texturen ist komplett unabhängig von den Uniform-IDs.</p>
</li>
<li>
<p>vor dem Rendern bindet man die Texturen ein, und gibt dabei die Texturenummer an.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In der Initialisierung sieht das so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_verwendung_der_texture">8.2. Verwendung der Texture</h3>
<div class="paragraph">
<p>Jeder Vertex benötigt nun statt Farben (oder zusätzlich zu den Farben) noch die Texturkoordinaten. Dank der <code>Vertex</code>-Struktur (siehe <em>Tutorial 05</em>) ist die Erweiterung trivial:</p>
</div>
<div class="listingblock">
<div class="title">Vertex.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">....</span>
<span class="n">Vertex</span><span class="p">(</span><span class="k">const</span> <span class="n">QVector3D</span> <span class="o">&amp;</span> <span class="n">coords</span><span class="p">,</span> <span class="k">const</span> <span class="n">QColor</span> <span class="o">&amp;</span> <span class="n">col</span><span class="p">,</span> <span class="kt">float</span> <span class="n">textureX</span><span class="p">,</span> <span class="kt">float</span> <span class="n">textureY</span><span class="p">,</span> <span class="n">GLint</span> <span class="n">textureID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">x</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">x</span><span class="p">())),</span>
	<span class="n">y</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">y</span><span class="p">())),</span>
	<span class="n">z</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">coords</span><span class="p">.</span><span class="n">z</span><span class="p">())),</span>
	<span class="n">r</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">redF</span><span class="p">())),</span>
	<span class="n">g</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">greenF</span><span class="p">())),</span>
	<span class="n">b</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">blueF</span><span class="p">())),</span>
	<span class="n">texi</span><span class="p">(</span><span class="n">textureX</span><span class="p">),</span>
	<span class="n">texj</span><span class="p">(</span><span class="n">textureY</span><span class="p">),</span>
	<span class="n">texID</span><span class="p">(</span><span class="n">textureID</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">texi</span><span class="p">,</span><span class="n">texj</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">texID</span><span class="p">;</span>
<span class="p">....</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Texture-ID wird später benötigt, wenn ein Shader zwischen mehreren Texturen unterscheidet.</p>
</div>
<div class="paragraph">
<p>Nun, da die Vertex-Datenstruktur 3 neue Parameter hat, muss man in <code>BoxMesh.cpp</code> das Erstellen der Vertex-Objekte anpassen:</p>
</div>
<div class="listingblock">
<div class="title">BoxMesh.cpp:copy2Buffer</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// front plane: a, b, c, d, vertexes (0, 1, 2, 3)</span>
<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">);</span>

<span class="c1">// right plane: b=1, f=5, g=6, c=2, vertexes</span>
<span class="c1">// Mind: colors are numbered up</span>
<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">);</span>

<span class="c1">// back plane: g=5, e=4, h=7, g=6</span>
<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">);</span>

<span class="c1">// left plane: 4,0,3,7</span>
<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">);</span>

<span class="c1">// bottom plane: 4,5,1,0</span>
<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">);</span>

<span class="c1">// top plane: 3,2,6,7</span>
<span class="n">copyPlane2Buffer</span><span class="p">(</span><span class="n">vertexBuffer</span><span class="p">,</span> <span class="n">elementBuffer</span><span class="p">,</span> <span class="n">elementStartIndex</span><span class="p">,</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
		<span class="n">Vertex</span><span class="p">(</span><span class="n">m_vertices</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die 2 zusätzlichen Argumente geben die Texturekoordinaten an. bei 0..1 heißt das, dass die Texture genau einmal die Fläche bespannt. Bei 0..2 (z.B. bei der hinteren Fläche) wird durch die Texture-Wrap-Einstellung die Texture zweimal nebeneinander gezeichnet.</p>
</div>
<div class="paragraph">
<p>Der dritte Parameter (bei back, left und top) setzt die Texture-ID (dazu gleich mehr).</p>
</div>
<div class="sect3">
<h4 id="_shader">8.2.1. Shader</h4>
<div class="paragraph">
<p>Nun zur Erweiterung der Shaderprogramme:</p>
</div>
<div class="listingblock">
<div class="title">Vertex Shader <em>withTexture.vert</em></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330
</span>
<span class="c1">// GLSL version 3.3</span>
<span class="c1">// vertex shader</span>

<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>   <span class="c1">// input:  attribute with index '0' with 3 elements per vertex</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">color</span><span class="p">;</span>      <span class="c1">// input:  attribute with index '1' with 3 elements (=rgb) per vertex</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">texcoords</span><span class="p">;</span>  <span class="c1">// input:  attribute with index '2' with 2 elements per vertex</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">in</span> <span class="kt">float</span> <span class="n">texnr</span><span class="p">;</span>     <span class="c1">// input:  attribute with index '3' with 1 float per vertex</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>                      <span class="c1">// output: computed fragmentation color</span>
<span class="n">out</span> <span class="n">vec2</span> <span class="n">texCoord</span><span class="p">;</span>                       <span class="c1">// output: computed texture coordinates</span>
<span class="n">flat</span> <span class="n">out</span> <span class="kt">float</span> <span class="n">texID</span><span class="p">;</span>                    <span class="c1">// output: texture ID - mind the 'flat' attribute!</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">worldToView</span><span class="p">;</span>                <span class="c1">// parameter: the camera matrix</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Mind multiplication order for matrixes</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">worldToView</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">texCoord</span> <span class="o">=</span> <span class="n">texcoords</span><span class="p">;</span>
  <span class="n">texID</span> <span class="o">=</span> <span class="n">texnr</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Vertexshader wird eigentlich nur um die Texture-Koordinaten erweitert, welche unverändert durchgereicht werden. Die Farbe spielt in diesem Beispiel keine Rolle und könnte weggelassen werden, aber der Einfachheit halber lassen wir das mal so.</p>
</div>
<div class="paragraph">
<p>Interessant ist noch das Schlüsselwort <code>flat</code> bei der Ausgabevariable texID. Letztlich hat jede Fläche nur eine TextureID. Diese zwischen Vertexes zu interpolieren, wäre Quatsch. Dass Schlüsselwort <code>flat</code> sagt, dass der Wert vom ersten Vertex des Elements genommen und unverändert an alle Fragmente weitergereicht wird.</p>
</div>
<div class="paragraph">
<p>Die eigentliche Texture wird erst im Fragment-Shaderprogramm verwendet.</p>
</div>
<div class="listingblock">
<div class="title">Fragment Shader <em>texture.frag</em></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// fragment shader</span>

<span class="n">in</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>    <span class="c1">// input: interpolated color as rgba-value</span>
<span class="n">in</span> <span class="n">vec2</span> <span class="n">texCoord</span><span class="p">;</span>     <span class="c1">// input: texture coordinate (xy-coordinates)</span>
<span class="n">flat</span> <span class="n">in</span> <span class="kt">float</span> <span class="n">texID</span><span class="p">;</span>  <span class="c1">// input: textureID</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">finalColor</span><span class="p">;</span>  <span class="c1">// output: final color value as rgba-value</span>

<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">brickTexture</span><span class="p">;</span> <span class="c1">// the wall texture</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">plasterTexture</span><span class="p">;</span> <span class="c1">// the plaster texture</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">rooftiles</span><span class="p">;</span> <span class="c1">// the roof texture</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">texID</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">finalColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">brickTexture</span><span class="p">,</span> <span class="n">texCoord</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">texID</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">finalColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">rooftiles</span><span class="p">,</span> <span class="n">texCoord</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">texID</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">finalColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">plasterTexture</span><span class="p">,</span> <span class="n">texCoord</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">finalColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">texCoord</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Auch hier muss das Schlüsselwort <code>flat</code> verwendet werden, sonst gibt es einen Linker-Fehler beim Shaderprogramm-Verknüpfen. Die Funktion <code>texture</code> interpoliert nun den Wert an der gegebenen Texturekoordinate.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>texture2D</code> sollte im Fragmentshader nicht mehr benutzt werden (deprecated), man findet es dennoch recht häufig in OpenGL-Beispielen.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_einbinden_der_texturen">8.2.2. Einbinden der Texturen</h4>
<div class="paragraph">
<p>Nun muss man vor dem Zeichnen der Boxen noch die Texturen einbinden, wobei man die jeweilige Texturnummer angibt (siehe auch Abschnitt <em>Shader-Texture-Verknüpfung</em> oben).</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// *** render boxes</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setUniformValue</span><span class="p">(</span><span class="n">m_shaderPrograms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">m_uniformIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m_worldToView</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">m_textures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// bind texture #i to texture index i -&gt; accessible in fragment shader through "texture1"</span>

<span class="n">m_gpuTimers</span><span class="p">.</span><span class="n">recordSample</span><span class="p">();</span> <span class="c1">// render boxes</span>
<span class="n">m_boxObject</span><span class="p">.</span><span class="n">render</span><span class="p">();</span>
<span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In diesem Beispiel konnte man sehen, wie man mit einem Shader mehrere Texturen verwenden kann. Üblicherweise kann man maximal 16 Texturen verwenden. Daher ist bei großen Szenen mit sehr vielen Texturen ein Aufteilen in mehrere <code>drawXXX</code>- Aufrufe unumgänglich.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_09_render_in_eine_framebuffer_und_verwendung_von_kernel_effekten">9. Tutorial 09: Render in eine Framebuffer und Verwendung von Kernel Effekten</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_09_FramebufferImageKernel.png" alt="Tutorial_09">
</div>
<div class="title">Figure 14. Tutorial_09, Framebuffer mit Kernel-Effekten</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_09">Tutorial_09</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In dem Tutorial soll die Szene zunächst in einem Framebuffer gerendert werden, welche dann unter Verwendung eines Image-Postprocessing-Kernels auf den Bildschirm übertragen wird. Im Prinzip wird das Gleiche gemacht, wie in <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" class="bare">https://learnopengl.com/Advanced-OpenGL/Framebuffers</a> (dieses Tutorial zu lesen, dürfte beim Verständnis des Quelltextes unten helfen).</p>
</div>
<div class="sect2">
<h3 id="_initialisierung_des_framebuffers">9.1. Initialisierung des Framebuffers</h3>
<div class="paragraph">
<p>Mit OpenGL muss man den Framebuffer, den Tiefen- und Ausstanzpufferanhang (<em>depth and stencil attachment</em>) erstellen, und eine Textur für die Farbwerte anhängen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// framebuffer configuration</span>
<span class="c1">// -------------------------</span>
<span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">framebuffer</span><span class="p">);</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span>
<span class="c1">// create a color attachment texture</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureColorbuffer</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureColorbuffer</span><span class="p">);</span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">scr_width</span><span class="p">,</span> <span class="n">scr_height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
<span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureColorbuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// create a renderbuffer object for depth and stencil attachment (we won't be sampling these)</span>
<span class="n">glGenRenderbuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbo</span><span class="p">);</span>
<span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span>
<span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="n">scr_width</span><span class="p">,</span> <span class="n">scr_height</span><span class="p">);</span> <span class="c1">// use a single renderbuffer object for both a depth AND stencil buffer.</span>
<span class="n">glFramebufferRenderbuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_STENCIL_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span> <span class="c1">// now actually attach it</span>
<span class="c1">// now that we actually created the framebuffer and added all attachments we want to check if it is actually complete now</span>
<span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span>
	<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"ERROR::FRAMEBUFFER:: Framebuffer is not complete!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Solange man nicht Spezielles machen will, können diese vielen Zeilen einfach durch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m_frameBufferObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QOpenGLFramebufferObject</span><span class="p">(</span><span class="n">QSize</span><span class="p">(</span><span class="n">scr_width</span><span class="p">,</span> <span class="n">scr_height</span><span class="p">),</span> <span class="n">QOpenGLFramebufferObject</span><span class="o">::</span><span class="n">CombinedDepthStencil</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ersetzen.</p>
</div>
</div>
<div class="sect2">
<h3 id="_größenanpassung">9.2. Größenanpassung</h3>
<div class="paragraph">
<p>Wenn man die Fenstergröße verändert, muss man auch die Größe der Puffer anpassen. Dies geschieht sinnvollerweise in <code>resizeGL()</code> und sieht mit nativem OpenGL so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// also resize the texture buffer</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureColorbuffer</span><span class="p">);</span>
<span class="c1">// actual resize operation</span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">scr_width</span><span class="p">,</span> <span class="n">scr_height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span>
<span class="c1">// actual resize operation</span>
<span class="n">glRenderbufferStorage</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="n">scr_width</span><span class="p">,</span> <span class="n">scr_height</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Bei Verwendung der <code>QOpenGLFrameBufferObject</code>-Klasse muss man einfach das Klassenobjekt neu erstellen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">delete</span> <span class="n">m_frameBufferObject</span><span class="p">;</span>
<span class="n">m_frameBufferObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QOpenGLFramebufferObject</span><span class="p">(</span><span class="n">QSize</span><span class="p">(</span><span class="n">scr_width</span><span class="p">,</span> <span class="n">scr_height</span><span class="p">),</span> <span class="n">QOpenGLFramebufferObject</span><span class="o">::</span><span class="n">CombinedDepthStencil</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rendern_in_den_framebuffer">9.3. Rendern in den Framebuffer</h3>
<div class="paragraph">
<p>Erst wird der Framebuffer eingebunden, mit nativem OpenGL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mit <code>QOpenGLFrameBufferObject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m_frameBufferObject</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Nach Rendern der Szene dann wieder zurücksetzen des normalen Renderbuffers, mit nativem OpenGL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>mit <code>QOpenGLFrameBufferObject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m_frameBufferObject</span><span class="o">-&gt;</span><span class="n">bindDefault</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>und einbinden der Textur zur Verwendung mit dem ScreenFill-Shader und Rechteck. Wieder mit OpenGL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureColorbuffer</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>und mit <code>QOpenGLFrameBufferObject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">m_frameBufferObject</span><span class="o">-&gt;</span><span class="n">texture</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das war&#8217;s auch schon. Der Quelltext für <em>Tutorial 09</em> enthält eine komplette Verwendung (und in einem früherem git Commit ist die native OpenGL-Variante drin).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_10_shadowmapsmehrfach_render_passes_und_qopenglframebufferobject">10. Tutorial 10: Shadowmaps/Mehrfach-Render-Passes und QOpenGLFramebufferObject</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO : Schattenwurf durch doppeltes Rendern (erst Kamera in Sonnenposition in Framebuffer rendern, dann diesen als Texturinput für den 2. Renderpass nehmen).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_xx_cmake_als_buildsystem_für_qt_und_opengl_und_deployment_von_qtopengl_anwendungen">11. Tutorial xx: CMake als BuildSystem für Qt und OpenGL, und Deployment von Qt+OpenGL Anwendungen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Für das automatische Bauen von Qt (z.B. mit Jenkins oder ähnlichen Build-Systemen) bietet sich CMake an. Es geht zwar auch mit qmake, aber in diesem Tutorial soll gezeigt werden, wie man das eine CMakeLists.txt-Datei für das Bauen von Qt-Anwendungen unter Linux, MacOS und Windows konfiguriert.</p>
</div>
<div class="paragraph">
<p>Im zweiten Teil des Tutorials geht es dann um das Deployment, d.h. welche Dateien jeweils kopiert werden müssen. Auch dies ist nicht wirklich OpenGL-spezifisch, aber zeigt nochmal, welche OpenGL-Bibliotheken auf den jeweiligen Betriebssystemen vorausgesetzt werden können, und welche kopiert werden müssen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>CMakeLists.txt - Dateien und entsprechende Build-Scripte liegen verschiedenen Tutorial-Quelltexten bei. Konkret beziehen sich die Beispiele unten auf den Tutorial 06 Quelltext, der im github repo liegt:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_06">Tutorial_06</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_cmakelists_txt_für_opengl_anwendungen">11.1. CMakeLists.txt für OpenGL-Anwendungen</h3>
<div class="paragraph">
<p>Hier ist eine Beispiel-CMakeLists.txt-Datei (aus Tutorial 05), welche das mal demonstriert:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cmake"><span class="c1"># CMakeLists.txt file for OpenGL + Qt Tutorial Series</span>

<span class="c1"># The project name</span>
<span class="nb">project</span><span class="p">(</span> Tutorial_06 <span class="p">)</span>

<span class="c1"># Require a fairly recent cmake version</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span> VERSION 2.8.12 <span class="p">)</span>

<span class="c1"># Set default build type</span>
<span class="nb">if</span> <span class="p">(</span>NOT CMAKE_BUILD_TYPE<span class="p">)</span>
	<span class="nb">set</span><span class="p">(</span> CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING
		<span class="s2">"Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."</span> FORCE<span class="p">)</span>
<span class="nb">endif</span> <span class="p">(</span>NOT CMAKE_BUILD_TYPE<span class="p">)</span>

<span class="c1"># -------------------------------------------------------------</span>
<span class="c1"># Packages</span>
<span class="c1"># -------------------------------------------------------------</span>

<span class="c1"># Test for Qt5 modules</span>
<span class="nb">find_package</span><span class="p">(</span>Qt5Widgets REQUIRED<span class="p">)</span>

<span class="c1"># set corresponding libraries</span>
<span class="nb">set</span><span class="p">(</span> QT_LIBRARIES
	Qt5::Widgets
<span class="p">)</span>

<span class="c1"># we need OpenGL</span>
<span class="nb">find_package</span><span class="p">(</span> OpenGL REQUIRED <span class="p">)</span>


<span class="c1"># -------------------------------------------------------------</span>
<span class="c1"># Application</span>
<span class="c1"># -------------------------------------------------------------</span>

<span class="c1"># automatically add CMAKE_CURRENT_SOURCE_DIR and CMAKE_CURRENT_BINARY_DIR to the include directories in every processed CMakeLists.txt</span>
<span class="nb">set</span><span class="p">(</span> CMAKE_INCLUDE_CURRENT_DIR ON <span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span>
	<span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>		<span class="c1"># needed so that ui-generated header files find our own headers</span>
	<span class="si">${</span><span class="nv">Qt5Widgets_INCLUDE_DIRS</span><span class="si">}</span>
<span class="p">)</span>

<span class="c1"># collect a list of all designer ui files</span>
<span class="nb">file</span><span class="p">(</span> GLOB APP_UIS <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/*.ui <span class="p">)</span>

<span class="c1"># collect a list of all header files (to be used in MOC compiler)</span>
<span class="nb">file</span><span class="p">(</span> GLOB APP_HDRS <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/*.h <span class="p">)</span>

<span class="c1"># collect a list of all source files in this directory</span>
<span class="nb">file</span><span class="p">(</span> GLOB APP_SRCS <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/*.cpp <span class="p">)</span>

<span class="c1"># collect the Qt resource files (*.qrc)</span>
<span class="nb">file</span><span class="p">(</span> GLOB APP_QRCS <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/*.qrc <span class="p">)</span>

<span class="c1"># look for Windows rc file</span>
<span class="nb">file</span><span class="p">(</span> GLOB APP_WIN_RC <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/*.rc <span class="p">)</span>

<span class="c1"># look for Apple icns file</span>
<span class="nb">file</span><span class="p">(</span> GLOB APP_MACOS_ICNS <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/*.icns <span class="p">)</span>

<span class="nf">qt5_wrap_ui</span><span class="p">(</span> APP_UI_SRCS <span class="si">${</span><span class="nv">APP_UIS</span><span class="si">}</span> <span class="p">)</span>
<span class="nf">qt5_add_resources</span><span class="p">(</span> APP_RC_SRCS <span class="si">${</span><span class="nv">APP_QRCS</span><span class="si">}</span> <span class="p">)</span>
<span class="nf">qt5_wrap_cpp</span><span class="p">(</span> APP_MOC_SRCS <span class="si">${</span><span class="nv">APP_HDRS</span><span class="si">}</span> <span class="p">)</span>

<span class="c1"># build application executable for the different platforms</span>
<span class="nb">if</span><span class="p">(</span> WIN32 <span class="p">)</span>
	<span class="nb">add_executable</span><span class="p">(</span> <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> WIN32
					<span class="si">${</span><span class="nv">APP_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_MOC_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_RC_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_UI_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_WIN_RC</span><span class="si">}</span>
	<span class="p">)</span>

	<span class="c1"># enable console window (to see debug/profiler messages)</span>
	<span class="nb">set_target_properties</span><span class="p">(</span> <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PROPERTIES LINK_FLAGS <span class="s2">"/SUBSYSTEM:CONSOLE"</span> <span class="p">)</span>
<span class="nb">endif</span><span class="p">(</span> WIN32 <span class="p">)</span>

<span class="nb">if</span><span class="p">(</span> UNIX <span class="p">)</span>
	<span class="nb">if</span><span class="p">(</span> APPLE <span class="p">)</span>
		<span class="nb">add_executable</span><span class="p">(</span> <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> MACOSX_BUNDLE
						<span class="si">${</span><span class="nv">APP_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_MOC_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_RC_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_UI_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_MACOS_ICNS</span><span class="si">}</span>
		<span class="p">)</span>
	<span class="nb">else</span><span class="p">(</span> APPLE <span class="p">)</span>
		<span class="nb">add_executable</span><span class="p">(</span> <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span>
						<span class="si">${</span><span class="nv">APP_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_MOC_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_RC_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">APP_UI_SRCS</span><span class="si">}</span>
		<span class="p">)</span>
	<span class="nb">endif</span><span class="p">(</span> APPLE <span class="p">)</span>
<span class="nb">endif</span><span class="p">(</span> UNIX <span class="p">)</span>


<span class="c1"># link libraries</span>
<span class="nb">target_link_libraries</span><span class="p">(</span> <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span>
	<span class="si">${</span><span class="nv">QT_LIBRARIES</span><span class="si">}</span>
	<span class="si">${</span><span class="nv">OPENGL_LIBRARIES</span><span class="si">}</span>
<span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Script selbst ist eigentlich nicht schwer zu verstehen (eventuell kann man mal die CMake-Syntax und Befehle auf <a href="https://cmake.org" class="bare">https://cmake.org</a> nachschlagen). Je nachdem, welche Qt-Module verwendet werden, müsste man die Sektion "Packages" noch entsprechend erweitern.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Unter Windows lohnt es sich (zumindest während der Entwicklung), das Konsolenfenster einzublenden, damit man <code>qDebug()</code>-Ausgaben sieht. Das wird mit der Zeile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cmake"><span class="nb">set_target_properties</span><span class="p">(</span> <span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PROPERTIES LINK_FLAGS <span class="s2">"/SUBSYSTEM:CONSOLE"</span> <span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>eingeschaltet.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_erstellung">11.1.1. Erstellung</h4>
<div class="sect4">
<h5 id="_linux">Linux</h5>
<div class="paragraph">
<p>Um Quelltexte und Resourcendateien nicht mit den generierten Dateien in einem Verzeichnis zu haben, lohnt sich ein <em>out-of-source</em> build, d.h. in einem getrennte Verzeichnis. Beispielsweise kann man parallel zum <code>Tutorial_05</code>-Verzeichnis noch ein Verzeichnis <code>build_Tutorial_05</code> anlegen. In diesem Verzeichnis reichen dann folgende Befehle zur Erstellung aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">cmake <span class="nt">-DCMAKE_BUILD_TYPE</span>:String<span class="o">=</span><span class="s2">"Release"</span> ../Tutorial_05
make <span class="nt">-j4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Argument <code>-DCMAKE_BUILD_TYPE:String="Release"</code> legt ein Release-Build fest, Standard ist Debug. <code>-j4</code> legt beim make das Erstellen mit 4 parallelen Jobs fest.</p>
</div>
</div>
<div class="sect4">
<h5 id="_mit_eigener_qt_version_bauen">Mit eigener Qt Version bauen</h5>
<div class="paragraph">
<p>Falls nicht das systemweit installierte Qt verwendet werden soll, kann man auch den <code>CMAKE_PREFIX_PATH</code> auf eine eigene Qt Installation umbiegen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="nb">export </span><span class="nv">CMAKE_PREFIX_PATH</span><span class="o">=</span>~/Qt/5.14.1/gcc_64
cmake <span class="nt">-DCMAKE_BUILD_TYPE</span>:String<span class="o">=</span><span class="s2">"Release"</span> ../Tutorial_05
make <span class="nt">-j4</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_macos">MacOS</h5>
<div class="paragraph">
<p>Ganz genauso wie unter Linux.</p>
</div>
</div>
<div class="sect4">
<h5 id="_windows">Windows</h5>
<div class="paragraph">
<p>Fast genauso wie unter Linux, nur eben mit Batch-Befehlen. Hier ist ein Beispiel für die Verwendung eines VC-Compilers, bereits als Batch-Datei zusammengestellt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="batch">@echo <span class="na">off</span>

<span class="c">:: cl compiler path</span>
<span class="k">call</span> <span class="s2">"c:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat"</span> <span class="kd">x64</span>

<span class="c">:: path to Qt</span>
<span class="kd">set</span> <span class="kd">CMAKE_PREFIX_PATH</span><span class="o">=</span><span class="kd">c</span>:\Qt\5.11.3\msvc2015_64

<span class="c">:: configure in release mode, to build with JOM</span>
<span class="kd">cmake</span> <span class="na">-G </span><span class="s2">"NMake Makefiles JOM"</span> <span class="na">-DCMAKE</span>_BUILD_TYPE:String<span class="o">=</span><span class="s2">"Release"</span> ..\Tutorial_05

<span class="c">:: build</span>
<span class="kd">jom</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Natürlich muss man die Pfade zum VC Compiler und zur Qt Installation im Batch-Script oben anpassen.</p>
</div>
<div class="paragraph">
<p>Alternativ kann man unter Windows CMake auch dazu benutzen, VC Projektdateien zu erstellen, aber wenn man Qt Creator hat, wer braucht dann VC als Editor?</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deployment">11.1.2. Deployment</h4>
<div class="sect4">
<h5 id="_windows_2">Windows</h5>
<div class="paragraph">
<p>Nachdem man unter Windows die Anwendung kompiliert hat, muss man noch die zur Verteilung benötigten DLLs zusammenstellen. Dies geht am einfachsten durch Verwendung des <code>windeployqt</code> Tools. Ein Aufruf sieht wie folgt aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="batch"><span class="c">:: path to Qt</span>
<span class="kd">set</span> <span class="kd">CMAKE_PREFIX_PATH</span><span class="o">=</span><span class="kd">c</span>:\Qt\5.11.3\msvc2015_64

<span class="c">:: copy dependencies</span>
<span class="nv">%CMAKE_PREFIX_PATH%</span>\bin\windeployqt <span class="kd">vc_x64_deploy</span>\Tutorial_06.exe</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die vom Tool ins Verzeichnis kopierten Dateien werden für die Ausführung benötigt. Es sind zumeist nicht alle Dateien notwendig, das hängt aber vom jeweiligen Programm ab. Anstelle die <code>redist.exe</code> auf dem Zielsystem auszuführen, kann man auch die benötigten VC DLLS direkt mit kopieren, also bspw. <code>msvcp140.dll</code> und <code>vcruntime140.dll</code> bei VC 2015.</p>
</div>
<div class="paragraph">
<p>Die Dateien befinden sich z.B. in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>c:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\redist\x64\Microsoft.VC140.CRT</pre>
</div>
</div>
<div class="paragraph">
<p>Sind alle benötigten Dateien im gleichen Verzeichnis wie die <code>.exe</code>-Datei, sollte man das Programm auf anderen Windows-Rechnern starten können (als Portable-Version).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es bietet sich an, das Deployment nicht im Erstellungsverzeichnis durchzuführen. Die Beispielskripte <code>build.bat</code>  und  <code>deploy.bat</code> im Tutorial 06 Quelltext zeigen, wie man Erstellung und Deployment in separaten Unterverzeichnissen durchführt. Dann kann man vereinfacht auch das gesamte Deployment-Verzeichnis packen und hat sofort ein "Portable"-Release der Software.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_macos_2">MacOS</h5>
<div class="paragraph">
<p>Unter MacOS wird eine Qt Anwendung üblicherweise gegen die installierten Frameworks gebaut. Man kann sich das anschauen, wenn man mit <code>otool</code> to gelinkten Bibliotheken anschaut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; otool -L Tutorial_05.app/Contents/MacOS/Tutorial_05
Tutorial_05.app/Contents/MacOS/Tutorial_05:
	@rpath/QtWidgets.framework/Versions/5/QtWidgets (compatibility version 5.11.0, current version 5.11.3)
	/System/Library/Frameworks/OpenGL.framework/Versions/A/OpenGL (compatibility version 1.0.0, current version 1.0.0)
	@rpath/QtGui.framework/Versions/5/QtGui (compatibility version 5.11.0, current version 5.11.3)
	@rpath/QtCore.framework/Versions/5/QtCore (compatibility version 5.11.0, current version 5.11.3)
	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 120.1.0)
	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1226.10.1)</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.7.0<br>
Last updated 2020-04-14 10:15:06 +0200
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>